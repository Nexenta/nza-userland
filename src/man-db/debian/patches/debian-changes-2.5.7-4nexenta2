Description: Upstream changes introduced in version 2.5.7-4nexenta2
 This patch has been created by dpkg-source during the package build.
 Here's the last changelog entry, hopefully it gives details on why
 those changes were made:
 .
 man-db (2.5.7-4nexenta2) unstable; urgency=low
 .
   * Updated to NCP4
 .
 The person named in the Author field signed this changelog entry.
Author: Igor Kozhukhov <igor.kozhukhov@nexenta.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- /dev/null
+++ man-db-2.5.7/lex.yy.c
@@ -0,0 +1,1772 @@
+
+#line 3 "lex.yy.c"
+
+#define  YY_INT_ALIGNED short int
+
+/* A lexical scanner generated by flex */
+
+#define FLEX_SCANNER
+#define YY_FLEX_MAJOR_VERSION 2
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
+#if YY_FLEX_SUBMINOR_VERSION > 0
+#define FLEX_BETA
+#endif
+
+/* First, we deal with  platform-specific or compiler-specific issues. */
+
+/* begin standard C headers. */
+#include <stdio.h>
+#include <string.h>
+#include <errno.h>
+#include <stdlib.h>
+
+/* end standard C headers. */
+
+/* flex integer type definitions */
+
+#ifndef FLEXINT_H
+#define FLEXINT_H
+
+/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+
+#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
+#include <inttypes.h>
+typedef int8_t flex_int8_t;
+typedef uint8_t flex_uint8_t;
+typedef int16_t flex_int16_t;
+typedef uint16_t flex_uint16_t;
+typedef int32_t flex_int32_t;
+typedef uint32_t flex_uint32_t;
+#else
+typedef signed char flex_int8_t;
+typedef short int flex_int16_t;
+typedef int flex_int32_t;
+typedef unsigned char flex_uint8_t; 
+typedef unsigned short int flex_uint16_t;
+typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
+
+/* Limits of integral types. */
+#ifndef INT8_MIN
+#define INT8_MIN               (-128)
+#endif
+#ifndef INT16_MIN
+#define INT16_MIN              (-32767-1)
+#endif
+#ifndef INT32_MIN
+#define INT32_MIN              (-2147483647-1)
+#endif
+#ifndef INT8_MAX
+#define INT8_MAX               (127)
+#endif
+#ifndef INT16_MAX
+#define INT16_MAX              (32767)
+#endif
+#ifndef INT32_MAX
+#define INT32_MAX              (2147483647)
+#endif
+#ifndef UINT8_MAX
+#define UINT8_MAX              (255U)
+#endif
+#ifndef UINT16_MAX
+#define UINT16_MAX             (65535U)
+#endif
+#ifndef UINT32_MAX
+#define UINT32_MAX             (4294967295U)
+#endif
+
+#endif /* ! FLEXINT_H */
+
+#ifdef __cplusplus
+
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
+
+#else	/* ! __cplusplus */
+
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
+
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
+#else
+#define yyconst
+#endif
+
+/* Returned upon end-of-file. */
+#define YY_NULL 0
+
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
+ */
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+
+/* Enter a start condition.  This macro really ought to take a parameter,
+ * but we do it the disgusting crufty way forced on us by the ()-less
+ * definition of BEGIN.
+ */
+#define BEGIN (yy_start) = 1 + 2 *
+
+/* Translate the current start state into a value that can be later handed
+ * to BEGIN to return to the state.  The YYSTATE alias is for lex
+ * compatibility.
+ */
+#define YY_START (((yy_start) - 1) / 2)
+#define YYSTATE YY_START
+
+/* Action number for EOF rule of a given start state. */
+#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
+/* Special action meaning "start processing a new file". */
+#define YY_NEW_FILE yyrestart(yyin  )
+
+#define YY_END_OF_BUFFER_CHAR 0
+
+/* Size of default input buffer. */
+#ifndef YY_BUF_SIZE
+#define YY_BUF_SIZE 16384
+#endif
+
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
+#ifndef YY_TYPEDEF_YY_BUFFER_STATE
+#define YY_TYPEDEF_YY_BUFFER_STATE
+typedef struct yy_buffer_state *YY_BUFFER_STATE;
+#endif
+
+extern int yyleng;
+
+extern FILE *yyin, *yyout;
+
+#define EOB_ACT_CONTINUE_SCAN 0
+#define EOB_ACT_END_OF_FILE 1
+#define EOB_ACT_LAST_MATCH 2
+
+    #define YY_LESS_LINENO(n)
+    
+/* Return all but the first "n" matched characters back to the input stream. */
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		*yy_cp = (yy_hold_char); \
+		YY_RESTORE_YY_MORE_OFFSET \
+		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+		} \
+	while ( 0 )
+
+#define unput(c) yyunput( c, (yytext_ptr)  )
+
+#ifndef YY_TYPEDEF_YY_SIZE_T
+#define YY_TYPEDEF_YY_SIZE_T
+typedef size_t yy_size_t;
+#endif
+
+#ifndef YY_STRUCT_YY_BUFFER_STATE
+#define YY_STRUCT_YY_BUFFER_STATE
+struct yy_buffer_state
+	{
+	FILE *yy_input_file;
+
+	char *yy_ch_buf;		/* input buffer */
+	char *yy_buf_pos;		/* current position in input buffer */
+
+	/* Size of input buffer in bytes, not including room for EOB
+	 * characters.
+	 */
+	yy_size_t yy_buf_size;
+
+	/* Number of characters read into yy_ch_buf, not including EOB
+	 * characters.
+	 */
+	int yy_n_chars;
+
+	/* Whether we "own" the buffer - i.e., we know we created it,
+	 * and can realloc() it to grow it, and should free() it to
+	 * delete it.
+	 */
+	int yy_is_our_buffer;
+
+	/* Whether this is an "interactive" input source; if so, and
+	 * if we're using stdio for input, then we want to use getc()
+	 * instead of fread(), to make sure we stop fetching input after
+	 * each newline.
+	 */
+	int yy_is_interactive;
+
+	/* Whether we're considered to be at the beginning of a line.
+	 * If so, '^' rules will be active on the next match, otherwise
+	 * not.
+	 */
+	int yy_at_bol;
+
+    int yy_bs_lineno; /**< The line count. */
+    int yy_bs_column; /**< The column count. */
+    
+	/* Whether to try to fill the input buffer when we reach the
+	 * end of it.
+	 */
+	int yy_fill_buffer;
+
+	int yy_buffer_status;
+
+#define YY_BUFFER_NEW 0
+#define YY_BUFFER_NORMAL 1
+	/* When an EOF's been seen but there's still some text to process
+	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+	 * shouldn't try reading from the input source any more.  We might
+	 * still have a bunch of tokens to match, though, because of
+	 * possible backing-up.
+	 *
+	 * When we actually see the EOF, we change the status to "new"
+	 * (via yyrestart()), so that the user can continue scanning by
+	 * just pointing yyin at a new input file.
+	 */
+#define YY_BUFFER_EOF_PENDING 2
+
+	};
+#endif /* !YY_STRUCT_YY_BUFFER_STATE */
+
+/* Stack of input buffers. */
+static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+
+/* We provide macros for accessing buffer states in case in the
+ * future we want to put the buffer states in a more general
+ * "scanner state".
+ *
+ * Returns the top of the stack, or NULL.
+ */
+#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+                          : NULL)
+
+/* Same as previous macro, but useful when we know that the buffer stack is not
+ * NULL or when we need an lvalue. For internal use only.
+ */
+#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+
+/* yy_hold_char holds the character lost when yytext is formed. */
+static char yy_hold_char;
+static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+int yyleng;
+
+/* Points to current character in buffer. */
+static char *yy_c_buf_p = (char *) 0;
+static int yy_init = 0;		/* whether we need to initialize */
+static int yy_start = 0;	/* start state number */
+
+/* Flag which is used to allow yywrap()'s to do buffer switches
+ * instead of setting up a fresh yyin.  A bit of a hack ...
+ */
+static int yy_did_buffer_switch_on_eof;
+
+void yyrestart (FILE *input_file  );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+void yy_delete_buffer (YY_BUFFER_STATE b  );
+void yy_flush_buffer (YY_BUFFER_STATE b  );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+void yypop_buffer_state (void );
+
+static void yyensure_buffer_stack (void );
+static void yy_load_buffer_state (void );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+
+void *yyalloc (yy_size_t  );
+void *yyrealloc (void *,yy_size_t  );
+void yyfree (void *  );
+
+#define yy_new_buffer yy_create_buffer
+
+#define yy_set_interactive(is_interactive) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){ \
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+	}
+
+#define yy_set_bol(at_bol) \
+	{ \
+	if ( ! YY_CURRENT_BUFFER ){\
+        yyensure_buffer_stack (); \
+		YY_CURRENT_BUFFER_LVALUE =    \
+            yy_create_buffer(yyin,YY_BUF_SIZE ); \
+	} \
+	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+	}
+
+#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+
+/* Begin user sect3 */
+
+typedef unsigned char YY_CHAR;
+
+FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+
+typedef int yy_state_type;
+
+extern int yylineno;
+
+int yylineno = 1;
+
+extern char *yytext;
+#define yytext_ptr yytext
+
+static yy_state_type yy_get_previous_state (void );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+static int yy_get_next_buffer (void );
+static void yy_fatal_error (yyconst char msg[]  );
+
+/* Done after the current pattern has been matched and before the
+ * corresponding action - sets up yytext.
+ */
+#define YY_DO_BEFORE_ACTION \
+	(yytext_ptr) = yy_bp; \
+	(yytext_ptr) -= (yy_more_len); \
+	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
+	(yy_hold_char) = *yy_cp; \
+	*yy_cp = '\0'; \
+	(yy_c_buf_p) = yy_cp;
+
+#define YY_NUM_RULES 8
+#define YY_END_OF_BUFFER 9
+/* This struct is not used in this scanner,
+   but its presence is necessary. */
+struct yy_trans_info
+	{
+	flex_int32_t yy_verify;
+	flex_int32_t yy_nxt;
+	};
+static yyconst flex_int16_t yy_acclist[23] =
+    {   0,
+        9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
+        3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
+        7,    8
+    } ;
+
+static yyconst flex_int16_t yy_accept[14] =
+    {   0,
+        1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
+       20,   23,   23
+    } ;
+
+static yyconst flex_int32_t yy_ec[256] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
+
+        7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+        1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int32_t yy_meta[9] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1
+    } ;
+
+static yyconst flex_int16_t yy_base[13] =
+    {   0,
+        0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
+       10,   10
+    } ;
+
+static yyconst flex_int16_t yy_def[13] =
+    {   0,
+       12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
+       12,    0
+    } ;
+
+static yyconst flex_int16_t yy_nxt[19] =
+    {   0,
+        4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
+       12,   12,   12,   12,   12,   12,   12,   12
+    } ;
+
+static yyconst flex_int16_t yy_chk[19] =
+    {   0,
+        1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
+       12,   12,   12,   12,   12,   12,   12,   12
+    } ;
+
+extern int yy_flex_debug;
+int yy_flex_debug = 0;
+
+static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
+static char *yy_full_match;
+static int yy_lp;
+#define REJECT \
+{ \
+*yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
+yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
+++(yy_lp); \
+goto find_rule; \
+}
+
+static int yy_more_flag = 0;
+static int yy_more_len = 0;
+#define yymore() ((yy_more_flag) = 1)
+#define YY_MORE_ADJ (yy_more_len)
+#define YY_RESTORE_YY_MORE_OFFSET
+char *yytext;
+#line 1 "conftest.l"
+#line 468 "lex.yy.c"
+
+#define INITIAL 0
+
+#ifndef YY_NO_UNISTD_H
+/* Special case for "unistd.h", since it is non-ANSI. We include it way
+ * down here because we want the user's section 1 to have been scanned first.
+ * The user has a chance to override it with an option.
+ */
+#include <unistd.h>
+#endif
+
+#ifndef YY_EXTRA_TYPE
+#define YY_EXTRA_TYPE void *
+#endif
+
+static int yy_init_globals (void );
+
+/* Accessor methods to globals.
+   These are made visible to non-reentrant scanners for convenience. */
+
+int yylex_destroy (void );
+
+int yyget_debug (void );
+
+void yyset_debug (int debug_flag  );
+
+YY_EXTRA_TYPE yyget_extra (void );
+
+void yyset_extra (YY_EXTRA_TYPE user_defined  );
+
+FILE *yyget_in (void );
+
+void yyset_in  (FILE * in_str  );
+
+FILE *yyget_out (void );
+
+void yyset_out  (FILE * out_str  );
+
+int yyget_leng (void );
+
+char *yyget_text (void );
+
+int yyget_lineno (void );
+
+void yyset_lineno (int line_number  );
+
+/* Macros after this point can all be overridden by user definitions in
+ * section 1.
+ */
+
+#ifndef YY_SKIP_YYWRAP
+#ifdef __cplusplus
+extern "C" int yywrap (void );
+#else
+extern int yywrap (void );
+#endif
+#endif
+
+    static void yyunput (int c,char *buf_ptr  );
+    
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char *,yyconst char *,int );
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * );
+#endif
+
+#ifndef YY_NO_INPUT
+
+#ifdef __cplusplus
+static int yyinput (void );
+#else
+static int input (void );
+#endif
+
+#endif
+
+/* Amount of stuff to slurp up with each read. */
+#ifndef YY_READ_BUF_SIZE
+#define YY_READ_BUF_SIZE 8192
+#endif
+
+/* Copy whatever the last rule matched to the standard output. */
+#ifndef ECHO
+/* This used to be an fputs(), but since the string might contain NUL's,
+ * we now use fwrite().
+ */
+#define ECHO fwrite( yytext, yyleng, 1, yyout )
+#endif
+
+/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+ * is returned in "result".
+ */
+#ifndef YY_INPUT
+#define YY_INPUT(buf,result,max_size) \
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+		{ \
+		int c = '*'; \
+		int n; \
+		for ( n = 0; n < max_size && \
+			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+			buf[n] = (char) c; \
+		if ( c == '\n' ) \
+			buf[n++] = (char) c; \
+		if ( c == EOF && ferror( yyin ) ) \
+			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+		result = n; \
+		} \
+	else \
+		{ \
+		errno=0; \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+			{ \
+			if( errno != EINTR) \
+				{ \
+				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+				break; \
+				} \
+			errno=0; \
+			clearerr(yyin); \
+			} \
+		}\
+\
+
+#endif
+
+/* No semi-colon after return; correct usage is to write "yyterminate();" -
+ * we don't want an extra ';' after the "return" because that will cause
+ * some compilers to complain about unreachable statements.
+ */
+#ifndef yyterminate
+#define yyterminate() return YY_NULL
+#endif
+
+/* Number of entries by which start-condition stack grows. */
+#ifndef YY_START_STACK_INCR
+#define YY_START_STACK_INCR 25
+#endif
+
+/* Report a fatal error. */
+#ifndef YY_FATAL_ERROR
+#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+#endif
+
+/* end tables serialization structures and prototypes */
+
+/* Default declaration of generated scanner - a define so the user can
+ * easily add parameters.
+ */
+#ifndef YY_DECL
+#define YY_DECL_IS_OURS 1
+
+extern int yylex (void);
+
+#define YY_DECL int yylex (void)
+#endif /* !YY_DECL */
+
+/* Code executed at the beginning of each rule, after yytext and yyleng
+ * have been set up.
+ */
+#ifndef YY_USER_ACTION
+#define YY_USER_ACTION
+#endif
+
+/* Code executed at the end of each rule. */
+#ifndef YY_BREAK
+#define YY_BREAK break;
+#endif
+
+#define YY_RULE_SETUP \
+	YY_USER_ACTION
+
+/** The main scanner function which does all the work.
+ */
+YY_DECL
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
+    
+#line 1 "conftest.l"
+
+#line 652 "lex.yy.c"
+
+	if ( !(yy_init) )
+		{
+		(yy_init) = 1;
+
+#ifdef YY_USER_INIT
+		YY_USER_INIT;
+#endif
+
+        /* Create the reject buffer large enough to save one state per allowed character. */
+        if ( ! (yy_state_buf) )
+            (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
+            if ( ! (yy_state_buf) )
+                YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
+
+		if ( ! (yy_start) )
+			(yy_start) = 1;	/* first start state */
+
+		if ( ! yyin )
+			yyin = stdin;
+
+		if ( ! yyout )
+			yyout = stdout;
+
+		if ( ! YY_CURRENT_BUFFER ) {
+			yyensure_buffer_stack ();
+			YY_CURRENT_BUFFER_LVALUE =
+				yy_create_buffer(yyin,YY_BUF_SIZE );
+		}
+
+		yy_load_buffer_state( );
+		}
+
+	while ( 1 )		/* loops until end-of-file is reached */
+		{
+		(yy_more_len) = 0;
+		if ( (yy_more_flag) )
+			{
+			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
+			(yy_more_flag) = 0;
+			}
+		yy_cp = (yy_c_buf_p);
+
+		/* Support of yytext. */
+		*yy_cp = (yy_hold_char);
+
+		/* yy_bp points to the position in yy_ch_buf of the start of
+		 * the current run.
+		 */
+		yy_bp = yy_cp;
+
+		yy_current_state = (yy_start);
+
+		(yy_state_ptr) = (yy_state_buf);
+		*(yy_state_ptr)++ = yy_current_state;
+
+yy_match:
+		do
+			{
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+				{
+				yy_current_state = (int) yy_def[yy_current_state];
+				if ( yy_current_state >= 13 )
+					yy_c = yy_meta[(unsigned int) yy_c];
+				}
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+			*(yy_state_ptr)++ = yy_current_state;
+			++yy_cp;
+			}
+		while ( yy_base[yy_current_state] != 10 );
+
+yy_find_action:
+		yy_current_state = *--(yy_state_ptr);
+		(yy_lp) = yy_accept[yy_current_state];
+find_rule: /* we branch to this label when backing up */
+		for ( ; ; ) /* until we find what rule we matched */
+			{
+			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
+				{
+				yy_act = yy_acclist[(yy_lp)];
+					{
+					(yy_full_match) = yy_cp;
+					break;
+					}
+				}
+			--yy_cp;
+			yy_current_state = *--(yy_state_ptr);
+			(yy_lp) = yy_accept[yy_current_state];
+			}
+
+		YY_DO_BEFORE_ACTION;
+
+do_action:	/* This label is used only to access EOF actions. */
+
+		switch ( yy_act )
+	{ /* beginning of action switch */
+case 1:
+YY_RULE_SETUP
+#line 2 "conftest.l"
+{ ECHO; }
+	YY_BREAK
+case 2:
+YY_RULE_SETUP
+#line 3 "conftest.l"
+{ REJECT; }
+	YY_BREAK
+case 3:
+YY_RULE_SETUP
+#line 4 "conftest.l"
+{ yymore (); }
+	YY_BREAK
+case 4:
+YY_RULE_SETUP
+#line 5 "conftest.l"
+{ yyless (1); }
+	YY_BREAK
+case 5:
+YY_RULE_SETUP
+#line 6 "conftest.l"
+{ yyless (input () != 0); }
+	YY_BREAK
+case 6:
+YY_RULE_SETUP
+#line 7 "conftest.l"
+{ unput (yytext[0]); }
+	YY_BREAK
+case 7:
+YY_RULE_SETUP
+#line 8 "conftest.l"
+{ BEGIN INITIAL; }
+	YY_BREAK
+case 8:
+YY_RULE_SETUP
+#line 9 "conftest.l"
+ECHO;
+	YY_BREAK
+#line 790 "lex.yy.c"
+			case YY_STATE_EOF(INITIAL):
+				yyterminate();
+
+	case YY_END_OF_BUFFER:
+		{
+		/* Amount of text matched not including the EOB char. */
+		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+
+		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+		*yy_cp = (yy_hold_char);
+		YY_RESTORE_YY_MORE_OFFSET
+
+		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+			{
+			/* We're scanning a new file or input source.  It's
+			 * possible that this happened because the user
+			 * just pointed yyin at a new source and called
+			 * yylex().  If so, then we have to assure
+			 * consistency between YY_CURRENT_BUFFER and our
+			 * globals.  Here is the right place to do so, because
+			 * this is the first action (other than possibly a
+			 * back-up) that will match for the new input source.
+			 */
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+			}
+
+		/* Note that here we test for yy_c_buf_p "<=" to the position
+		 * of the first EOB in the buffer, since yy_c_buf_p will
+		 * already have been incremented past the NUL character
+		 * (since all states make transitions on EOB to the
+		 * end-of-buffer state).  Contrast this with the test
+		 * in input().
+		 */
+		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			{ /* This was really a NUL. */
+			yy_state_type yy_next_state;
+
+			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+
+			yy_current_state = yy_get_previous_state(  );
+
+			/* Okay, we're now positioned to make the NUL
+			 * transition.  We couldn't have
+			 * yy_get_previous_state() go ahead and do it
+			 * for us because it doesn't know how to deal
+			 * with the possibility of jamming (and we don't
+			 * want to build jamming into it because then it
+			 * will run more slowly).
+			 */
+
+			yy_next_state = yy_try_NUL_trans( yy_current_state );
+
+			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+
+			if ( yy_next_state )
+				{
+				/* Consume the NUL. */
+				yy_cp = ++(yy_c_buf_p);
+				yy_current_state = yy_next_state;
+				goto yy_match;
+				}
+
+			else
+				{
+				yy_cp = (yy_c_buf_p);
+				goto yy_find_action;
+				}
+			}
+
+		else switch ( yy_get_next_buffer(  ) )
+			{
+			case EOB_ACT_END_OF_FILE:
+				{
+				(yy_did_buffer_switch_on_eof) = 0;
+
+				if ( yywrap( ) )
+					{
+					/* Note: because we've taken care in
+					 * yy_get_next_buffer() to have set up
+					 * yytext, we can now set up
+					 * yy_c_buf_p so that if some total
+					 * hoser (like flex itself) wants to
+					 * call the scanner after we return the
+					 * YY_NULL, it'll still work - another
+					 * YY_NULL will get returned.
+					 */
+					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+
+					yy_act = YY_STATE_EOF(YY_START);
+					goto do_action;
+					}
+
+				else
+					{
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+					}
+				break;
+				}
+
+			case EOB_ACT_CONTINUE_SCAN:
+				(yy_c_buf_p) =
+					(yytext_ptr) + yy_amount_of_matched_text;
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_match;
+
+			case EOB_ACT_LAST_MATCH:
+				(yy_c_buf_p) =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+
+				yy_current_state = yy_get_previous_state(  );
+
+				yy_cp = (yy_c_buf_p);
+				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+				goto yy_find_action;
+			}
+		break;
+		}
+
+	default:
+		YY_FATAL_ERROR(
+			"fatal flex scanner internal error--no action found" );
+	} /* end of action switch */
+		} /* end of scanning one token */
+} /* end of yylex */
+
+/* yy_get_next_buffer - try to read in a new buffer
+ *
+ * Returns a code representing an action:
+ *	EOB_ACT_LAST_MATCH -
+ *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+ *	EOB_ACT_END_OF_FILE - end of file
+ */
+static int yy_get_next_buffer (void)
+{
+    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = (yytext_ptr);
+	register int number_to_move, i;
+	int ret_val;
+
+	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+		YY_FATAL_ERROR(
+		"fatal flex scanner internal error--end of buffer missed" );
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+		{ /* Don't try to fill the buffer, so this is an EOF. */
+		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+			{
+			/* We matched a single character, the EOB, so
+			 * treat this as a final EOF.
+			 */
+			return EOB_ACT_END_OF_FILE;
+			}
+
+		else
+			{
+			/* We matched some text prior to the EOB, first
+			 * process it.
+			 */
+			return EOB_ACT_LAST_MATCH;
+			}
+		}
+
+	/* Try to read more data. */
+
+	/* First move last chars to start of buffer. */
+	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+
+	for ( i = 0; i < number_to_move; ++i )
+		*(dest++) = *(source++);
+
+	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+		/* don't do the read, it's not guaranteed to return an EOF,
+		 * just force an EOF
+		 */
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+
+	else
+		{
+			int num_to_read =
+			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+
+		while ( num_to_read <= 0 )
+			{ /* Not enough room in the buffer - grow it. */
+
+			YY_FATAL_ERROR(
+"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+
+			}
+
+		if ( num_to_read > YY_READ_BUF_SIZE )
+			num_to_read = YY_READ_BUF_SIZE;
+
+		/* Read in more data. */
+		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+			(yy_n_chars), (size_t) num_to_read );
+
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	if ( (yy_n_chars) == 0 )
+		{
+		if ( number_to_move == YY_MORE_ADJ )
+			{
+			ret_val = EOB_ACT_END_OF_FILE;
+			yyrestart(yyin  );
+			}
+
+		else
+			{
+			ret_val = EOB_ACT_LAST_MATCH;
+			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+				YY_BUFFER_EOF_PENDING;
+			}
+		}
+
+	else
+		ret_val = EOB_ACT_CONTINUE_SCAN;
+
+	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+		/* Extend the array by 50%, plus the number we really need. */
+		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+	}
+
+	(yy_n_chars) += number_to_move;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+
+	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+
+	return ret_val;
+}
+
+/* yy_get_previous_state - get the state just before the EOB char was reached */
+
+    static yy_state_type yy_get_previous_state (void)
+{
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
+    
+	yy_current_state = (yy_start);
+
+	(yy_state_ptr) = (yy_state_buf);
+	*(yy_state_ptr)++ = yy_current_state;
+
+	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+		{
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+			{
+			yy_current_state = (int) yy_def[yy_current_state];
+			if ( yy_current_state >= 13 )
+				yy_c = yy_meta[(unsigned int) yy_c];
+			}
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+		*(yy_state_ptr)++ = yy_current_state;
+		}
+
+	return yy_current_state;
+}
+
+/* yy_try_NUL_trans - try to make a transition on the NUL character
+ *
+ * synopsis
+ *	next_state = yy_try_NUL_trans( current_state );
+ */
+    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+{
+	register int yy_is_jam;
+    
+	register YY_CHAR yy_c = 1;
+	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+		{
+		yy_current_state = (int) yy_def[yy_current_state];
+		if ( yy_current_state >= 13 )
+			yy_c = yy_meta[(unsigned int) yy_c];
+		}
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 12);
+	if ( ! yy_is_jam )
+		*(yy_state_ptr)++ = yy_current_state;
+
+	return yy_is_jam ? 0 : yy_current_state;
+}
+
+    static void yyunput (int c, register char * yy_bp )
+{
+	register char *yy_cp;
+    
+    yy_cp = (yy_c_buf_p);
+
+	/* undo effects of setting up yytext */
+	*yy_cp = (yy_hold_char);
+
+	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+		{ /* need to shift things up to make room */
+		/* +2 for EOB chars. */
+		register int number_to_move = (yy_n_chars) + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+		register char *source =
+				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+
+		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+			*--dest = *--source;
+
+		yy_cp += (int) (dest - source);
+		yy_bp += (int) (dest - source);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+
+		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+		}
+
+	*--yy_cp = (char) c;
+
+	(yytext_ptr) = yy_bp;
+	(yy_hold_char) = *yy_cp;
+	(yy_c_buf_p) = yy_cp;
+}
+
+#ifndef YY_NO_INPUT
+#ifdef __cplusplus
+    static int yyinput (void)
+#else
+    static int input  (void)
+#endif
+
+{
+	int c;
+    
+	*(yy_c_buf_p) = (yy_hold_char);
+
+	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+		{
+		/* yy_c_buf_p now points to the character we want to return.
+		 * If this occurs *before* the EOB characters, then it's a
+		 * valid NUL; if not, then we've hit the end of the buffer.
+		 */
+		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+			/* This was really a NUL. */
+			*(yy_c_buf_p) = '\0';
+
+		else
+			{ /* need more input */
+			int offset = (yy_c_buf_p) - (yytext_ptr);
+			++(yy_c_buf_p);
+
+			switch ( yy_get_next_buffer(  ) )
+				{
+				case EOB_ACT_LAST_MATCH:
+					/* This happens because yy_g_n_b()
+					 * sees that we've accumulated a
+					 * token and flags that we need to
+					 * try matching the token before
+					 * proceeding.  But for input(),
+					 * there's no matching to consider.
+					 * So convert the EOB_ACT_LAST_MATCH
+					 * to EOB_ACT_END_OF_FILE.
+					 */
+
+					/* Reset buffer status. */
+					yyrestart(yyin );
+
+					/*FALLTHROUGH*/
+
+				case EOB_ACT_END_OF_FILE:
+					{
+					if ( yywrap( ) )
+						return EOF;
+
+					if ( ! (yy_did_buffer_switch_on_eof) )
+						YY_NEW_FILE;
+#ifdef __cplusplus
+					return yyinput();
+#else
+					return input();
+#endif
+					}
+
+				case EOB_ACT_CONTINUE_SCAN:
+					(yy_c_buf_p) = (yytext_ptr) + offset;
+					break;
+				}
+			}
+		}
+
+	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+	(yy_hold_char) = *++(yy_c_buf_p);
+
+	return c;
+}
+#endif	/* ifndef YY_NO_INPUT */
+
+/** Immediately switch to a different input stream.
+ * @param input_file A readable stream.
+ * 
+ * @note This function does not reset the start condition to @c INITIAL .
+ */
+    void yyrestart  (FILE * input_file )
+{
+    
+	if ( ! YY_CURRENT_BUFFER ){
+        yyensure_buffer_stack ();
+		YY_CURRENT_BUFFER_LVALUE =
+            yy_create_buffer(yyin,YY_BUF_SIZE );
+	}
+
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+	yy_load_buffer_state( );
+}
+
+/** Switch to a different input buffer.
+ * @param new_buffer The new input buffer.
+ * 
+ */
+    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+{
+    
+	/* TODO. We should be able to replace this entire function body
+	 * with
+	 *		yypop_buffer_state();
+	 *		yypush_buffer_state(new_buffer);
+     */
+	yyensure_buffer_stack ();
+	if ( YY_CURRENT_BUFFER == new_buffer )
+		return;
+
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+	yy_load_buffer_state( );
+
+	/* We don't actually know whether we did this switch during
+	 * EOF (yywrap()) processing, but the only time this flag
+	 * is looked at is after yywrap() is called, so it's safe
+	 * to go ahead and always set it.
+	 */
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+static void yy_load_buffer_state  (void)
+{
+    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+	(yy_hold_char) = *(yy_c_buf_p);
+}
+
+/** Allocate and initialize an input buffer state.
+ * @param file A readable stream.
+ * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+ * 
+ * @return the allocated buffer state.
+ */
+    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+{
+	YY_BUFFER_STATE b;
+    
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_buf_size = size;
+
+	/* yy_ch_buf has to be 2 characters longer than the size given because
+	 * we need to put in 2 end-of-buffer characters.
+	 */
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+	if ( ! b->yy_ch_buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+
+	b->yy_is_our_buffer = 1;
+
+	yy_init_buffer(b,file );
+
+	return b;
+}
+
+/** Destroy the buffer.
+ * @param b a buffer created with yy_create_buffer()
+ * 
+ */
+    void yy_delete_buffer (YY_BUFFER_STATE  b )
+{
+    
+	if ( ! b )
+		return;
+
+	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+
+	if ( b->yy_is_our_buffer )
+		yyfree((void *) b->yy_ch_buf  );
+
+	yyfree((void *) b  );
+}
+
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
+/* Initializes or reinitializes a buffer.
+ * This function is sometimes called more than once on the same buffer,
+ * such as during a yyrestart() or at EOF.
+ */
+    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+
+{
+	int oerrno = errno;
+    
+	yy_flush_buffer(b );
+
+	b->yy_input_file = file;
+	b->yy_fill_buffer = 1;
+
+    /* If b is the current buffer, then yy_init_buffer was _probably_
+     * called from yyrestart() or through yy_get_next_buffer.
+     * In that case, we don't want to reset the lineno or column.
+     */
+    if (b != YY_CURRENT_BUFFER){
+        b->yy_bs_lineno = 1;
+        b->yy_bs_column = 0;
+    }
+
+        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+    
+	errno = oerrno;
+}
+
+/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+ * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+ * 
+ */
+    void yy_flush_buffer (YY_BUFFER_STATE  b )
+{
+    	if ( ! b )
+		return;
+
+	b->yy_n_chars = 0;
+
+	/* We always need two end-of-buffer characters.  The first causes
+	 * a transition to the end-of-buffer state.  The second causes
+	 * a jam in that state.
+	 */
+	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+
+	b->yy_buf_pos = &b->yy_ch_buf[0];
+
+	b->yy_at_bol = 1;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	if ( b == YY_CURRENT_BUFFER )
+		yy_load_buffer_state( );
+}
+
+/** Pushes the new state onto the stack. The new state becomes
+ *  the current state. This function will allocate the stack
+ *  if necessary.
+ *  @param new_buffer The new state.
+ *  
+ */
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+{
+    	if (new_buffer == NULL)
+		return;
+
+	yyensure_buffer_stack();
+
+	/* This block is copied from yy_switch_to_buffer. */
+	if ( YY_CURRENT_BUFFER )
+		{
+		/* Flush out information for old buffer. */
+		*(yy_c_buf_p) = (yy_hold_char);
+		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+		}
+
+	/* Only push if top exists. Otherwise, replace top. */
+	if (YY_CURRENT_BUFFER)
+		(yy_buffer_stack_top)++;
+	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+
+	/* copied from yy_switch_to_buffer. */
+	yy_load_buffer_state( );
+	(yy_did_buffer_switch_on_eof) = 1;
+}
+
+/** Removes and deletes the top of the stack, if present.
+ *  The next element becomes the new top.
+ *  
+ */
+void yypop_buffer_state (void)
+{
+    	if (!YY_CURRENT_BUFFER)
+		return;
+
+	yy_delete_buffer(YY_CURRENT_BUFFER );
+	YY_CURRENT_BUFFER_LVALUE = NULL;
+	if ((yy_buffer_stack_top) > 0)
+		--(yy_buffer_stack_top);
+
+	if (YY_CURRENT_BUFFER) {
+		yy_load_buffer_state( );
+		(yy_did_buffer_switch_on_eof) = 1;
+	}
+}
+
+/* Allocates the stack if it does not exist.
+ *  Guarantees space for at least one push.
+ */
+static void yyensure_buffer_stack (void)
+{
+	int num_to_alloc;
+    
+	if (!(yy_buffer_stack)) {
+
+		/* First allocation is just for 2 elements, since we don't know if this
+		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+		 * immediate realloc on the next call.
+         */
+		num_to_alloc = 1;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+								(num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+								  
+		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+				
+		(yy_buffer_stack_max) = num_to_alloc;
+		(yy_buffer_stack_top) = 0;
+		return;
+	}
+
+	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+
+		/* Increase the buffer to prepare for a possible push. */
+		int grow_size = 8 /* arbitrary grow size */;
+
+		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+								((yy_buffer_stack),
+								num_to_alloc * sizeof(struct yy_buffer_state*)
+								);
+		if ( ! (yy_buffer_stack) )
+			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+
+		/* zero only the new slots.*/
+		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+		(yy_buffer_stack_max) = num_to_alloc;
+	}
+}
+
+/** Setup the input buffer state to scan directly from a user-specified character buffer.
+ * @param base the character buffer
+ * @param size the size in bytes of the character buffer
+ * 
+ * @return the newly allocated buffer state object. 
+ */
+YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+{
+	YY_BUFFER_STATE b;
+    
+	if ( size < 2 ||
+	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+		/* They forgot to leave room for the EOB's. */
+		return 0;
+
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+	if ( ! b )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+	b->yy_buf_pos = b->yy_ch_buf = base;
+	b->yy_is_our_buffer = 0;
+	b->yy_input_file = 0;
+	b->yy_n_chars = b->yy_buf_size;
+	b->yy_is_interactive = 0;
+	b->yy_at_bol = 1;
+	b->yy_fill_buffer = 0;
+	b->yy_buffer_status = YY_BUFFER_NEW;
+
+	yy_switch_to_buffer(b  );
+
+	return b;
+}
+
+/** Setup the input buffer state to scan a string. The next call to yylex() will
+ * scan from a @e copy of @a str.
+ * @param yystr a NUL-terminated string to scan
+ * 
+ * @return the newly allocated buffer state object.
+ * @note If you want to scan bytes that may contain NUL values, then use
+ *       yy_scan_bytes() instead.
+ */
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+{
+    
+	return yy_scan_bytes(yystr,strlen(yystr) );
+}
+
+/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+ * scan from a @e copy of @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
+ * 
+ * @return the newly allocated buffer state object.
+ */
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+{
+	YY_BUFFER_STATE b;
+	char *buf;
+	yy_size_t n;
+	int i;
+    
+	/* Get memory for full buffer, including space for trailing EOB's. */
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n  );
+	if ( ! buf )
+		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
+
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+
+	b = yy_scan_buffer(buf,n );
+	if ( ! b )
+		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+
+	/* It's okay to grow etc. this buffer, and we should throw it
+	 * away when we're done.
+	 */
+	b->yy_is_our_buffer = 1;
+
+	return b;
+}
+
+#ifndef YY_EXIT_FAILURE
+#define YY_EXIT_FAILURE 2
+#endif
+
+static void yy_fatal_error (yyconst char* msg )
+{
+    	(void) fprintf( stderr, "%s\n", msg );
+	exit( YY_EXIT_FAILURE );
+}
+
+/* Redefine yyless() so it works in section 3 code. */
+
+#undef yyless
+#define yyless(n) \
+	do \
+		{ \
+		/* Undo effects of setting up yytext. */ \
+        int yyless_macro_arg = (n); \
+        YY_LESS_LINENO(yyless_macro_arg);\
+		yytext[yyleng] = (yy_hold_char); \
+		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+		(yy_hold_char) = *(yy_c_buf_p); \
+		*(yy_c_buf_p) = '\0'; \
+		yyleng = yyless_macro_arg; \
+		} \
+	while ( 0 )
+
+/* Accessor  methods (get/set functions) to struct members. */
+
+/** Get the current line number.
+ * 
+ */
+int yyget_lineno  (void)
+{
+        
+    return yylineno;
+}
+
+/** Get the input stream.
+ * 
+ */
+FILE *yyget_in  (void)
+{
+        return yyin;
+}
+
+/** Get the output stream.
+ * 
+ */
+FILE *yyget_out  (void)
+{
+        return yyout;
+}
+
+/** Get the length of the current token.
+ * 
+ */
+int yyget_leng  (void)
+{
+        return yyleng;
+}
+
+/** Get the current token.
+ * 
+ */
+
+char *yyget_text  (void)
+{
+        return yytext;
+}
+
+/** Set the current line number.
+ * @param line_number
+ * 
+ */
+void yyset_lineno (int  line_number )
+{
+    
+    yylineno = line_number;
+}
+
+/** Set the input stream. This does not discard the current
+ * input buffer.
+ * @param in_str A readable stream.
+ * 
+ * @see yy_switch_to_buffer
+ */
+void yyset_in (FILE *  in_str )
+{
+        yyin = in_str ;
+}
+
+void yyset_out (FILE *  out_str )
+{
+        yyout = out_str ;
+}
+
+int yyget_debug  (void)
+{
+        return yy_flex_debug;
+}
+
+void yyset_debug (int  bdebug )
+{
+        yy_flex_debug = bdebug ;
+}
+
+static int yy_init_globals (void)
+{
+        /* Initialization is the same as for the non-reentrant scanner.
+     * This function is called from yylex_destroy(), so don't allocate here.
+     */
+
+    (yy_buffer_stack) = 0;
+    (yy_buffer_stack_top) = 0;
+    (yy_buffer_stack_max) = 0;
+    (yy_c_buf_p) = (char *) 0;
+    (yy_init) = 0;
+    (yy_start) = 0;
+
+    (yy_state_buf) = 0;
+    (yy_state_ptr) = 0;
+    (yy_full_match) = 0;
+    (yy_lp) = 0;
+
+/* Defined in main.c */
+#ifdef YY_STDINIT
+    yyin = stdin;
+    yyout = stdout;
+#else
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
+#endif
+
+    /* For future reference: Set errno on error, since we are called by
+     * yylex_init()
+     */
+    return 0;
+}
+
+/* yylex_destroy is for both reentrant and non-reentrant scanners. */
+int yylex_destroy  (void)
+{
+    
+    /* Pop the buffer stack, destroying each element. */
+	while(YY_CURRENT_BUFFER){
+		yy_delete_buffer(YY_CURRENT_BUFFER  );
+		YY_CURRENT_BUFFER_LVALUE = NULL;
+		yypop_buffer_state();
+	}
+
+	/* Destroy the stack itself. */
+	yyfree((yy_buffer_stack) );
+	(yy_buffer_stack) = NULL;
+
+    yyfree ( (yy_state_buf) );
+    (yy_state_buf)  = NULL;
+
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * yylex() is called, initialization will occur. */
+    yy_init_globals( );
+
+    return 0;
+}
+
+/*
+ * Internal utility routines.
+ */
+
+#ifndef yytext_ptr
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+{
+	register int i;
+	for ( i = 0; i < n; ++i )
+		s1[i] = s2[i];
+}
+#endif
+
+#ifdef YY_NEED_STRLEN
+static int yy_flex_strlen (yyconst char * s )
+{
+	register int n;
+	for ( n = 0; s[n]; ++n )
+		;
+
+	return n;
+}
+#endif
+
+void *yyalloc (yy_size_t  size )
+{
+	return (void *) malloc( size );
+}
+
+void *yyrealloc  (void * ptr, yy_size_t  size )
+{
+	/* The cast to (char *) in the following accommodates both
+	 * implementations that use char* generic pointers, and those
+	 * that use void* generic pointers.  It works with the latter
+	 * because both ANSI C and C++ allow castless assignment from
+	 * any pointer type to void*, and deal with argument conversions
+	 * as though doing an assignment.
+	 */
+	return (void *) realloc( (char *) ptr, size );
+}
+
+void yyfree (void * ptr )
+{
+	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+}
+
+#define YYTABLES_NAME "yytables"
+
+#line 9 "conftest.l"
+
+
+#ifdef YYTEXT_POINTER
+extern char *yytext;
+#endif
+int
+main (void)
+{
+  return ! yylex () + ! yywrap ();
+}
+
--- /dev/null
+++ man-db-2.5.7/config.log
@@ -0,0 +1,3430 @@
+This file contains any messages produced by compilers while
+running configure, to aid debugging if configure makes a mistake.
+
+It was created by man-db configure 2.5.7, which was
+generated by GNU Autoconf 2.65.  Invocation command line was
+
+  $ ./configure --build=i386-pc-solaris2.11 --prefix=/usr --includedir=${prefix}/include --mandir=${prefix}/share/man --infodir=${prefix}/share/info --sysconfdir=/etc --localstatedir=/var --libexecdir=${prefix}/lib/man-db --disable-maintainer-mode --disable-dependency-tracking --prefix=/usr --libexecdir=${libdir} --enable-setuid --enable-undoc=man 7 undocumented --with-device=latin1 --enable-mb-groff --with-config-file=/etc/manpath.config --with-browser=www-browser --with-pager=pager --with-col=col --with-vgrind=vgrind --with-grap=grap --with-compress=compress --with-bzip2=bzip2 --with-lzma=lzma --with-sections=1 n l 8 3 2 3posix 3pm 3perl 5 4 9 6 7
+
+## --------- ##
+## Platform. ##
+## --------- ##
+
+hostname = srv131
+uname -m = i86pc
+uname -r = 5.11
+uname -s = SunOS
+uname -v = NCP4.13368
+
+/usr/bin/uname -p = i386
+/bin/uname -X     = System = SunOS
+Node = srv131
+Release = 5.11
+KernelID = NCP4.13368
+Machine = i86pc
+BusType = <unknown>
+Serial = <unknown>
+Users = <unknown>
+OEM# = 0
+Origin# = 1
+NumCPU = 2
+
+/bin/arch              = i86pc
+/usr/bin/arch -k       = i86pc
+/usr/convex/getsysinfo = unknown
+/usr/bin/hostinfo      = unknown
+/bin/machine           = unknown
+/usr/bin/oslevel       = unknown
+/bin/universe          = unknown
+
+PATH: /usr/gnu/bin
+PATH: /usr/bin
+PATH: /usr/sbin
+PATH: /sbin
+
+
+## ----------- ##
+## Core tests. ##
+## ----------- ##
+
+configure:3306: checking for a BSD-compatible install
+configure:3374: result: /usr/gnu/bin/install -c
+configure:3385: checking whether build environment is sane
+configure:3435: result: yes
+configure:3576: checking for a thread-safe mkdir -p
+configure:3615: result: /usr/gnu/bin/mkdir -p
+configure:3628: checking for gawk
+configure:3644: found /usr/bin/gawk
+configure:3655: result: gawk
+configure:3666: checking whether make sets $(MAKE)
+configure:3688: result: yes
+configure:3793: checking build system type
+configure:3807: result: i386-pc-solaris2.11
+configure:3827: checking host system type
+configure:3840: result: i386-pc-solaris2.11
+configure:3883: Man will be installed setuid man
+configure:3906: Suggesting 'man 7 undocumented' for missing manual pages
+configure:4044: checking for style of include used by make
+configure:4072: result: GNU
+configure:4142: checking for gcc
+configure:4158: found /usr/bin/gcc
+configure:4169: result: gcc
+configure:4398: checking for C compiler version
+configure:4407: gcc --version >&5
+gcc (Debian 4.4.5-12nexenta2) 4.4.5
+Copyright (C) 2010 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:4418: $? = 0
+configure:4407: gcc -v >&5
+Using built-in specs.
+Target: i386-pc-solaris2.11
+Configured with: ../src/configure -v --with-pkgversion='Debian 4.4.5-12nexenta2' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.4 --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --with-gnu-as --with-as=/usr/gnu/bin/as --with-gnu-ld --with-ld=/usr/gnu/bin/ld --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --disable-libmudflap --enable-objc-gc --enable-targets=all --enable-checking=release --build=i386-pc-solaris2.11 --host=i386-pc-solaris2.11 --target=i386-pc-solaris2.11
+Thread model: posix
+gcc version 4.4.5 (Debian 4.4.5-12nexenta2) 
+configure:4418: $? = 0
+configure:4407: gcc -V >&5
+gcc: '-V' option must have argument
+configure:4418: $? = 1
+configure:4407: gcc -qversion >&5
+gcc: unrecognized option '-qversion'
+gcc: no input files
+configure:4418: $? = 1
+configure:4438: checking whether the C compiler works
+configure:4460: gcc -O2 -g   conftest.c  >&5
+configure:4464: $? = 0
+configure:4513: result: yes
+configure:4516: checking for C compiler default output file name
+configure:4518: result: a.out
+configure:4524: checking for suffix of executables
+configure:4531: gcc -o conftest -O2 -g   conftest.c  >&5
+configure:4535: $? = 0
+configure:4557: result: 
+configure:4579: checking whether we are cross compiling
+configure:4587: gcc -o conftest -O2 -g   conftest.c  >&5
+configure:4591: $? = 0
+configure:4598: ./conftest
+configure:4602: $? = 0
+configure:4617: result: no
+configure:4622: checking for suffix of object files
+configure:4644: gcc -c -O2 -g  conftest.c >&5
+configure:4648: $? = 0
+configure:4669: result: o
+configure:4673: checking whether we are using the GNU C compiler
+configure:4692: gcc -c -O2 -g  conftest.c >&5
+configure:4692: $? = 0
+configure:4701: result: yes
+configure:4710: checking whether gcc accepts -g
+configure:4730: gcc -c -g  conftest.c >&5
+configure:4730: $? = 0
+configure:4771: result: yes
+configure:4788: checking for gcc option to accept ISO C89
+configure:4852: gcc  -c -O2 -g  conftest.c >&5
+configure:4852: $? = 0
+configure:4865: result: none needed
+configure:4887: checking dependency style of gcc
+configure:4997: result: none
+configure:5018: checking how to run the C preprocessor
+configure:5049: gcc -E  conftest.c
+configure:5049: $? = 0
+configure:5063: gcc -E  conftest.c
+conftest.c:15:28: error: ac_nonexistent.h: No such file or directory
+configure:5063: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME "man-db"
+| #define PACKAGE_TARNAME "man-db"
+| #define PACKAGE_VERSION "2.5.7"
+| #define PACKAGE_STRING "man-db 2.5.7"
+| #define PACKAGE_BUGREPORT "cjwatson@debian.org"
+| #define PACKAGE_URL ""
+| #define PACKAGE "man-db"
+| #define VERSION "2.5.7"
+| #define SECURE_MAN_UID "man"
+| #define UNDOC_COMMAND "man 7 undocumented"
+| #define MAN_DB_UPDATES 1
+| #define MAN_CATS 1
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:5088: result: gcc -E
+configure:5108: gcc -E  conftest.c
+configure:5108: $? = 0
+configure:5122: gcc -E  conftest.c
+conftest.c:15:28: error: ac_nonexistent.h: No such file or directory
+configure:5122: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME "man-db"
+| #define PACKAGE_TARNAME "man-db"
+| #define PACKAGE_VERSION "2.5.7"
+| #define PACKAGE_STRING "man-db 2.5.7"
+| #define PACKAGE_BUGREPORT "cjwatson@debian.org"
+| #define PACKAGE_URL ""
+| #define PACKAGE "man-db"
+| #define VERSION "2.5.7"
+| #define SECURE_MAN_UID "man"
+| #define UNDOC_COMMAND "man 7 undocumented"
+| #define MAN_DB_UPDATES 1
+| #define MAN_CATS 1
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:5151: checking for grep that handles long lines and -e
+configure:5209: result: /usr/gnu/bin/grep
+configure:5214: checking for egrep
+configure:5276: result: /usr/gnu/bin/grep -E
+configure:5281: checking for ANSI C header files
+configure:5301: gcc -c -O2 -g  conftest.c >&5
+configure:5301: $? = 0
+configure:5374: gcc -o conftest -O2 -g   conftest.c  >&5
+configure:5374: $? = 0
+configure:5374: ./conftest
+configure:5374: $? = 0
+configure:5385: result: yes
+configure:5398: checking for sys/types.h
+configure:5398: gcc -c -O2 -g  conftest.c >&5
+configure:5398: $? = 0
+configure:5398: result: yes
+configure:5398: checking for sys/stat.h
+configure:5398: gcc -c -O2 -g  conftest.c >&5
+configure:5398: $? = 0
+configure:5398: result: yes
+configure:5398: checking for stdlib.h
+configure:5398: gcc -c -O2 -g  conftest.c >&5
+configure:5398: $? = 0
+configure:5398: result: yes
+configure:5398: checking for string.h
+configure:5398: gcc -c -O2 -g  conftest.c >&5
+configure:5398: $? = 0
+configure:5398: result: yes
+configure:5398: checking for memory.h
+configure:5398: gcc -c -O2 -g  conftest.c >&5
+configure:5398: $? = 0
+configure:5398: result: yes
+configure:5398: checking for strings.h
+configure:5398: gcc -c -O2 -g  conftest.c >&5
+configure:5398: $? = 0
+configure:5398: result: yes
+configure:5398: checking for inttypes.h
+configure:5398: gcc -c -O2 -g  conftest.c >&5
+configure:5398: $? = 0
+configure:5398: result: yes
+configure:5398: checking for stdint.h
+configure:5398: gcc -c -O2 -g  conftest.c >&5
+configure:5398: $? = 0
+configure:5398: result: yes
+configure:5398: checking for unistd.h
+configure:5398: gcc -c -O2 -g  conftest.c >&5
+configure:5398: $? = 0
+configure:5398: result: yes
+configure:5414: checking minix/config.h usability
+configure:5414: gcc -c -O2 -g  conftest.c >&5
+conftest.c:58:26: error: minix/config.h: No such file or directory
+configure:5414: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME "man-db"
+| #define PACKAGE_TARNAME "man-db"
+| #define PACKAGE_VERSION "2.5.7"
+| #define PACKAGE_STRING "man-db 2.5.7"
+| #define PACKAGE_BUGREPORT "cjwatson@debian.org"
+| #define PACKAGE_URL ""
+| #define PACKAGE "man-db"
+| #define VERSION "2.5.7"
+| #define SECURE_MAN_UID "man"
+| #define UNDOC_COMMAND "man 7 undocumented"
+| #define MAN_DB_UPDATES 1
+| #define MAN_CATS 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| /* end confdefs.h.  */
+| #include <stdio.h>
+| #ifdef HAVE_SYS_TYPES_H
+| # include <sys/types.h>
+| #endif
+| #ifdef HAVE_SYS_STAT_H
+| # include <sys/stat.h>
+| #endif
+| #ifdef STDC_HEADERS
+| # include <stdlib.h>
+| # include <stddef.h>
+| #else
+| # ifdef HAVE_STDLIB_H
+| #  include <stdlib.h>
+| # endif
+| #endif
+| #ifdef HAVE_STRING_H
+| # if !defined STDC_HEADERS && defined HAVE_MEMORY_H
+| #  include <memory.h>
+| # endif
+| # include <string.h>
+| #endif
+| #ifdef HAVE_STRINGS_H
+| # include <strings.h>
+| #endif
+| #ifdef HAVE_INTTYPES_H
+| # include <inttypes.h>
+| #endif
+| #ifdef HAVE_STDINT_H
+| # include <stdint.h>
+| #endif
+| #ifdef HAVE_UNISTD_H
+| # include <unistd.h>
+| #endif
+| #include <minix/config.h>
+configure:5414: result: no
+configure:5414: checking minix/config.h presence
+configure:5414: gcc -E  conftest.c
+conftest.c:25:26: error: minix/config.h: No such file or directory
+configure:5414: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME "man-db"
+| #define PACKAGE_TARNAME "man-db"
+| #define PACKAGE_VERSION "2.5.7"
+| #define PACKAGE_STRING "man-db 2.5.7"
+| #define PACKAGE_BUGREPORT "cjwatson@debian.org"
+| #define PACKAGE_URL ""
+| #define PACKAGE "man-db"
+| #define VERSION "2.5.7"
+| #define SECURE_MAN_UID "man"
+| #define UNDOC_COMMAND "man 7 undocumented"
+| #define MAN_DB_UPDATES 1
+| #define MAN_CATS 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| /* end confdefs.h.  */
+| #include <minix/config.h>
+configure:5414: result: no
+configure:5414: checking for minix/config.h
+configure:5414: result: no
+configure:5443: checking whether it is safe to define __EXTENSIONS__
+configure:5461: gcc -c -O2 -g  conftest.c >&5
+configure:5461: $? = 0
+configure:5468: result: yes
+configure:5531: checking for gcc
+configure:5558: result: gcc
+configure:5787: checking for C compiler version
+configure:5796: gcc --version >&5
+gcc (Debian 4.4.5-12nexenta2) 4.4.5
+Copyright (C) 2010 Free Software Foundation, Inc.
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+
+configure:5807: $? = 0
+configure:5796: gcc -v >&5
+Using built-in specs.
+Target: i386-pc-solaris2.11
+Configured with: ../src/configure -v --with-pkgversion='Debian 4.4.5-12nexenta2' --with-bugurl=file:///usr/share/doc/gcc-4.4/README.Bugs --enable-languages=c,c++,fortran,objc,obj-c++ --prefix=/usr --program-suffix=-4.4 --enable-shared --enable-multiarch --enable-linker-build-id --with-system-zlib --with-gnu-as --with-as=/usr/gnu/bin/as --with-gnu-ld --with-ld=/usr/gnu/bin/ld --libexecdir=/usr/lib --without-included-gettext --enable-threads=posix --with-gxx-include-dir=/usr/include/c++/4.4 --libdir=/usr/lib --enable-nls --with-sysroot=/ --enable-clocale=gnu --enable-libstdcxx-debug --disable-libmudflap --enable-objc-gc --enable-targets=all --enable-checking=release --build=i386-pc-solaris2.11 --host=i386-pc-solaris2.11 --target=i386-pc-solaris2.11
+Thread model: posix
+gcc version 4.4.5 (Debian 4.4.5-12nexenta2) 
+configure:5807: $? = 0
+configure:5796: gcc -V >&5
+gcc: '-V' option must have argument
+configure:5807: $? = 1
+configure:5796: gcc -qversion >&5
+gcc: unrecognized option '-qversion'
+gcc: no input files
+configure:5807: $? = 1
+configure:5811: checking whether we are using the GNU C compiler
+configure:5839: result: yes
+configure:5848: checking whether gcc accepts -g
+configure:5909: result: yes
+configure:5926: checking for gcc option to accept ISO C89
+configure:6003: result: none needed
+configure:6025: checking dependency style of gcc
+configure:6135: result: none
+configure:6193: checking for ranlib
+configure:6209: found /usr/gnu/bin/ranlib
+configure:6220: result: ranlib
+configure:6243: checking whether gcc and cc understand -c and -o together
+configure:6274: gcc -c conftest.c -o conftest2.o >&5
+configure:6278: $? = 0
+configure:6284: gcc -c conftest.c -o conftest2.o >&5
+configure:6288: $? = 0
+configure:6299: cc -c conftest.c >&5
+configure:6303: $? = 0
+configure:6311: cc -c conftest.c -o conftest2.o >&5
+configure:6315: $? = 0
+configure:6321: cc -c conftest.c -o conftest2.o >&5
+configure:6325: $? = 0
+configure:6343: result: yes
+configure:6377: checking for gcc option to accept ISO C99
+configure:6526: gcc  -c -O2 -g  conftest.c >&5
+conftest.c:80: error: expected ';', ',' or ')' before 'text'
+conftest.c: In function 'main':
+conftest.c:134: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'newvar'
+conftest.c:134: error: 'newvar' undeclared (first use in this function)
+conftest.c:134: error: (Each undeclared identifier is reported only once
+conftest.c:134: error: for each function it appears in.)
+conftest.c:144: error: 'for' loop initial declarations are only allowed in C99 mode
+conftest.c:144: note: use option -std=c99 or -std=gnu99 to compile your code
+configure:6526: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME "man-db"
+| #define PACKAGE_TARNAME "man-db"
+| #define PACKAGE_VERSION "2.5.7"
+| #define PACKAGE_STRING "man-db 2.5.7"
+| #define PACKAGE_BUGREPORT "cjwatson@debian.org"
+| #define PACKAGE_URL ""
+| #define PACKAGE "man-db"
+| #define VERSION "2.5.7"
+| #define SECURE_MAN_UID "man"
+| #define UNDOC_COMMAND "man 7 undocumented"
+| #define MAN_DB_UPDATES 1
+| #define MAN_CATS 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define __EXTENSIONS__ 1
+| #define _ALL_SOURCE 1
+| #define _GNU_SOURCE 1
+| #define _POSIX_PTHREAD_SEMANTICS 1
+| #define _TANDEM_SOURCE 1
+| /* end confdefs.h.  */
+| #include <stdarg.h>
+| #include <stdbool.h>
+| #include <stdlib.h>
+| #include <wchar.h>
+| #include <stdio.h>
+| 
+| // Check varargs macros.  These examples are taken from C99 6.10.3.5.
+| #define debug(...) fprintf (stderr, __VA_ARGS__)
+| #define showlist(...) puts (#__VA_ARGS__)
+| #define report(test,...) ((test) ? puts (#test) : printf (__VA_ARGS__))
+| static void
+| test_varargs_macros (void)
+| {
+|   int x = 1234;
+|   int y = 5678;
+|   debug ("Flag");
+|   debug ("X = %d\n", x);
+|   showlist (The first, second, and third items.);
+|   report (x>y, "x is %d but y is %d", x, y);
+| }
+| 
+| // Check long long types.
+| #define BIG64 18446744073709551615ull
+| #define BIG32 4294967295ul
+| #define BIG_OK (BIG64 / BIG32 == 4294967297ull && BIG64 % BIG32 == 0)
+| #if !BIG_OK
+|   your preprocessor is broken;
+| #endif
+| #if BIG_OK
+| #else
+|   your preprocessor is broken;
+| #endif
+| static long long int bignum = -9223372036854775807LL;
+| static unsigned long long int ubignum = BIG64;
+| 
+| struct incomplete_array
+| {
+|   int datasize;
+|   double data[];
+| };
+| 
+| struct named_init {
+|   int number;
+|   const wchar_t *name;
+|   double average;
+| };
+| 
+| typedef const char *ccp;
+| 
+| static inline int
+| test_restrict (ccp restrict text)
+| {
+|   // See if C++-style comments work.
+|   // Iterate through items via the restricted pointer.
+|   // Also check for declarations in for loops.
+|   for (unsigned int i = 0; *(text+i) != '\0'; ++i)
+|     continue;
+|   return 0;
+| }
+| 
+| // Check varargs and va_copy.
+| static void
+| test_varargs (const char *format, ...)
+| {
+|   va_list args;
+|   va_start (args, format);
+|   va_list args_copy;
+|   va_copy (args_copy, args);
+| 
+|   const char *str;
+|   int number;
+|   float fnumber;
+| 
+|   while (*format)
+|     {
+|       switch (*format++)
+| 	{
+| 	case 's': // string
+| 	  str = va_arg (args_copy, const char *);
+| 	  break;
+| 	case 'd': // int
+| 	  number = va_arg (args_copy, int);
+| 	  break;
+| 	case 'f': // float
+| 	  fnumber = va_arg (args_copy, double);
+| 	  break;
+| 	default:
+| 	  break;
+| 	}
+|     }
+|   va_end (args_copy);
+|   va_end (args);
+| }
+| 
+| int
+| main ()
+| {
+| 
+|   // Check bool.
+|   _Bool success = false;
+| 
+|   // Check restrict.
+|   if (test_restrict ("String literal") == 0)
+|     success = true;
+|   char *restrict newvar = "Another string";
+| 
+|   // Check varargs.
+|   test_varargs ("s, d' f .", "string", 65, 34.234);
+|   test_varargs_macros ();
+| 
+|   // Check flexible array members.
+|   struct incomplete_array *ia =
+|     malloc (sizeof (struct incomplete_array) + (sizeof (double) * 10));
+|   ia->datasize = 10;
+|   for (int i = 0; i < ia->datasize; ++i)
+|     ia->data[i] = i * 1.234;
+| 
+|   // Check named initializers.
+|   struct named_init ni = {
+|     .number = 34,
+|     .name = L"Test wide string",
+|     .average = 543.34343,
+|   };
+| 
+|   ni.number = 58;
+| 
+|   int dynamic_array[ni.number];
+|   dynamic_array[ni.number - 1] = 543;
+| 
+|   // work around unused variable warnings
+|   return (!success || bignum == 0LL || ubignum == 0uLL || newvar[0] == 'x'
+| 	  || dynamic_array[ni.number - 1] != 543);
+| 
+|   ;
+|   return 0;
+| }
+configure:6526: gcc -std=gnu99 -c -O2 -g  conftest.c >&5
+configure:6526: $? = 0
+configure:6546: result: -std=gnu99
+configure:6648: checking for gcc -std=gnu99 option to accept ISO Standard C
+configure:6662: result: -std=gnu99
+configure:6728: checking how to run the C preprocessor
+configure:6798: result: gcc -E
+configure:6818: gcc -E  -D_REENTRANT conftest.c
+configure:6818: $? = 0
+configure:6832: gcc -E  -D_REENTRANT conftest.c
+conftest.c:30:28: error: ac_nonexistent.h: No such file or directory
+configure:6832: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME "man-db"
+| #define PACKAGE_TARNAME "man-db"
+| #define PACKAGE_VERSION "2.5.7"
+| #define PACKAGE_STRING "man-db 2.5.7"
+| #define PACKAGE_BUGREPORT "cjwatson@debian.org"
+| #define PACKAGE_URL ""
+| #define PACKAGE "man-db"
+| #define VERSION "2.5.7"
+| #define SECURE_MAN_UID "man"
+| #define UNDOC_COMMAND "man 7 undocumented"
+| #define MAN_DB_UPDATES 1
+| #define MAN_CATS 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define __EXTENSIONS__ 1
+| #define _ALL_SOURCE 1
+| #define _GNU_SOURCE 1
+| #define _POSIX_PTHREAD_SEMANTICS 1
+| #define _TANDEM_SOURCE 1
+| /* end confdefs.h.  */
+| #include <ac_nonexistent.h>
+configure:6870: checking that GCC supports -W
+configure:6887: gcc -std=gnu99 -c -O2 -g -Wall -W  -D_REENTRANT conftest.c >&5
+configure:6887: $? = 0
+configure:6892: result: yes
+configure:6899: checking that GCC supports -Wpointer-arith
+configure:6916: gcc -std=gnu99 -c -O2 -g -Wall -W -Wpointer-arith  -D_REENTRANT conftest.c >&5
+configure:6916: $? = 0
+configure:6921: result: yes
+configure:6928: checking that GCC supports -Wwrite-strings
+configure:6945: gcc -std=gnu99 -c -O2 -g -Wall -W -Wpointer-arith -Wwrite-strings  -D_REENTRANT conftest.c >&5
+configure:6945: $? = 0
+configure:6950: result: yes
+configure:6957: checking that GCC supports -Wstrict-prototypes
+configure:6974: gcc -std=gnu99 -c -O2 -g -Wall -W -Wpointer-arith -Wwrite-strings -Wstrict-prototypes  -D_REENTRANT conftest.c >&5
+conftest.c:33: warning: function declaration isn't a prototype
+configure:6974: $? = 0
+configure:6979: result: yes
+configure:6986: checking that GCC supports -Wshadow
+configure:7003: gcc -std=gnu99 -c -O2 -g -Wall -W -Wpointer-arith -Wwrite-strings -Wstrict-prototypes -Wshadow  -D_REENTRANT conftest.c >&5
+conftest.c:33: warning: function declaration isn't a prototype
+configure:7003: $? = 0
+configure:7008: result: yes
+configure:7015: checking that GCC supports -Wformat-security
+configure:7032: gcc -std=gnu99 -c -O2 -g -Wall -W -Wpointer-arith -Wwrite-strings -Wstrict-prototypes -Wshadow -Wformat-security  -D_REENTRANT conftest.c >&5
+conftest.c:33: warning: function declaration isn't a prototype
+configure:7032: $? = 0
+configure:7037: result: yes
+configure:7044: checking that GCC supports -Wredundant-decls
+configure:7061: gcc -std=gnu99 -c -O2 -g -Wall -W -Wpointer-arith -Wwrite-strings -Wstrict-prototypes -Wshadow -Wformat-security -Wredundant-decls  -D_REENTRANT conftest.c >&5
+conftest.c:33: warning: function declaration isn't a prototype
+configure:7061: $? = 0
+configure:7066: result: yes
+configure:7073: checking that GCC supports -Wno-missing-field-initializers
+configure:7090: gcc -std=gnu99 -c -O2 -g -Wall -W -Wpointer-arith -Wwrite-strings -Wstrict-prototypes -Wshadow -Wformat-security -Wredundant-decls -Wno-missing-field-initializers  -D_REENTRANT conftest.c >&5
+conftest.c:33: warning: function declaration isn't a prototype
+configure:7090: $? = 0
+configure:7095: result: yes
+configure:7145: checking for ranlib
+configure:7172: result: ranlib
+configure:7194: checking whether ln -s works
+configure:7198: result: yes
+configure:7209: checking for cat
+configure:7225: found /usr/gnu/bin/cat
+configure:7236: result: cat
+configure:7253: checking for browser
+configure:7255: result: www-browser
+configure:7314: checking for tr
+configure:7330: found /usr/gnu/bin/tr
+configure:7341: result: tr
+configure:7356: checking for grep
+configure:7372: found /usr/gnu/bin/grep
+configure:7383: result: grep
+configure:7400: checking for pager
+configure:7402: result: pager
+configure:7480: checking for nroff
+configure:7496: found /usr/gnu/bin/nroff
+configure:7507: result: nroff
+configure:7527: checking whether nroff is GNU nroff
+configure:7551: result: yes
+configure:7556: checking that nroff works with argument -Tlatin1
+configure:7562: result: yes
+configure:7570: checking for appropriate nroff macro
+configure:7591: result: -mandoc
+configure:7612: checking for groff
+configure:7628: found /usr/gnu/bin/groff
+configure:7639: result: groff
+configure:7709: checking for appropriate groff options
+configure:7732: result: -mandoc
+configure:7748: checking for gpreconv
+configure:7778: result: no
+configure:7748: checking for preconv
+configure:7764: found /usr/gnu/bin/preconv
+configure:7775: result: preconv
+configure:7787: checking for groff with Debian multibyte patch or real Unicode support
+configure:7809: result: yes
+configure:7835: checking for eqn
+configure:7851: found /usr/gnu/bin/eqn
+configure:7862: result: eqn
+configure:7897: checking for neqn
+configure:7913: found /usr/gnu/bin/neqn
+configure:7924: result: neqn
+configure:7967: checking for tbl
+configure:7983: found /usr/gnu/bin/tbl
+configure:7994: result: tbl
+configure:8018: checking for col
+configure:8020: result: col
+configure:8080: checking for vgrind
+configure:8082: result: vgrind
+configure:8153: checking for refer
+configure:8169: found /usr/gnu/bin/refer
+configure:8180: result: refer
+configure:8204: checking for grap
+configure:8206: result: grap
+configure:8277: checking for pic
+configure:8293: found /usr/gnu/bin/pic
+configure:8304: result: pic
+configure:8341: checking for gzip
+configure:8357: found /usr/bin/gzip
+configure:8368: result: gzip
+configure:8398: checking for compress
+configure:8400: result: compress
+configure:8469: checking for bzip2
+configure:8471: result: bzip2
+configure:8535: checking for lzma
+configure:8537: result: lzma
+configure:8610: checking for gzopen in -lz
+configure:8635: gcc -std=gnu99 -o conftest -O2 -g -Wall -W -Wpointer-arith -Wwrite-strings -Wstrict-prototypes -Wshadow -Wformat-security -Wredundant-decls -Wno-missing-field-initializers  -D_REENTRANT  conftest.c -lz   >&5
+conftest.c:58: warning: function declaration isn't a prototype
+conftest.c:61: warning: function declaration isn't a prototype
+configure:8635: $? = 0
+configure:8644: result: yes
+configure:8678: Using Solaris hierarchy organization
+configure:8694: checking for library containing strerror
+configure:8725: gcc -std=gnu99 -o conftest -O2 -g -Wall -W -Wpointer-arith -Wwrite-strings -Wstrict-prototypes -Wshadow -Wformat-security -Wredundant-decls -Wno-missing-field-initializers  -D_REENTRANT  conftest.c  >&5
+conftest.c:60: warning: function declaration isn't a prototype
+conftest.c:63: warning: function declaration isn't a prototype
+configure:8725: $? = 0
+configure:8742: result: none required
+configure:8754: checking for flex
+configure:8770: found /usr/bin/flex
+configure:8781: result: flex
+configure:8818: flex conftest.l
+configure:8822: $? = 0
+configure:8824: checking lex output file root
+configure:8838: result: lex.yy
+configure:8843: checking lex library
+configure:8857: gcc -std=gnu99 -o conftest -O2 -g -Wall -W -Wpointer-arith -Wwrite-strings -Wstrict-prototypes -Wshadow -Wformat-security -Wredundant-decls -Wno-missing-field-initializers  -D_REENTRANT  conftest.c   >&5
+lex.yy.c: In function 'yy_get_next_buffer':
+lex.yy.c:990: warning: comparison between signed and unsigned integer expressions
+lex.yy.c: At top level:
+lex.yy.c:1306: warning: redundant redeclaration of 'isatty'
+/usr/include/unistd.h:394: note: previous declaration of 'isatty' was here
+/var/tmp//ccseq90D.o: In function `input':
+/myshare/nexenta/src/2/man-db/man-db-2.5.7/lex.yy.c:1168: undefined reference to `yywrap'
+/var/tmp//ccseq90D.o: In function `yylex':
+/myshare/nexenta/src/2/man-db/man-db-2.5.7/lex.yy.c:867: undefined reference to `yywrap'
+/var/tmp//ccseq90D.o: In function `main':
+/myshare/nexenta/src/2/man-db/man-db-2.5.7/conftest.l:17: undefined reference to `yywrap'
+collect2: ld returned 1 exit status
+configure:8857: $? = 1
+configure: failed program was:
+| /* confdefs.h */
+| #define PACKAGE_NAME "man-db"
+| #define PACKAGE_TARNAME "man-db"
+| #define PACKAGE_VERSION "2.5.7"
+| #define PACKAGE_STRING "man-db 2.5.7"
+| #define PACKAGE_BUGREPORT "cjwatson@debian.org"
+| #define PACKAGE_URL ""
+| #define PACKAGE "man-db"
+| #define VERSION "2.5.7"
+| #define SECURE_MAN_UID "man"
+| #define UNDOC_COMMAND "man 7 undocumented"
+| #define MAN_DB_UPDATES 1
+| #define MAN_CATS 1
+| #define STDC_HEADERS 1
+| #define HAVE_SYS_TYPES_H 1
+| #define HAVE_SYS_STAT_H 1
+| #define HAVE_STDLIB_H 1
+| #define HAVE_STRING_H 1
+| #define HAVE_MEMORY_H 1
+| #define HAVE_STRINGS_H 1
+| #define HAVE_INTTYPES_H 1
+| #define HAVE_STDINT_H 1
+| #define HAVE_UNISTD_H 1
+| #define __EXTENSIONS__ 1
+| #define _ALL_SOURCE 1
+| #define _GNU_SOURCE 1
+| #define _POSIX_PTHREAD_SEMANTICS 1
+| #define _TANDEM_SOURCE 1
+| #define HAVE_BROWSER 1
+| #define HAVE_PAGER 1
+| #define HAVE_NROFF 1
+| #define GNU_NROFF 1
+| #define TROFF_IS_GROFF 1
+| #define HAS_TROFF 1
+| #define MULTIBYTE_GROFF 1
+| #define HAVE_EQN 1
+| #define HAVE_NEQN 1
+| #define HAVE_TBL 1
+| #define HAVE_COL 1
+| #define HAVE_VGRIND 1
+| #define HAVE_REFER 1
+| #define HAVE_GRAP 1
+| #define HAVE_PIC 1
+| #define HAVE_GZIP 1
+| #define HAVE_COMPRESS 1
+| #define HAVE_BZIP2 1
+| #define HAVE_LZMA 1
+| #define COMP_CAT 1
+| #define COMP_SRC 1
+| #define HAVE_LIBZ 1
+| #define MANDIR_LAYOUT "Solaris"
+| /* end confdefs.h.  */
+| 
+| #line 3 "lex.yy.c"
+| 
+| #define  YY_INT_ALIGNED short int
+| 
+| /* A lexical scanner generated by flex */
+| 
+| #define FLEX_SCANNER
+| #define YY_FLEX_MAJOR_VERSION 2
+| #define YY_FLEX_MINOR_VERSION 5
+| #define YY_FLEX_SUBMINOR_VERSION 35
+| #if YY_FLEX_SUBMINOR_VERSION > 0
+| #define FLEX_BETA
+| #endif
+| 
+| /* First, we deal with  platform-specific or compiler-specific issues. */
+| 
+| /* begin standard C headers. */
+| #include <stdio.h>
+| #include <string.h>
+| #include <errno.h>
+| #include <stdlib.h>
+| 
+| /* end standard C headers. */
+| 
+| /* flex integer type definitions */
+| 
+| #ifndef FLEXINT_H
+| #define FLEXINT_H
+| 
+| /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
+| 
+| #if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
+| 
+| /* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+|  * if you want the limit (max/min) macros for int types. 
+|  */
+| #ifndef __STDC_LIMIT_MACROS
+| #define __STDC_LIMIT_MACROS 1
+| #endif
+| 
+| #include <inttypes.h>
+| typedef int8_t flex_int8_t;
+| typedef uint8_t flex_uint8_t;
+| typedef int16_t flex_int16_t;
+| typedef uint16_t flex_uint16_t;
+| typedef int32_t flex_int32_t;
+| typedef uint32_t flex_uint32_t;
+| #else
+| typedef signed char flex_int8_t;
+| typedef short int flex_int16_t;
+| typedef int flex_int32_t;
+| typedef unsigned char flex_uint8_t; 
+| typedef unsigned short int flex_uint16_t;
+| typedef unsigned int flex_uint32_t;
+| #endif /* ! C99 */
+| 
+| /* Limits of integral types. */
+| #ifndef INT8_MIN
+| #define INT8_MIN               (-128)
+| #endif
+| #ifndef INT16_MIN
+| #define INT16_MIN              (-32767-1)
+| #endif
+| #ifndef INT32_MIN
+| #define INT32_MIN              (-2147483647-1)
+| #endif
+| #ifndef INT8_MAX
+| #define INT8_MAX               (127)
+| #endif
+| #ifndef INT16_MAX
+| #define INT16_MAX              (32767)
+| #endif
+| #ifndef INT32_MAX
+| #define INT32_MAX              (2147483647)
+| #endif
+| #ifndef UINT8_MAX
+| #define UINT8_MAX              (255U)
+| #endif
+| #ifndef UINT16_MAX
+| #define UINT16_MAX             (65535U)
+| #endif
+| #ifndef UINT32_MAX
+| #define UINT32_MAX             (4294967295U)
+| #endif
+| 
+| #endif /* ! FLEXINT_H */
+| 
+| #ifdef __cplusplus
+| 
+| /* The "const" storage-class-modifier is valid. */
+| #define YY_USE_CONST
+| 
+| #else	/* ! __cplusplus */
+| 
+| /* C99 requires __STDC__ to be defined as 1. */
+| #if defined (__STDC__)
+| 
+| #define YY_USE_CONST
+| 
+| #endif	/* defined (__STDC__) */
+| #endif	/* ! __cplusplus */
+| 
+| #ifdef YY_USE_CONST
+| #define yyconst const
+| #else
+| #define yyconst
+| #endif
+| 
+| /* Returned upon end-of-file. */
+| #define YY_NULL 0
+| 
+| /* Promotes a possibly negative, possibly signed char to an unsigned
+|  * integer for use as an array index.  If the signed char is negative,
+|  * we want to instead treat it as an 8-bit unsigned char, hence the
+|  * double cast.
+|  */
+| #define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
+| 
+| /* Enter a start condition.  This macro really ought to take a parameter,
+|  * but we do it the disgusting crufty way forced on us by the ()-less
+|  * definition of BEGIN.
+|  */
+| #define BEGIN (yy_start) = 1 + 2 *
+| 
+| /* Translate the current start state into a value that can be later handed
+|  * to BEGIN to return to the state.  The YYSTATE alias is for lex
+|  * compatibility.
+|  */
+| #define YY_START (((yy_start) - 1) / 2)
+| #define YYSTATE YY_START
+| 
+| /* Action number for EOF rule of a given start state. */
+| #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+| 
+| /* Special action meaning "start processing a new file". */
+| #define YY_NEW_FILE yyrestart(yyin  )
+| 
+| #define YY_END_OF_BUFFER_CHAR 0
+| 
+| /* Size of default input buffer. */
+| #ifndef YY_BUF_SIZE
+| #define YY_BUF_SIZE 16384
+| #endif
+| 
+| /* The state buf must be large enough to hold one state per character in the main buffer.
+|  */
+| #define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+| 
+| #ifndef YY_TYPEDEF_YY_BUFFER_STATE
+| #define YY_TYPEDEF_YY_BUFFER_STATE
+| typedef struct yy_buffer_state *YY_BUFFER_STATE;
+| #endif
+| 
+| extern int yyleng;
+| 
+| extern FILE *yyin, *yyout;
+| 
+| #define EOB_ACT_CONTINUE_SCAN 0
+| #define EOB_ACT_END_OF_FILE 1
+| #define EOB_ACT_LAST_MATCH 2
+| 
+|     #define YY_LESS_LINENO(n)
+|     
+| /* Return all but the first "n" matched characters back to the input stream. */
+| #define yyless(n) \
+| 	do \
+| 		{ \
+| 		/* Undo effects of setting up yytext. */ \
+|         int yyless_macro_arg = (n); \
+|         YY_LESS_LINENO(yyless_macro_arg);\
+| 		*yy_cp = (yy_hold_char); \
+| 		YY_RESTORE_YY_MORE_OFFSET \
+| 		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
+| 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
+| 		} \
+| 	while ( 0 )
+| 
+| #define unput(c) yyunput( c, (yytext_ptr)  )
+| 
+| #ifndef YY_TYPEDEF_YY_SIZE_T
+| #define YY_TYPEDEF_YY_SIZE_T
+| typedef size_t yy_size_t;
+| #endif
+| 
+| #ifndef YY_STRUCT_YY_BUFFER_STATE
+| #define YY_STRUCT_YY_BUFFER_STATE
+| struct yy_buffer_state
+| 	{
+| 	FILE *yy_input_file;
+| 
+| 	char *yy_ch_buf;		/* input buffer */
+| 	char *yy_buf_pos;		/* current position in input buffer */
+| 
+| 	/* Size of input buffer in bytes, not including room for EOB
+| 	 * characters.
+| 	 */
+| 	yy_size_t yy_buf_size;
+| 
+| 	/* Number of characters read into yy_ch_buf, not including EOB
+| 	 * characters.
+| 	 */
+| 	int yy_n_chars;
+| 
+| 	/* Whether we "own" the buffer - i.e., we know we created it,
+| 	 * and can realloc() it to grow it, and should free() it to
+| 	 * delete it.
+| 	 */
+| 	int yy_is_our_buffer;
+| 
+| 	/* Whether this is an "interactive" input source; if so, and
+| 	 * if we're using stdio for input, then we want to use getc()
+| 	 * instead of fread(), to make sure we stop fetching input after
+| 	 * each newline.
+| 	 */
+| 	int yy_is_interactive;
+| 
+| 	/* Whether we're considered to be at the beginning of a line.
+| 	 * If so, '^' rules will be active on the next match, otherwise
+| 	 * not.
+| 	 */
+| 	int yy_at_bol;
+| 
+|     int yy_bs_lineno; /**< The line count. */
+|     int yy_bs_column; /**< The column count. */
+|     
+| 	/* Whether to try to fill the input buffer when we reach the
+| 	 * end of it.
+| 	 */
+| 	int yy_fill_buffer;
+| 
+| 	int yy_buffer_status;
+| 
+| #define YY_BUFFER_NEW 0
+| #define YY_BUFFER_NORMAL 1
+| 	/* When an EOF's been seen but there's still some text to process
+| 	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
+| 	 * shouldn't try reading from the input source any more.  We might
+| 	 * still have a bunch of tokens to match, though, because of
+| 	 * possible backing-up.
+| 	 *
+| 	 * When we actually see the EOF, we change the status to "new"
+| 	 * (via yyrestart()), so that the user can continue scanning by
+| 	 * just pointing yyin at a new input file.
+| 	 */
+| #define YY_BUFFER_EOF_PENDING 2
+| 
+| 	};
+| #endif /* !YY_STRUCT_YY_BUFFER_STATE */
+| 
+| /* Stack of input buffers. */
+| static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
+| static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
+| static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
+| 
+| /* We provide macros for accessing buffer states in case in the
+|  * future we want to put the buffer states in a more general
+|  * "scanner state".
+|  *
+|  * Returns the top of the stack, or NULL.
+|  */
+| #define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
+|                           ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
+|                           : NULL)
+| 
+| /* Same as previous macro, but useful when we know that the buffer stack is not
+|  * NULL or when we need an lvalue. For internal use only.
+|  */
+| #define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
+| 
+| /* yy_hold_char holds the character lost when yytext is formed. */
+| static char yy_hold_char;
+| static int yy_n_chars;		/* number of characters read into yy_ch_buf */
+| int yyleng;
+| 
+| /* Points to current character in buffer. */
+| static char *yy_c_buf_p = (char *) 0;
+| static int yy_init = 0;		/* whether we need to initialize */
+| static int yy_start = 0;	/* start state number */
+| 
+| /* Flag which is used to allow yywrap()'s to do buffer switches
+|  * instead of setting up a fresh yyin.  A bit of a hack ...
+|  */
+| static int yy_did_buffer_switch_on_eof;
+| 
+| void yyrestart (FILE *input_file  );
+| void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
+| YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
+| void yy_delete_buffer (YY_BUFFER_STATE b  );
+| void yy_flush_buffer (YY_BUFFER_STATE b  );
+| void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
+| void yypop_buffer_state (void );
+| 
+| static void yyensure_buffer_stack (void );
+| static void yy_load_buffer_state (void );
+| static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
+| 
+| #define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
+| 
+| YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
+| YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
+| YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,int len  );
+| 
+| void *yyalloc (yy_size_t  );
+| void *yyrealloc (void *,yy_size_t  );
+| void yyfree (void *  );
+| 
+| #define yy_new_buffer yy_create_buffer
+| 
+| #define yy_set_interactive(is_interactive) \
+| 	{ \
+| 	if ( ! YY_CURRENT_BUFFER ){ \
+|         yyensure_buffer_stack (); \
+| 		YY_CURRENT_BUFFER_LVALUE =    \
+|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
+| 	} \
+| 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
+| 	}
+| 
+| #define yy_set_bol(at_bol) \
+| 	{ \
+| 	if ( ! YY_CURRENT_BUFFER ){\
+|         yyensure_buffer_stack (); \
+| 		YY_CURRENT_BUFFER_LVALUE =    \
+|             yy_create_buffer(yyin,YY_BUF_SIZE ); \
+| 	} \
+| 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
+| 	}
+| 
+| #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
+| 
+| /* Begin user sect3 */
+| 
+| typedef unsigned char YY_CHAR;
+| 
+| FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
+| 
+| typedef int yy_state_type;
+| 
+| extern int yylineno;
+| 
+| int yylineno = 1;
+| 
+| extern char *yytext;
+| #define yytext_ptr yytext
+| 
+| static yy_state_type yy_get_previous_state (void );
+| static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
+| static int yy_get_next_buffer (void );
+| static void yy_fatal_error (yyconst char msg[]  );
+| 
+| /* Done after the current pattern has been matched and before the
+|  * corresponding action - sets up yytext.
+|  */
+| #define YY_DO_BEFORE_ACTION \
+| 	(yytext_ptr) = yy_bp; \
+| 	(yytext_ptr) -= (yy_more_len); \
+| 	yyleng = (size_t) (yy_cp - (yytext_ptr)); \
+| 	(yy_hold_char) = *yy_cp; \
+| 	*yy_cp = '\0'; \
+| 	(yy_c_buf_p) = yy_cp;
+| 
+| #define YY_NUM_RULES 8
+| #define YY_END_OF_BUFFER 9
+| /* This struct is not used in this scanner,
+|    but its presence is necessary. */
+| struct yy_trans_info
+| 	{
+| 	flex_int32_t yy_verify;
+| 	flex_int32_t yy_nxt;
+| 	};
+| static yyconst flex_int16_t yy_acclist[23] =
+|     {   0,
+|         9,    7,    8,    8,    1,    7,    8,    2,    7,    8,
+|         3,    7,    8,    4,    7,    8,    5,    7,    8,    6,
+|         7,    8
+|     } ;
+| 
+| static yyconst flex_int16_t yy_accept[14] =
+|     {   0,
+|         1,    1,    1,    2,    4,    5,    8,   11,   14,   17,
+|        20,   23,   23
+|     } ;
+| 
+| static yyconst flex_int32_t yy_ec[256] =
+|     {   0,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    2,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    3,    4,    5,    6,
+| 
+|         7,    8,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+| 
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
+|         1,    1,    1,    1,    1
+|     } ;
+| 
+| static yyconst flex_int32_t yy_meta[9] =
+|     {   0,
+|         1,    1,    1,    1,    1,    1,    1,    1
+|     } ;
+| 
+| static yyconst flex_int16_t yy_base[13] =
+|     {   0,
+|         0,    0,    9,   10,   10,   10,   10,   10,   10,   10,
+|        10,   10
+|     } ;
+| 
+| static yyconst flex_int16_t yy_def[13] =
+|     {   0,
+|        12,    1,   12,   12,   12,   12,   12,   12,   12,   12,
+|        12,    0
+|     } ;
+| 
+| static yyconst flex_int16_t yy_nxt[19] =
+|     {   0,
+|         4,    5,    6,    7,    8,    9,   10,   11,   12,    3,
+|        12,   12,   12,   12,   12,   12,   12,   12
+|     } ;
+| 
+| static yyconst flex_int16_t yy_chk[19] =
+|     {   0,
+|         1,    1,    1,    1,    1,    1,    1,    1,    3,   12,
+|        12,   12,   12,   12,   12,   12,   12,   12
+|     } ;
+| 
+| extern int yy_flex_debug;
+| int yy_flex_debug = 0;
+| 
+| static yy_state_type *yy_state_buf=0, *yy_state_ptr=0;
+| static char *yy_full_match;
+| static int yy_lp;
+| #define REJECT \
+| { \
+| *yy_cp = (yy_hold_char); /* undo effects of setting up yytext */ \
+| yy_cp = (yy_full_match); /* restore poss. backed-over text */ \
+| ++(yy_lp); \
+| goto find_rule; \
+| }
+| 
+| static int yy_more_flag = 0;
+| static int yy_more_len = 0;
+| #define yymore() ((yy_more_flag) = 1)
+| #define YY_MORE_ADJ (yy_more_len)
+| #define YY_RESTORE_YY_MORE_OFFSET
+| char *yytext;
+| #line 1 "conftest.l"
+| #line 468 "lex.yy.c"
+| 
+| #define INITIAL 0
+| 
+| #ifndef YY_NO_UNISTD_H
+| /* Special case for "unistd.h", since it is non-ANSI. We include it way
+|  * down here because we want the user's section 1 to have been scanned first.
+|  * The user has a chance to override it with an option.
+|  */
+| #include <unistd.h>
+| #endif
+| 
+| #ifndef YY_EXTRA_TYPE
+| #define YY_EXTRA_TYPE void *
+| #endif
+| 
+| static int yy_init_globals (void );
+| 
+| /* Accessor methods to globals.
+|    These are made visible to non-reentrant scanners for convenience. */
+| 
+| int yylex_destroy (void );
+| 
+| int yyget_debug (void );
+| 
+| void yyset_debug (int debug_flag  );
+| 
+| YY_EXTRA_TYPE yyget_extra (void );
+| 
+| void yyset_extra (YY_EXTRA_TYPE user_defined  );
+| 
+| FILE *yyget_in (void );
+| 
+| void yyset_in  (FILE * in_str  );
+| 
+| FILE *yyget_out (void );
+| 
+| void yyset_out  (FILE * out_str  );
+| 
+| int yyget_leng (void );
+| 
+| char *yyget_text (void );
+| 
+| int yyget_lineno (void );
+| 
+| void yyset_lineno (int line_number  );
+| 
+| /* Macros after this point can all be overridden by user definitions in
+|  * section 1.
+|  */
+| 
+| #ifndef YY_SKIP_YYWRAP
+| #ifdef __cplusplus
+| extern "C" int yywrap (void );
+| #else
+| extern int yywrap (void );
+| #endif
+| #endif
+| 
+|     static void yyunput (int c,char *buf_ptr  );
+|     
+| #ifndef yytext_ptr
+| static void yy_flex_strncpy (char *,yyconst char *,int );
+| #endif
+| 
+| #ifdef YY_NEED_STRLEN
+| static int yy_flex_strlen (yyconst char * );
+| #endif
+| 
+| #ifndef YY_NO_INPUT
+| 
+| #ifdef __cplusplus
+| static int yyinput (void );
+| #else
+| static int input (void );
+| #endif
+| 
+| #endif
+| 
+| /* Amount of stuff to slurp up with each read. */
+| #ifndef YY_READ_BUF_SIZE
+| #define YY_READ_BUF_SIZE 8192
+| #endif
+| 
+| /* Copy whatever the last rule matched to the standard output. */
+| #ifndef ECHO
+| /* This used to be an fputs(), but since the string might contain NUL's,
+|  * we now use fwrite().
+|  */
+| #define ECHO fwrite( yytext, yyleng, 1, yyout )
+| #endif
+| 
+| /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
+|  * is returned in "result".
+|  */
+| #ifndef YY_INPUT
+| #define YY_INPUT(buf,result,max_size) \
+| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
+| 		{ \
+| 		int c = '*'; \
+| 		int n; \
+| 		for ( n = 0; n < max_size && \
+| 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
+| 			buf[n] = (char) c; \
+| 		if ( c == '\n' ) \
+| 			buf[n++] = (char) c; \
+| 		if ( c == EOF && ferror( yyin ) ) \
+| 			YY_FATAL_ERROR( "input in flex scanner failed" ); \
+| 		result = n; \
+| 		} \
+| 	else \
+| 		{ \
+| 		errno=0; \
+| 		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
+| 			{ \
+| 			if( errno != EINTR) \
+| 				{ \
+| 				YY_FATAL_ERROR( "input in flex scanner failed" ); \
+| 				break; \
+| 				} \
+| 			errno=0; \
+| 			clearerr(yyin); \
+| 			} \
+| 		}\
+| \
+| 
+| #endif
+| 
+| /* No semi-colon after return; correct usage is to write "yyterminate();" -
+|  * we don't want an extra ';' after the "return" because that will cause
+|  * some compilers to complain about unreachable statements.
+|  */
+| #ifndef yyterminate
+| #define yyterminate() return YY_NULL
+| #endif
+| 
+| /* Number of entries by which start-condition stack grows. */
+| #ifndef YY_START_STACK_INCR
+| #define YY_START_STACK_INCR 25
+| #endif
+| 
+| /* Report a fatal error. */
+| #ifndef YY_FATAL_ERROR
+| #define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
+| #endif
+| 
+| /* end tables serialization structures and prototypes */
+| 
+| /* Default declaration of generated scanner - a define so the user can
+|  * easily add parameters.
+|  */
+| #ifndef YY_DECL
+| #define YY_DECL_IS_OURS 1
+| 
+| extern int yylex (void);
+| 
+| #define YY_DECL int yylex (void)
+| #endif /* !YY_DECL */
+| 
+| /* Code executed at the beginning of each rule, after yytext and yyleng
+|  * have been set up.
+|  */
+| #ifndef YY_USER_ACTION
+| #define YY_USER_ACTION
+| #endif
+| 
+| /* Code executed at the end of each rule. */
+| #ifndef YY_BREAK
+| #define YY_BREAK break;
+| #endif
+| 
+| #define YY_RULE_SETUP \
+| 	YY_USER_ACTION
+| 
+| /** The main scanner function which does all the work.
+|  */
+| YY_DECL
+| {
+| 	register yy_state_type yy_current_state;
+| 	register char *yy_cp, *yy_bp;
+| 	register int yy_act;
+|     
+| #line 1 "conftest.l"
+| 
+| #line 652 "lex.yy.c"
+| 
+| 	if ( !(yy_init) )
+| 		{
+| 		(yy_init) = 1;
+| 
+| #ifdef YY_USER_INIT
+| 		YY_USER_INIT;
+| #endif
+| 
+|         /* Create the reject buffer large enough to save one state per allowed character. */
+|         if ( ! (yy_state_buf) )
+|             (yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  );
+|             if ( ! (yy_state_buf) )
+|                 YY_FATAL_ERROR( "out of dynamic memory in yylex()" );
+| 
+| 		if ( ! (yy_start) )
+| 			(yy_start) = 1;	/* first start state */
+| 
+| 		if ( ! yyin )
+| 			yyin = stdin;
+| 
+| 		if ( ! yyout )
+| 			yyout = stdout;
+| 
+| 		if ( ! YY_CURRENT_BUFFER ) {
+| 			yyensure_buffer_stack ();
+| 			YY_CURRENT_BUFFER_LVALUE =
+| 				yy_create_buffer(yyin,YY_BUF_SIZE );
+| 		}
+| 
+| 		yy_load_buffer_state( );
+| 		}
+| 
+| 	while ( 1 )		/* loops until end-of-file is reached */
+| 		{
+| 		(yy_more_len) = 0;
+| 		if ( (yy_more_flag) )
+| 			{
+| 			(yy_more_len) = (yy_c_buf_p) - (yytext_ptr);
+| 			(yy_more_flag) = 0;
+| 			}
+| 		yy_cp = (yy_c_buf_p);
+| 
+| 		/* Support of yytext. */
+| 		*yy_cp = (yy_hold_char);
+| 
+| 		/* yy_bp points to the position in yy_ch_buf of the start of
+| 		 * the current run.
+| 		 */
+| 		yy_bp = yy_cp;
+| 
+| 		yy_current_state = (yy_start);
+| 
+| 		(yy_state_ptr) = (yy_state_buf);
+| 		*(yy_state_ptr)++ = yy_current_state;
+| 
+| yy_match:
+| 		do
+| 			{
+| 			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
+| 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+| 				{
+| 				yy_current_state = (int) yy_def[yy_current_state];
+| 				if ( yy_current_state >= 13 )
+| 					yy_c = yy_meta[(unsigned int) yy_c];
+| 				}
+| 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+| 			*(yy_state_ptr)++ = yy_current_state;
+| 			++yy_cp;
+| 			}
+| 		while ( yy_base[yy_current_state] != 10 );
+| 
+| yy_find_action:
+| 		yy_current_state = *--(yy_state_ptr);
+| 		(yy_lp) = yy_accept[yy_current_state];
+| find_rule: /* we branch to this label when backing up */
+| 		for ( ; ; ) /* until we find what rule we matched */
+| 			{
+| 			if ( (yy_lp) && (yy_lp) < yy_accept[yy_current_state + 1] )
+| 				{
+| 				yy_act = yy_acclist[(yy_lp)];
+| 					{
+| 					(yy_full_match) = yy_cp;
+| 					break;
+| 					}
+| 				}
+| 			--yy_cp;
+| 			yy_current_state = *--(yy_state_ptr);
+| 			(yy_lp) = yy_accept[yy_current_state];
+| 			}
+| 
+| 		YY_DO_BEFORE_ACTION;
+| 
+| do_action:	/* This label is used only to access EOF actions. */
+| 
+| 		switch ( yy_act )
+| 	{ /* beginning of action switch */
+| case 1:
+| YY_RULE_SETUP
+| #line 2 "conftest.l"
+| { ECHO; }
+| 	YY_BREAK
+| case 2:
+| YY_RULE_SETUP
+| #line 3 "conftest.l"
+| { REJECT; }
+| 	YY_BREAK
+| case 3:
+| YY_RULE_SETUP
+| #line 4 "conftest.l"
+| { yymore (); }
+| 	YY_BREAK
+| case 4:
+| YY_RULE_SETUP
+| #line 5 "conftest.l"
+| { yyless (1); }
+| 	YY_BREAK
+| case 5:
+| YY_RULE_SETUP
+| #line 6 "conftest.l"
+| { yyless (input () != 0); }
+| 	YY_BREAK
+| case 6:
+| YY_RULE_SETUP
+| #line 7 "conftest.l"
+| { unput (yytext[0]); }
+| 	YY_BREAK
+| case 7:
+| YY_RULE_SETUP
+| #line 8 "conftest.l"
+| { BEGIN INITIAL; }
+| 	YY_BREAK
+| case 8:
+| YY_RULE_SETUP
+| #line 9 "conftest.l"
+| ECHO;
+| 	YY_BREAK
+| #line 790 "lex.yy.c"
+| 			case YY_STATE_EOF(INITIAL):
+| 				yyterminate();
+| 
+| 	case YY_END_OF_BUFFER:
+| 		{
+| 		/* Amount of text matched not including the EOB char. */
+| 		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
+| 
+| 		/* Undo the effects of YY_DO_BEFORE_ACTION. */
+| 		*yy_cp = (yy_hold_char);
+| 		YY_RESTORE_YY_MORE_OFFSET
+| 
+| 		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
+| 			{
+| 			/* We're scanning a new file or input source.  It's
+| 			 * possible that this happened because the user
+| 			 * just pointed yyin at a new source and called
+| 			 * yylex().  If so, then we have to assure
+| 			 * consistency between YY_CURRENT_BUFFER and our
+| 			 * globals.  Here is the right place to do so, because
+| 			 * this is the first action (other than possibly a
+| 			 * back-up) that will match for the new input source.
+| 			 */
+| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+| 			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
+| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
+| 			}
+| 
+| 		/* Note that here we test for yy_c_buf_p "<=" to the position
+| 		 * of the first EOB in the buffer, since yy_c_buf_p will
+| 		 * already have been incremented past the NUL character
+| 		 * (since all states make transitions on EOB to the
+| 		 * end-of-buffer state).  Contrast this with the test
+| 		 * in input().
+| 		 */
+| 		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+| 			{ /* This was really a NUL. */
+| 			yy_state_type yy_next_state;
+| 
+| 			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
+| 
+| 			yy_current_state = yy_get_previous_state(  );
+| 
+| 			/* Okay, we're now positioned to make the NUL
+| 			 * transition.  We couldn't have
+| 			 * yy_get_previous_state() go ahead and do it
+| 			 * for us because it doesn't know how to deal
+| 			 * with the possibility of jamming (and we don't
+| 			 * want to build jamming into it because then it
+| 			 * will run more slowly).
+| 			 */
+| 
+| 			yy_next_state = yy_try_NUL_trans( yy_current_state );
+| 
+| 			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+| 
+| 			if ( yy_next_state )
+| 				{
+| 				/* Consume the NUL. */
+| 				yy_cp = ++(yy_c_buf_p);
+| 				yy_current_state = yy_next_state;
+| 				goto yy_match;
+| 				}
+| 
+| 			else
+| 				{
+| 				yy_cp = (yy_c_buf_p);
+| 				goto yy_find_action;
+| 				}
+| 			}
+| 
+| 		else switch ( yy_get_next_buffer(  ) )
+| 			{
+| 			case EOB_ACT_END_OF_FILE:
+| 				{
+| 				(yy_did_buffer_switch_on_eof) = 0;
+| 
+| 				if ( yywrap( ) )
+| 					{
+| 					/* Note: because we've taken care in
+| 					 * yy_get_next_buffer() to have set up
+| 					 * yytext, we can now set up
+| 					 * yy_c_buf_p so that if some total
+| 					 * hoser (like flex itself) wants to
+| 					 * call the scanner after we return the
+| 					 * YY_NULL, it'll still work - another
+| 					 * YY_NULL will get returned.
+| 					 */
+| 					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
+| 
+| 					yy_act = YY_STATE_EOF(YY_START);
+| 					goto do_action;
+| 					}
+| 
+| 				else
+| 					{
+| 					if ( ! (yy_did_buffer_switch_on_eof) )
+| 						YY_NEW_FILE;
+| 					}
+| 				break;
+| 				}
+| 
+| 			case EOB_ACT_CONTINUE_SCAN:
+| 				(yy_c_buf_p) =
+| 					(yytext_ptr) + yy_amount_of_matched_text;
+| 
+| 				yy_current_state = yy_get_previous_state(  );
+| 
+| 				yy_cp = (yy_c_buf_p);
+| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+| 				goto yy_match;
+| 
+| 			case EOB_ACT_LAST_MATCH:
+| 				(yy_c_buf_p) =
+| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
+| 
+| 				yy_current_state = yy_get_previous_state(  );
+| 
+| 				yy_cp = (yy_c_buf_p);
+| 				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
+| 				goto yy_find_action;
+| 			}
+| 		break;
+| 		}
+| 
+| 	default:
+| 		YY_FATAL_ERROR(
+| 			"fatal flex scanner internal error--no action found" );
+| 	} /* end of action switch */
+| 		} /* end of scanning one token */
+| } /* end of yylex */
+| 
+| /* yy_get_next_buffer - try to read in a new buffer
+|  *
+|  * Returns a code representing an action:
+|  *	EOB_ACT_LAST_MATCH -
+|  *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
+|  *	EOB_ACT_END_OF_FILE - end of file
+|  */
+| static int yy_get_next_buffer (void)
+| {
+|     	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+| 	register char *source = (yytext_ptr);
+| 	register int number_to_move, i;
+| 	int ret_val;
+| 
+| 	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
+| 		YY_FATAL_ERROR(
+| 		"fatal flex scanner internal error--end of buffer missed" );
+| 
+| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
+| 		{ /* Don't try to fill the buffer, so this is an EOF. */
+| 		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
+| 			{
+| 			/* We matched a single character, the EOB, so
+| 			 * treat this as a final EOF.
+| 			 */
+| 			return EOB_ACT_END_OF_FILE;
+| 			}
+| 
+| 		else
+| 			{
+| 			/* We matched some text prior to the EOB, first
+| 			 * process it.
+| 			 */
+| 			return EOB_ACT_LAST_MATCH;
+| 			}
+| 		}
+| 
+| 	/* Try to read more data. */
+| 
+| 	/* First move last chars to start of buffer. */
+| 	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
+| 
+| 	for ( i = 0; i < number_to_move; ++i )
+| 		*(dest++) = *(source++);
+| 
+| 	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
+| 		/* don't do the read, it's not guaranteed to return an EOF,
+| 		 * just force an EOF
+| 		 */
+| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
+| 
+| 	else
+| 		{
+| 			int num_to_read =
+| 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
+| 
+| 		while ( num_to_read <= 0 )
+| 			{ /* Not enough room in the buffer - grow it. */
+| 
+| 			YY_FATAL_ERROR(
+| "input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
+| 
+| 			}
+| 
+| 		if ( num_to_read > YY_READ_BUF_SIZE )
+| 			num_to_read = YY_READ_BUF_SIZE;
+| 
+| 		/* Read in more data. */
+| 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
+| 			(yy_n_chars), (size_t) num_to_read );
+| 
+| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+| 		}
+| 
+| 	if ( (yy_n_chars) == 0 )
+| 		{
+| 		if ( number_to_move == YY_MORE_ADJ )
+| 			{
+| 			ret_val = EOB_ACT_END_OF_FILE;
+| 			yyrestart(yyin  );
+| 			}
+| 
+| 		else
+| 			{
+| 			ret_val = EOB_ACT_LAST_MATCH;
+| 			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
+| 				YY_BUFFER_EOF_PENDING;
+| 			}
+| 		}
+| 
+| 	else
+| 		ret_val = EOB_ACT_CONTINUE_SCAN;
+| 
+| 	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+| 		/* Extend the array by 50%, plus the number we really need. */
+| 		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
+| 		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
+| 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+| 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
+| 	}
+| 
+| 	(yy_n_chars) += number_to_move;
+| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
+| 	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
+| 
+| 	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
+| 
+| 	return ret_val;
+| }
+| 
+| /* yy_get_previous_state - get the state just before the EOB char was reached */
+| 
+|     static yy_state_type yy_get_previous_state (void)
+| {
+| 	register yy_state_type yy_current_state;
+| 	register char *yy_cp;
+|     
+| 	yy_current_state = (yy_start);
+| 
+| 	(yy_state_ptr) = (yy_state_buf);
+| 	*(yy_state_ptr)++ = yy_current_state;
+| 
+| 	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
+| 		{
+| 		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+| 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+| 			{
+| 			yy_current_state = (int) yy_def[yy_current_state];
+| 			if ( yy_current_state >= 13 )
+| 				yy_c = yy_meta[(unsigned int) yy_c];
+| 			}
+| 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+| 		*(yy_state_ptr)++ = yy_current_state;
+| 		}
+| 
+| 	return yy_current_state;
+| }
+| 
+| /* yy_try_NUL_trans - try to make a transition on the NUL character
+|  *
+|  * synopsis
+|  *	next_state = yy_try_NUL_trans( current_state );
+|  */
+|     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
+| {
+| 	register int yy_is_jam;
+|     
+| 	register YY_CHAR yy_c = 1;
+| 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
+| 		{
+| 		yy_current_state = (int) yy_def[yy_current_state];
+| 		if ( yy_current_state >= 13 )
+| 			yy_c = yy_meta[(unsigned int) yy_c];
+| 		}
+| 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+| 	yy_is_jam = (yy_current_state == 12);
+| 	if ( ! yy_is_jam )
+| 		*(yy_state_ptr)++ = yy_current_state;
+| 
+| 	return yy_is_jam ? 0 : yy_current_state;
+| }
+| 
+|     static void yyunput (int c, register char * yy_bp )
+| {
+| 	register char *yy_cp;
+|     
+|     yy_cp = (yy_c_buf_p);
+| 
+| 	/* undo effects of setting up yytext */
+| 	*yy_cp = (yy_hold_char);
+| 
+| 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+| 		{ /* need to shift things up to make room */
+| 		/* +2 for EOB chars. */
+| 		register int number_to_move = (yy_n_chars) + 2;
+| 		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+| 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
+| 		register char *source =
+| 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
+| 
+| 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
+| 			*--dest = *--source;
+| 
+| 		yy_cp += (int) (dest - source);
+| 		yy_bp += (int) (dest - source);
+| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
+| 			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+| 
+| 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
+| 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
+| 		}
+| 
+| 	*--yy_cp = (char) c;
+| 
+| 	(yytext_ptr) = yy_bp;
+| 	(yy_hold_char) = *yy_cp;
+| 	(yy_c_buf_p) = yy_cp;
+| }
+| 
+| #ifndef YY_NO_INPUT
+| #ifdef __cplusplus
+|     static int yyinput (void)
+| #else
+|     static int input  (void)
+| #endif
+| 
+| {
+| 	int c;
+|     
+| 	*(yy_c_buf_p) = (yy_hold_char);
+| 
+| 	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
+| 		{
+| 		/* yy_c_buf_p now points to the character we want to return.
+| 		 * If this occurs *before* the EOB characters, then it's a
+| 		 * valid NUL; if not, then we've hit the end of the buffer.
+| 		 */
+| 		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
+| 			/* This was really a NUL. */
+| 			*(yy_c_buf_p) = '\0';
+| 
+| 		else
+| 			{ /* need more input */
+| 			int offset = (yy_c_buf_p) - (yytext_ptr);
+| 			++(yy_c_buf_p);
+| 
+| 			switch ( yy_get_next_buffer(  ) )
+| 				{
+| 				case EOB_ACT_LAST_MATCH:
+| 					/* This happens because yy_g_n_b()
+| 					 * sees that we've accumulated a
+| 					 * token and flags that we need to
+| 					 * try matching the token before
+| 					 * proceeding.  But for input(),
+| 					 * there's no matching to consider.
+| 					 * So convert the EOB_ACT_LAST_MATCH
+| 					 * to EOB_ACT_END_OF_FILE.
+| 					 */
+| 
+| 					/* Reset buffer status. */
+| 					yyrestart(yyin );
+| 
+| 					/*FALLTHROUGH*/
+| 
+| 				case EOB_ACT_END_OF_FILE:
+| 					{
+| 					if ( yywrap( ) )
+| 						return EOF;
+| 
+| 					if ( ! (yy_did_buffer_switch_on_eof) )
+| 						YY_NEW_FILE;
+| #ifdef __cplusplus
+| 					return yyinput();
+| #else
+| 					return input();
+| #endif
+| 					}
+| 
+| 				case EOB_ACT_CONTINUE_SCAN:
+| 					(yy_c_buf_p) = (yytext_ptr) + offset;
+| 					break;
+| 				}
+| 			}
+| 		}
+| 
+| 	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
+| 	*(yy_c_buf_p) = '\0';	/* preserve yytext */
+| 	(yy_hold_char) = *++(yy_c_buf_p);
+| 
+| 	return c;
+| }
+| #endif	/* ifndef YY_NO_INPUT */
+| 
+| /** Immediately switch to a different input stream.
+|  * @param input_file A readable stream.
+|  * 
+|  * @note This function does not reset the start condition to @c INITIAL .
+|  */
+|     void yyrestart  (FILE * input_file )
+| {
+|     
+| 	if ( ! YY_CURRENT_BUFFER ){
+|         yyensure_buffer_stack ();
+| 		YY_CURRENT_BUFFER_LVALUE =
+|             yy_create_buffer(yyin,YY_BUF_SIZE );
+| 	}
+| 
+| 	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
+| 	yy_load_buffer_state( );
+| }
+| 
+| /** Switch to a different input buffer.
+|  * @param new_buffer The new input buffer.
+|  * 
+|  */
+|     void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
+| {
+|     
+| 	/* TODO. We should be able to replace this entire function body
+| 	 * with
+| 	 *		yypop_buffer_state();
+| 	 *		yypush_buffer_state(new_buffer);
+|      */
+| 	yyensure_buffer_stack ();
+| 	if ( YY_CURRENT_BUFFER == new_buffer )
+| 		return;
+| 
+| 	if ( YY_CURRENT_BUFFER )
+| 		{
+| 		/* Flush out information for old buffer. */
+| 		*(yy_c_buf_p) = (yy_hold_char);
+| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+| 		}
+| 
+| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+| 	yy_load_buffer_state( );
+| 
+| 	/* We don't actually know whether we did this switch during
+| 	 * EOF (yywrap()) processing, but the only time this flag
+| 	 * is looked at is after yywrap() is called, so it's safe
+| 	 * to go ahead and always set it.
+| 	 */
+| 	(yy_did_buffer_switch_on_eof) = 1;
+| }
+| 
+| static void yy_load_buffer_state  (void)
+| {
+|     	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
+| 	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
+| 	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
+| 	(yy_hold_char) = *(yy_c_buf_p);
+| }
+| 
+| /** Allocate and initialize an input buffer state.
+|  * @param file A readable stream.
+|  * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
+|  * 
+|  * @return the allocated buffer state.
+|  */
+|     YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
+| {
+| 	YY_BUFFER_STATE b;
+|     
+| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+| 	if ( ! b )
+| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+| 
+| 	b->yy_buf_size = size;
+| 
+| 	/* yy_ch_buf has to be 2 characters longer than the size given because
+| 	 * we need to put in 2 end-of-buffer characters.
+| 	 */
+| 	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
+| 	if ( ! b->yy_ch_buf )
+| 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
+| 
+| 	b->yy_is_our_buffer = 1;
+| 
+| 	yy_init_buffer(b,file );
+| 
+| 	return b;
+| }
+| 
+| /** Destroy the buffer.
+|  * @param b a buffer created with yy_create_buffer()
+|  * 
+|  */
+|     void yy_delete_buffer (YY_BUFFER_STATE  b )
+| {
+|     
+| 	if ( ! b )
+| 		return;
+| 
+| 	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
+| 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
+| 
+| 	if ( b->yy_is_our_buffer )
+| 		yyfree((void *) b->yy_ch_buf  );
+| 
+| 	yyfree((void *) b  );
+| }
+| 
+| #ifndef __cplusplus
+| extern int isatty (int );
+| #endif /* __cplusplus */
+|     
+| /* Initializes or reinitializes a buffer.
+|  * This function is sometimes called more than once on the same buffer,
+|  * such as during a yyrestart() or at EOF.
+|  */
+|     static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
+| 
+| {
+| 	int oerrno = errno;
+|     
+| 	yy_flush_buffer(b );
+| 
+| 	b->yy_input_file = file;
+| 	b->yy_fill_buffer = 1;
+| 
+|     /* If b is the current buffer, then yy_init_buffer was _probably_
+|      * called from yyrestart() or through yy_get_next_buffer.
+|      * In that case, we don't want to reset the lineno or column.
+|      */
+|     if (b != YY_CURRENT_BUFFER){
+|         b->yy_bs_lineno = 1;
+|         b->yy_bs_column = 0;
+|     }
+| 
+|         b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
+|     
+| 	errno = oerrno;
+| }
+| 
+| /** Discard all buffered characters. On the next scan, YY_INPUT will be called.
+|  * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
+|  * 
+|  */
+|     void yy_flush_buffer (YY_BUFFER_STATE  b )
+| {
+|     	if ( ! b )
+| 		return;
+| 
+| 	b->yy_n_chars = 0;
+| 
+| 	/* We always need two end-of-buffer characters.  The first causes
+| 	 * a transition to the end-of-buffer state.  The second causes
+| 	 * a jam in that state.
+| 	 */
+| 	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
+| 	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
+| 
+| 	b->yy_buf_pos = &b->yy_ch_buf[0];
+| 
+| 	b->yy_at_bol = 1;
+| 	b->yy_buffer_status = YY_BUFFER_NEW;
+| 
+| 	if ( b == YY_CURRENT_BUFFER )
+| 		yy_load_buffer_state( );
+| }
+| 
+| /** Pushes the new state onto the stack. The new state becomes
+|  *  the current state. This function will allocate the stack
+|  *  if necessary.
+|  *  @param new_buffer The new state.
+|  *  
+|  */
+| void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
+| {
+|     	if (new_buffer == NULL)
+| 		return;
+| 
+| 	yyensure_buffer_stack();
+| 
+| 	/* This block is copied from yy_switch_to_buffer. */
+| 	if ( YY_CURRENT_BUFFER )
+| 		{
+| 		/* Flush out information for old buffer. */
+| 		*(yy_c_buf_p) = (yy_hold_char);
+| 		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
+| 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
+| 		}
+| 
+| 	/* Only push if top exists. Otherwise, replace top. */
+| 	if (YY_CURRENT_BUFFER)
+| 		(yy_buffer_stack_top)++;
+| 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
+| 
+| 	/* copied from yy_switch_to_buffer. */
+| 	yy_load_buffer_state( );
+| 	(yy_did_buffer_switch_on_eof) = 1;
+| }
+| 
+| /** Removes and deletes the top of the stack, if present.
+|  *  The next element becomes the new top.
+|  *  
+|  */
+| void yypop_buffer_state (void)
+| {
+|     	if (!YY_CURRENT_BUFFER)
+| 		return;
+| 
+| 	yy_delete_buffer(YY_CURRENT_BUFFER );
+| 	YY_CURRENT_BUFFER_LVALUE = NULL;
+| 	if ((yy_buffer_stack_top) > 0)
+| 		--(yy_buffer_stack_top);
+| 
+| 	if (YY_CURRENT_BUFFER) {
+| 		yy_load_buffer_state( );
+| 		(yy_did_buffer_switch_on_eof) = 1;
+| 	}
+| }
+| 
+| /* Allocates the stack if it does not exist.
+|  *  Guarantees space for at least one push.
+|  */
+| static void yyensure_buffer_stack (void)
+| {
+| 	int num_to_alloc;
+|     
+| 	if (!(yy_buffer_stack)) {
+| 
+| 		/* First allocation is just for 2 elements, since we don't know if this
+| 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
+| 		 * immediate realloc on the next call.
+|          */
+| 		num_to_alloc = 1;
+| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
+| 								(num_to_alloc * sizeof(struct yy_buffer_state*)
+| 								);
+| 		if ( ! (yy_buffer_stack) )
+| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+| 								  
+| 		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
+| 				
+| 		(yy_buffer_stack_max) = num_to_alloc;
+| 		(yy_buffer_stack_top) = 0;
+| 		return;
+| 	}
+| 
+| 	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
+| 
+| 		/* Increase the buffer to prepare for a possible push. */
+| 		int grow_size = 8 /* arbitrary grow size */;
+| 
+| 		num_to_alloc = (yy_buffer_stack_max) + grow_size;
+| 		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
+| 								((yy_buffer_stack),
+| 								num_to_alloc * sizeof(struct yy_buffer_state*)
+| 								);
+| 		if ( ! (yy_buffer_stack) )
+| 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
+| 
+| 		/* zero only the new slots.*/
+| 		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
+| 		(yy_buffer_stack_max) = num_to_alloc;
+| 	}
+| }
+| 
+| /** Setup the input buffer state to scan directly from a user-specified character buffer.
+|  * @param base the character buffer
+|  * @param size the size in bytes of the character buffer
+|  * 
+|  * @return the newly allocated buffer state object. 
+|  */
+| YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
+| {
+| 	YY_BUFFER_STATE b;
+|     
+| 	if ( size < 2 ||
+| 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
+| 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
+| 		/* They forgot to leave room for the EOB's. */
+| 		return 0;
+| 
+| 	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
+| 	if ( ! b )
+| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
+| 
+| 	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
+| 	b->yy_buf_pos = b->yy_ch_buf = base;
+| 	b->yy_is_our_buffer = 0;
+| 	b->yy_input_file = 0;
+| 	b->yy_n_chars = b->yy_buf_size;
+| 	b->yy_is_interactive = 0;
+| 	b->yy_at_bol = 1;
+| 	b->yy_fill_buffer = 0;
+| 	b->yy_buffer_status = YY_BUFFER_NEW;
+| 
+| 	yy_switch_to_buffer(b  );
+| 
+| 	return b;
+| }
+| 
+| /** Setup the input buffer state to scan a string. The next call to yylex() will
+|  * scan from a @e copy of @a str.
+|  * @param yystr a NUL-terminated string to scan
+|  * 
+|  * @return the newly allocated buffer state object.
+|  * @note If you want to scan bytes that may contain NUL values, then use
+|  *       yy_scan_bytes() instead.
+|  */
+| YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
+| {
+|     
+| 	return yy_scan_bytes(yystr,strlen(yystr) );
+| }
+| 
+| /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
+|  * scan from a @e copy of @a bytes.
+|  * @param bytes the byte buffer to scan
+|  * @param len the number of bytes in the buffer pointed to by @a bytes.
+|  * 
+|  * @return the newly allocated buffer state object.
+|  */
+| YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len )
+| {
+| 	YY_BUFFER_STATE b;
+| 	char *buf;
+| 	yy_size_t n;
+| 	int i;
+|     
+| 	/* Get memory for full buffer, including space for trailing EOB's. */
+| 	n = _yybytes_len + 2;
+| 	buf = (char *) yyalloc(n  );
+| 	if ( ! buf )
+| 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
+| 
+| 	for ( i = 0; i < _yybytes_len; ++i )
+| 		buf[i] = yybytes[i];
+| 
+| 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+| 
+| 	b = yy_scan_buffer(buf,n );
+| 	if ( ! b )
+| 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
+| 
+| 	/* It's okay to grow etc. this buffer, and we should throw it
+| 	 * away when we're done.
+| 	 */
+| 	b->yy_is_our_buffer = 1;
+| 
+| 	return b;
+| }
+| 
+| #ifndef YY_EXIT_FAILURE
+| #define YY_EXIT_FAILURE 2
+| #endif
+| 
+| static void yy_fatal_error (yyconst char* msg )
+| {
+|     	(void) fprintf( stderr, "%s\n", msg );
+| 	exit( YY_EXIT_FAILURE );
+| }
+| 
+| /* Redefine yyless() so it works in section 3 code. */
+| 
+| #undef yyless
+| #define yyless(n) \
+| 	do \
+| 		{ \
+| 		/* Undo effects of setting up yytext. */ \
+|         int yyless_macro_arg = (n); \
+|         YY_LESS_LINENO(yyless_macro_arg);\
+| 		yytext[yyleng] = (yy_hold_char); \
+| 		(yy_c_buf_p) = yytext + yyless_macro_arg; \
+| 		(yy_hold_char) = *(yy_c_buf_p); \
+| 		*(yy_c_buf_p) = '\0'; \
+| 		yyleng = yyless_macro_arg; \
+| 		} \
+| 	while ( 0 )
+| 
+| /* Accessor  methods (get/set functions) to struct members. */
+| 
+| /** Get the current line number.
+|  * 
+|  */
+| int yyget_lineno  (void)
+| {
+|         
+|     return yylineno;
+| }
+| 
+| /** Get the input stream.
+|  * 
+|  */
+| FILE *yyget_in  (void)
+| {
+|         return yyin;
+| }
+| 
+| /** Get the output stream.
+|  * 
+|  */
+| FILE *yyget_out  (void)
+| {
+|         return yyout;
+| }
+| 
+| /** Get the length of the current token.
+|  * 
+|  */
+| int yyget_leng  (void)
+| {
+|         return yyleng;
+| }
+| 
+| /** Get the current token.
+|  * 
+|  */
+| 
+| char *yyget_text  (void)
+| {
+|         return yytext;
+| }
+| 
+| /** Set the current line number.
+|  * @param line_number
+|  * 
+|  */
+| void yyset_lineno (int  line_number )
+| {
+|     
+|     yylineno = line_number;
+| }
+| 
+| /** Set the input stream. This does not discard the current
+|  * input buffer.
+|  * @param in_str A readable stream.
+|  * 
+|  * @see yy_switch_to_buffer
+|  */
+| void yyset_in (FILE *  in_str )
+| {
+|         yyin = in_str ;
+| }
+| 
+| void yyset_out (FILE *  out_str )
+| {
+|         yyout = out_str ;
+| }
+| 
+| int yyget_debug  (void)
+| {
+|         return yy_flex_debug;
+| }
+| 
+| void yyset_debug (int  bdebug )
+| {
+|         yy_flex_debug = bdebug ;
+| }
+| 
+| static int yy_init_globals (void)
+| {
+|         /* Initialization is the same as for the non-reentrant scanner.
+|      * This function is called from yylex_destroy(), so don't allocate here.
+|      */
+| 
+|     (yy_buffer_stack) = 0;
+|     (yy_buffer_stack_top) = 0;
+|     (yy_buffer_stack_max) = 0;
+|     (yy_c_buf_p) = (char *) 0;
+|     (yy_init) = 0;
+|     (yy_start) = 0;
+| 
+|     (yy_state_buf) = 0;
+|     (yy_state_ptr) = 0;
+|     (yy_full_match) = 0;
+|     (yy_lp) = 0;
+| 
+| /* Defined in main.c */
+| #ifdef YY_STDINIT
+|     yyin = stdin;
+|     yyout = stdout;
+| #else
+|     yyin = (FILE *) 0;
+|     yyout = (FILE *) 0;
+| #endif
+| 
+|     /* For future reference: Set errno on error, since we are called by
+|      * yylex_init()
+|      */
+|     return 0;
+| }
+| 
+| /* yylex_destroy is for both reentrant and non-reentrant scanners. */
+| int yylex_destroy  (void)
+| {
+|     
+|     /* Pop the buffer stack, destroying each element. */
+| 	while(YY_CURRENT_BUFFER){
+| 		yy_delete_buffer(YY_CURRENT_BUFFER  );
+| 		YY_CURRENT_BUFFER_LVALUE = NULL;
+| 		yypop_buffer_state();
+| 	}
+| 
+| 	/* Destroy the stack itself. */
+| 	yyfree((yy_buffer_stack) );
+| 	(yy_buffer_stack) = NULL;
+| 
+|     yyfree ( (yy_state_buf) );
+|     (yy_state_buf)  = NULL;
+| 
+|     /* Reset the globals. This is important in a non-reentrant scanner so the next time
+|      * yylex() is called, initialization will occur. */
+|     yy_init_globals( );
+| 
+|     return 0;
+| }
+| 
+| /*
+|  * Internal utility routines.
+|  */
+| 
+| #ifndef yytext_ptr
+| static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
+| {
+| 	register int i;
+| 	for ( i = 0; i < n; ++i )
+| 		s1[i] = s2[i];
+| }
+| #endif
+| 
+| #ifdef YY_NEED_STRLEN
+| static int yy_flex_strlen (yyconst char * s )
+| {
+| 	register int n;
+| 	for ( n = 0; s[n]; ++n )
+| 		;
+| 
+| 	return n;
+| }
+| #endif
+| 
+| void *yyalloc (yy_size_t  size )
+| {
+| 	return (void *) malloc( size );
+| }
+| 
+| void *yyrealloc  (void * ptr, yy_size_t  size )
+| {
+| 	/* The cast to (char *) in the following accommodates both
+| 	 * implementations that use char* generic pointers, and those
+| 	 * that use void* generic pointers.  It works with the latter
+| 	 * because both ANSI C and C++ allow castless assignment from
+| 	 * any pointer type to void*, and deal with argument conversions
+| 	 * as though doing an assignment.
+| 	 */
+| 	return (void *) realloc( (char *) ptr, size );
+| }
+| 
+| void yyfree (void * ptr )
+| {
+| 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
+| }
+| 
+| #define YYTABLES_NAME "yytables"
+| 
+| #line 9 "conftest.l"
+| 
+| 
+| #ifdef YYTEXT_POINTER
+| extern char *yytext;
+| #endif
+| int
+| main (void)
+| {
+|   return ! yylex () + ! yywrap ();
+| }
+configure:8857: gcc -std=gnu99 -o conftest -O2 -g -Wall -W -Wpointer-arith -Wwrite-strings -Wstrict-prototypes -Wshadow -Wformat-security -Wredundant-decls -Wno-missing-field-initializers  -D_REENTRANT  conftest.c -lfl  >&5
+
+## ---------------- ##
+## Cache variables. ##
+## ---------------- ##
+
+ac_cv_build=i386-pc-solaris2.11
+ac_cv_c_compiler_gnu=yes
+ac_cv_env_CC_set=''
+ac_cv_env_CC_value=''
+ac_cv_env_CFLAGS_set=set
+ac_cv_env_CFLAGS_value='-O2 -g'
+ac_cv_env_CPPFLAGS_set=set
+ac_cv_env_CPPFLAGS_value=''
+ac_cv_env_CPP_set=''
+ac_cv_env_CPP_value=''
+ac_cv_env_LDFLAGS_set=set
+ac_cv_env_LDFLAGS_value=''
+ac_cv_env_LIBS_set=''
+ac_cv_env_LIBS_value=''
+ac_cv_env_build_alias_set=set
+ac_cv_env_build_alias_value=i386-pc-solaris2.11
+ac_cv_env_host_alias_set=''
+ac_cv_env_host_alias_value=''
+ac_cv_env_target_alias_set=''
+ac_cv_env_target_alias_value=''
+ac_cv_header_inttypes_h=yes
+ac_cv_header_memory_h=yes
+ac_cv_header_minix_config_h=no
+ac_cv_header_stdc=yes
+ac_cv_header_stdint_h=yes
+ac_cv_header_stdlib_h=yes
+ac_cv_header_string_h=yes
+ac_cv_header_strings_h=yes
+ac_cv_header_sys_stat_h=yes
+ac_cv_header_sys_types_h=yes
+ac_cv_header_unistd_h=yes
+ac_cv_host=i386-pc-solaris2.11
+ac_cv_lib_lex='none needed'
+ac_cv_lib_z_gzopen=yes
+ac_cv_objext=o
+ac_cv_path_EGREP='/usr/gnu/bin/grep -E'
+ac_cv_path_GREP=/usr/gnu/bin/grep
+ac_cv_path_install='/usr/gnu/bin/install -c'
+ac_cv_path_mkdir=/usr/gnu/bin/mkdir
+ac_cv_prog_AWK=gawk
+ac_cv_prog_CPP='gcc -E'
+ac_cv_prog_LEX=flex
+ac_cv_prog_ac_ct_CC=gcc
+ac_cv_prog_ac_ct_RANLIB=ranlib
+ac_cv_prog_cat=cat
+ac_cv_prog_cc_c89=''
+ac_cv_prog_cc_c99=-std=gnu99
+ac_cv_prog_cc_g=yes
+ac_cv_prog_cc_gcc_c_o=yes
+ac_cv_prog_cc_stdc=-std=gnu99
+ac_cv_prog_eqn=eqn
+ac_cv_prog_grep=grep
+ac_cv_prog_gzip=gzip
+ac_cv_prog_lex_root=lex.yy
+ac_cv_prog_make_make_set=yes
+ac_cv_prog_neqn=neqn
+ac_cv_prog_nroff=nroff
+ac_cv_prog_pic=pic
+ac_cv_prog_preconv=preconv
+ac_cv_prog_refer=refer
+ac_cv_prog_tbl=tbl
+ac_cv_prog_tr=tr
+ac_cv_prog_troff=groff
+ac_cv_safe_to_define___extensions__=yes
+ac_cv_search_strerror='none required'
+am_cv_CC_dependencies_compiler_type=none
+man_cv_gcc_warning_=yes
+man_cv_gcc_warning_format_security=yes
+man_cv_gcc_warning_no_missing_field_initializers=yes
+man_cv_gcc_warning_pointer_arith=yes
+man_cv_gcc_warning_redundant_decls=yes
+man_cv_gcc_warning_shadow=yes
+man_cv_gcc_warning_strict_prototypes=yes
+man_cv_gcc_warning_write_strings=yes
+man_cv_prog_gnu_nroff=yes
+man_cv_prog_nroff_macro=-mandoc
+man_cv_prog_troff_options=-mandoc
+
+## ----------------- ##
+## Output variables. ##
+## ----------------- ##
+
+ACLOCAL='${SHELL} /myshare/nexenta/src/2/man-db/man-db-2.5.7/tools/missing --run aclocal-1.11'
+ALLOCA=''
+ALLOCA_H=''
+AMDEPBACKSLASH=''
+AMDEP_FALSE=''
+AMDEP_TRUE='#'
+AMTAR='${SHELL} /myshare/nexenta/src/2/man-db/man-db-2.5.7/tools/missing --run tar'
+AM_BACKSLASH='\'
+AM_DEFAULT_VERBOSITY='0'
+APPLE_UNIVERSAL_BUILD=''
+AUTOCONF='${SHELL} /myshare/nexenta/src/2/man-db/man-db-2.5.7/tools/missing --run autoconf'
+AUTOHEADER='${SHELL} /myshare/nexenta/src/2/man-db/man-db-2.5.7/tools/missing --run autoheader'
+AUTOMAKE='${SHELL} /myshare/nexenta/src/2/man-db/man-db-2.5.7/tools/missing --run automake-1.11'
+AWK='gawk'
+BITSIZEOF_PTRDIFF_T=''
+BITSIZEOF_SIG_ATOMIC_T=''
+BITSIZEOF_SIZE_T=''
+BITSIZEOF_WCHAR_T=''
+BITSIZEOF_WINT_T=''
+BUILD_INCLUDED_LIBINTL=''
+CATOBJEXT=''
+CC='gcc -std=gnu99'
+CCDEPMODE='depmode=none'
+CFLAGS='-O2 -g -Wall -W -Wpointer-arith -Wwrite-strings -Wstrict-prototypes -Wshadow -Wformat-security -Wredundant-decls -Wno-missing-field-initializers'
+CFLAG_VISIBILITY=''
+CPP='gcc -E'
+CPPFLAGS=' -D_REENTRANT'
+CROSS_COMPILING_FALSE=''
+CROSS_COMPILING_TRUE=''
+CYGPATH_W='echo'
+DATADIRNAME=''
+DBLIBS=''
+DBTYPE=''
+DEFS=''
+DEPDIR='.deps'
+ECHO_C='\c'
+ECHO_N=''
+ECHO_T=''
+EGREP='/usr/gnu/bin/grep -E'
+EMULTIHOP_HIDDEN=''
+EMULTIHOP_VALUE=''
+ENOLINK_HIDDEN=''
+ENOLINK_VALUE=''
+EOVERFLOW_HIDDEN=''
+EOVERFLOW_VALUE=''
+ERRNO_H=''
+EXEEXT=''
+FLOAT_H=''
+FNMATCH_H=''
+GENCAT=''
+GETOPT_H=''
+GETTEXT_MACRO_VERSION=''
+GLIBC21=''
+GLIBC2=''
+GLOB_H=''
+GL_COND_LIBTOOL_FALSE=''
+GL_COND_LIBTOOL_TRUE=''
+GMSGFMT=''
+GMSGFMT_015=''
+GNULIB_ACCEPT4=''
+GNULIB_ACCEPT=''
+GNULIB_ALPHASORT=''
+GNULIB_ATOLL=''
+GNULIB_BIND=''
+GNULIB_BTOWC=''
+GNULIB_CALLOC_POSIX=''
+GNULIB_CANONICALIZE_FILE_NAME=''
+GNULIB_CHOWN=''
+GNULIB_CLOSE=''
+GNULIB_CONNECT=''
+GNULIB_DIRFD=''
+GNULIB_DPRINTF=''
+GNULIB_DUP2=''
+GNULIB_DUP3=''
+GNULIB_ENVIRON=''
+GNULIB_EUIDACCESS=''
+GNULIB_FACCESSAT=''
+GNULIB_FCHDIR=''
+GNULIB_FCHMODAT=''
+GNULIB_FCHOWNAT=''
+GNULIB_FCLOSE=''
+GNULIB_FCNTL=''
+GNULIB_FDOPENDIR=''
+GNULIB_FFLUSH=''
+GNULIB_FOPEN=''
+GNULIB_FPRINTF=''
+GNULIB_FPRINTF_POSIX=''
+GNULIB_FPURGE=''
+GNULIB_FPUTC=''
+GNULIB_FPUTS=''
+GNULIB_FREOPEN=''
+GNULIB_FSEEK=''
+GNULIB_FSEEKO=''
+GNULIB_FSTATAT=''
+GNULIB_FSYNC=''
+GNULIB_FTELL=''
+GNULIB_FTELLO=''
+GNULIB_FTRUNCATE=''
+GNULIB_FUTIMENS=''
+GNULIB_FWRITE=''
+GNULIB_GETCWD=''
+GNULIB_GETDELIM=''
+GNULIB_GETDOMAINNAME=''
+GNULIB_GETDTABLESIZE=''
+GNULIB_GETGROUPS=''
+GNULIB_GETHOSTNAME=''
+GNULIB_GETLINE=''
+GNULIB_GETLOADAVG=''
+GNULIB_GETLOGIN_R=''
+GNULIB_GETPAGESIZE=''
+GNULIB_GETPEERNAME=''
+GNULIB_GETSOCKNAME=''
+GNULIB_GETSOCKOPT=''
+GNULIB_GETSUBOPT=''
+GNULIB_GETUSERSHELL=''
+GNULIB_LCHMOD=''
+GNULIB_LCHOWN=''
+GNULIB_LINK=''
+GNULIB_LINKAT=''
+GNULIB_LISTEN=''
+GNULIB_LSEEK=''
+GNULIB_LSTAT=''
+GNULIB_MALLOC_POSIX=''
+GNULIB_MBRLEN=''
+GNULIB_MBRTOWC=''
+GNULIB_MBSCASECMP=''
+GNULIB_MBSCASESTR=''
+GNULIB_MBSCHR=''
+GNULIB_MBSCSPN=''
+GNULIB_MBSINIT=''
+GNULIB_MBSLEN=''
+GNULIB_MBSNCASECMP=''
+GNULIB_MBSNLEN=''
+GNULIB_MBSNRTOWCS=''
+GNULIB_MBSPBRK=''
+GNULIB_MBSPCASECMP=''
+GNULIB_MBSRCHR=''
+GNULIB_MBSRTOWCS=''
+GNULIB_MBSSEP=''
+GNULIB_MBSSPN=''
+GNULIB_MBSSTR=''
+GNULIB_MBSTOK_R=''
+GNULIB_MEMCHR=''
+GNULIB_MEMMEM=''
+GNULIB_MEMPCPY=''
+GNULIB_MEMRCHR=''
+GNULIB_MKDIRAT=''
+GNULIB_MKDTEMP=''
+GNULIB_MKFIFO=''
+GNULIB_MKFIFOAT=''
+GNULIB_MKNOD=''
+GNULIB_MKNODAT=''
+GNULIB_MKOSTEMP=''
+GNULIB_MKOSTEMPS=''
+GNULIB_MKSTEMP=''
+GNULIB_MKSTEMPS=''
+GNULIB_OBSTACK_PRINTF=''
+GNULIB_OBSTACK_PRINTF_POSIX=''
+GNULIB_OPEN=''
+GNULIB_OPENAT=''
+GNULIB_PERROR=''
+GNULIB_PIPE2=''
+GNULIB_POPEN=''
+GNULIB_PREAD=''
+GNULIB_PRINTF=''
+GNULIB_PRINTF_POSIX=''
+GNULIB_PUTC=''
+GNULIB_PUTCHAR=''
+GNULIB_PUTENV=''
+GNULIB_PUTS=''
+GNULIB_RANDOM_R=''
+GNULIB_RAWMEMCHR=''
+GNULIB_READLINK=''
+GNULIB_READLINKAT=''
+GNULIB_REALLOC_POSIX=''
+GNULIB_REALPATH=''
+GNULIB_RECV=''
+GNULIB_RECVFROM=''
+GNULIB_REMOVE=''
+GNULIB_RENAME=''
+GNULIB_RENAMEAT=''
+GNULIB_RMDIR=''
+GNULIB_RPMATCH=''
+GNULIB_SCANDIR=''
+GNULIB_SELECT=''
+GNULIB_SEND=''
+GNULIB_SENDTO=''
+GNULIB_SETENV=''
+GNULIB_SETSOCKOPT=''
+GNULIB_SHUTDOWN=''
+GNULIB_SIGACTION=''
+GNULIB_SIGNAL_H_SIGPIPE=''
+GNULIB_SIGPROCMASK=''
+GNULIB_SLEEP=''
+GNULIB_SNPRINTF=''
+GNULIB_SOCKET=''
+GNULIB_SPRINTF_POSIX=''
+GNULIB_STAT=''
+GNULIB_STDIO_H_SIGPIPE=''
+GNULIB_STPCPY=''
+GNULIB_STPNCPY=''
+GNULIB_STRCASESTR=''
+GNULIB_STRCHRNUL=''
+GNULIB_STRDUP=''
+GNULIB_STRERROR=''
+GNULIB_STRNDUP=''
+GNULIB_STRNLEN=''
+GNULIB_STRPBRK=''
+GNULIB_STRSEP=''
+GNULIB_STRSIGNAL=''
+GNULIB_STRSTR=''
+GNULIB_STRTOD=''
+GNULIB_STRTOK_R=''
+GNULIB_STRTOLL=''
+GNULIB_STRTOULL=''
+GNULIB_STRVERSCMP=''
+GNULIB_SYMLINK=''
+GNULIB_SYMLINKAT=''
+GNULIB_UNISTD_H_GETOPT=''
+GNULIB_UNISTD_H_SIGPIPE=''
+GNULIB_UNLINK=''
+GNULIB_UNLINKAT=''
+GNULIB_UNSETENV=''
+GNULIB_USLEEP=''
+GNULIB_UTIMENSAT=''
+GNULIB_VASPRINTF=''
+GNULIB_VDPRINTF=''
+GNULIB_VFPRINTF=''
+GNULIB_VFPRINTF_POSIX=''
+GNULIB_VPRINTF=''
+GNULIB_VPRINTF_POSIX=''
+GNULIB_VSNPRINTF=''
+GNULIB_VSPRINTF_POSIX=''
+GNULIB_WCRTOMB=''
+GNULIB_WCSNRTOMBS=''
+GNULIB_WCSRTOMBS=''
+GNULIB_WCTOB=''
+GNULIB_WCWIDTH=''
+GNULIB_WRITE=''
+GREP='/usr/gnu/bin/grep'
+HAVE_ACCEPT4=''
+HAVE_ALPHASORT=''
+HAVE_ASPRINTF=''
+HAVE_ATOLL=''
+HAVE_BTOWC=''
+HAVE_CALLOC_POSIX=''
+HAVE_CANONICALIZE_FILE_NAME=''
+HAVE_CHOWN=''
+HAVE_DECL_DIRFD=''
+HAVE_DECL_ENVIRON=''
+HAVE_DECL_FPURGE=''
+HAVE_DECL_GETDELIM=''
+HAVE_DECL_GETLINE=''
+HAVE_DECL_GETLOADAVG=''
+HAVE_DECL_GETLOGIN_R=''
+HAVE_DECL_MEMMEM=''
+HAVE_DECL_MEMRCHR=''
+HAVE_DECL_OBSTACK_PRINTF=''
+HAVE_DECL_SNPRINTF=''
+HAVE_DECL_STRDUP=''
+HAVE_DECL_STRERROR=''
+HAVE_DECL_STRNCASECMP=''
+HAVE_DECL_STRNDUP=''
+HAVE_DECL_STRNLEN=''
+HAVE_DECL_STRSIGNAL=''
+HAVE_DECL_STRTOK_R=''
+HAVE_DECL_VSNPRINTF=''
+HAVE_DECL_WCTOB=''
+HAVE_DECL_WCWIDTH=''
+HAVE_DPRINTF=''
+HAVE_DUP2=''
+HAVE_DUP3=''
+HAVE_EUIDACCESS=''
+HAVE_FACCESSAT=''
+HAVE_FCHMODAT=''
+HAVE_FCHOWNAT=''
+HAVE_FCNTL=''
+HAVE_FDOPENDIR=''
+HAVE_FSTATAT=''
+HAVE_FSYNC=''
+HAVE_FTRUNCATE=''
+HAVE_FUTIMENS=''
+HAVE_GETDOMAINNAME=''
+HAVE_GETDTABLESIZE=''
+HAVE_GETGROUPS=''
+HAVE_GETHOSTNAME=''
+HAVE_GETOPT_H=''
+HAVE_GETPAGESIZE=''
+HAVE_GETSUBOPT=''
+HAVE_GETUSERSHELL=''
+HAVE_INTTYPES_H=''
+HAVE_ISWCNTRL=''
+HAVE_LCHMOD=''
+HAVE_LCHOWN=''
+HAVE_LINK=''
+HAVE_LINKAT=''
+HAVE_LONG_LONG_INT=''
+HAVE_LSTAT=''
+HAVE_MALLOC_POSIX=''
+HAVE_MBRLEN=''
+HAVE_MBRTOWC=''
+HAVE_MBSINIT=''
+HAVE_MBSLEN=''
+HAVE_MBSNRTOWCS=''
+HAVE_MBSRTOWCS=''
+HAVE_MEMPCPY=''
+HAVE_MKDIRAT=''
+HAVE_MKDTEMP=''
+HAVE_MKFIFO=''
+HAVE_MKFIFOAT=''
+HAVE_MKNOD=''
+HAVE_MKNODAT=''
+HAVE_MKOSTEMP=''
+HAVE_MKOSTEMPS=''
+HAVE_MKSTEMPS=''
+HAVE_OPENAT=''
+HAVE_OS_H=''
+HAVE_PIPE2=''
+HAVE_POSIX_PRINTF=''
+HAVE_POSIX_SIGNALBLOCKING=''
+HAVE_PREAD=''
+HAVE_RANDOM_H=''
+HAVE_RANDOM_R=''
+HAVE_RAWMEMCHR=''
+HAVE_READLINK=''
+HAVE_READLINKAT=''
+HAVE_REALLOC_POSIX=''
+HAVE_REALPATH=''
+HAVE_RENAMEAT=''
+HAVE_RPMATCH=''
+HAVE_SA_FAMILY_T=''
+HAVE_SCANDIR=''
+HAVE_SETENV=''
+HAVE_SIGACTION=''
+HAVE_SIGINFO_T=''
+HAVE_SIGNED_SIG_ATOMIC_T=''
+HAVE_SIGNED_WCHAR_T=''
+HAVE_SIGNED_WINT_T=''
+HAVE_SIGSET_T=''
+HAVE_SLEEP=''
+HAVE_SNPRINTF=''
+HAVE_STDINT_H=''
+HAVE_STPCPY=''
+HAVE_STPNCPY=''
+HAVE_STRCASECMP=''
+HAVE_STRCASESTR=''
+HAVE_STRCHRNUL=''
+HAVE_STRPBRK=''
+HAVE_STRSEP=''
+HAVE_STRTOD=''
+HAVE_STRTOLL=''
+HAVE_STRTOULL=''
+HAVE_STRUCT_RANDOM_DATA=''
+HAVE_STRUCT_SIGACTION_SA_SIGACTION=''
+HAVE_STRUCT_SOCKADDR_STORAGE=''
+HAVE_STRUCT_TIMEVAL=''
+HAVE_STRVERSCMP=''
+HAVE_SYMLINK=''
+HAVE_SYMLINKAT=''
+HAVE_SYSEXITS_H=''
+HAVE_SYS_BITYPES_H=''
+HAVE_SYS_CDEFS_H=''
+HAVE_SYS_INTTYPES_H=''
+HAVE_SYS_LOADAVG_H=''
+HAVE_SYS_PARAM_H=''
+HAVE_SYS_SELECT_H=''
+HAVE_SYS_SOCKET_H=''
+HAVE_SYS_TIME_H=''
+HAVE_SYS_TYPES_H=''
+HAVE_TYPE_VOLATILE_SIG_ATOMIC_T=''
+HAVE_UNISTD_H=''
+HAVE_UNLINKAT=''
+HAVE_UNSETENV=''
+HAVE_UNSIGNED_LONG_LONG_INT=''
+HAVE_USLEEP=''
+HAVE_UTIMENSAT=''
+HAVE_VASPRINTF=''
+HAVE_VDPRINTF=''
+HAVE_VISIBILITY=''
+HAVE_WCHAR_H=''
+HAVE_WCHAR_T=''
+HAVE_WCRTOMB=''
+HAVE_WCSNRTOMBS=''
+HAVE_WCSRTOMBS=''
+HAVE_WCTYPE_H=''
+HAVE_WINSOCK2_H=''
+HAVE_WINT_T=''
+HAVE_WPRINTF=''
+HAVE_WS2TCPIP_H=''
+HAVE__BOOL=''
+INCLUDE_NEXT=''
+INCLUDE_NEXT_AS_FIRST_DIRECTIVE=''
+INSTALL_DATA='${INSTALL} -m 644'
+INSTALL_PROGRAM='${INSTALL}'
+INSTALL_SCRIPT='${INSTALL}'
+INSTALL_STRIP_PROGRAM='$(install_sh) -c -s'
+INSTOBJEXT=''
+INTLBISON=''
+INTLLIBS=''
+INTLOBJS=''
+INTL_LIBTOOL_SUFFIX_PREFIX=''
+INTL_MACOSX_LIBS=''
+LDFLAGS=''
+LEX='flex'
+LEXLIB=''
+LEX_OUTPUT_ROOT='lex.yy'
+LIBCOMPRESS='-lz '
+LIBGNU_LIBDEPS=''
+LIBGNU_LTLIBDEPS=''
+LIBICONV=''
+LIBINTL=''
+LIBMULTITHREAD=''
+LIBOBJS=''
+LIBPTH=''
+LIBPTH_PREFIX=''
+LIBS='-lfl '
+LIBTHREAD=''
+LINGUAS=''
+LN_S='ln -s'
+LOCALCHARSET_TESTS_ENVIRONMENT=''
+LOCALE_FR=''
+LOCALE_FR_UTF8=''
+LOCALE_JA=''
+LOCALE_ZH_CN=''
+LTLIBC=''
+LTLIBICONV=''
+LTLIBINTL=''
+LTLIBMULTITHREAD=''
+LTLIBOBJS=''
+LTLIBPTH=''
+LTLIBTHREAD=''
+MAKEINFO='${SHELL} /myshare/nexenta/src/2/man-db/man-db-2.5.7/tools/missing --run makeinfo'
+MAN_SUBDIRS=''
+MKDIR_P='/usr/gnu/bin/mkdir -p'
+MSGFMT=''
+MSGFMT_015=''
+MSGMERGE=''
+NEXT_AS_FIRST_DIRECTIVE_DIRENT_H=''
+NEXT_AS_FIRST_DIRECTIVE_ERRNO_H=''
+NEXT_AS_FIRST_DIRECTIVE_FCNTL_H=''
+NEXT_AS_FIRST_DIRECTIVE_FLOAT_H=''
+NEXT_AS_FIRST_DIRECTIVE_GETOPT_H=''
+NEXT_AS_FIRST_DIRECTIVE_SIGNAL_H=''
+NEXT_AS_FIRST_DIRECTIVE_STDARG_H=''
+NEXT_AS_FIRST_DIRECTIVE_STDDEF_H=''
+NEXT_AS_FIRST_DIRECTIVE_STDINT_H=''
+NEXT_AS_FIRST_DIRECTIVE_STDIO_H=''
+NEXT_AS_FIRST_DIRECTIVE_STDLIB_H=''
+NEXT_AS_FIRST_DIRECTIVE_STRINGS_H=''
+NEXT_AS_FIRST_DIRECTIVE_STRING_H=''
+NEXT_AS_FIRST_DIRECTIVE_SYSEXITS_H=''
+NEXT_AS_FIRST_DIRECTIVE_SYS_SELECT_H=''
+NEXT_AS_FIRST_DIRECTIVE_SYS_SOCKET_H=''
+NEXT_AS_FIRST_DIRECTIVE_SYS_STAT_H=''
+NEXT_AS_FIRST_DIRECTIVE_SYS_TIME_H=''
+NEXT_AS_FIRST_DIRECTIVE_TIME_H=''
+NEXT_AS_FIRST_DIRECTIVE_UNISTD_H=''
+NEXT_AS_FIRST_DIRECTIVE_WCHAR_H=''
+NEXT_AS_FIRST_DIRECTIVE_WCTYPE_H=''
+NEXT_DIRENT_H=''
+NEXT_ERRNO_H=''
+NEXT_FCNTL_H=''
+NEXT_FLOAT_H=''
+NEXT_GETOPT_H=''
+NEXT_SIGNAL_H=''
+NEXT_STDARG_H=''
+NEXT_STDDEF_H=''
+NEXT_STDINT_H=''
+NEXT_STDIO_H=''
+NEXT_STDLIB_H=''
+NEXT_STRINGS_H=''
+NEXT_STRING_H=''
+NEXT_SYSEXITS_H=''
+NEXT_SYS_SELECT_H=''
+NEXT_SYS_SOCKET_H=''
+NEXT_SYS_STAT_H=''
+NEXT_SYS_TIME_H=''
+NEXT_TIME_H=''
+NEXT_UNISTD_H=''
+NEXT_WCHAR_H=''
+NEXT_WCTYPE_H=''
+OBJEXT='o'
+PACKAGE='man-db'
+PACKAGE_BUGREPORT='cjwatson@debian.org'
+PACKAGE_NAME='man-db'
+PACKAGE_STRING='man-db 2.5.7'
+PACKAGE_TARNAME='man-db'
+PACKAGE_URL=''
+PACKAGE_VERSION='2.5.7'
+PATH_SEPARATOR=':'
+PO4A=''
+PO4A_FALSE=''
+PO4A_TRUE=''
+POSUB=''
+PRAGMA_SYSTEM_HEADER=''
+PRI_MACROS_BROKEN=''
+PTRDIFF_T_SUFFIX=''
+RANLIB='ranlib'
+REPLACE_BTOWC=''
+REPLACE_CANONICALIZE_FILE_NAME=''
+REPLACE_CHOWN=''
+REPLACE_CLOSE=''
+REPLACE_CLOSEDIR=''
+REPLACE_DPRINTF=''
+REPLACE_DUP2=''
+REPLACE_DUP=''
+REPLACE_FCHDIR=''
+REPLACE_FCHOWNAT=''
+REPLACE_FCLOSE=''
+REPLACE_FCNTL=''
+REPLACE_FDOPENDIR=''
+REPLACE_FFLUSH=''
+REPLACE_FOPEN=''
+REPLACE_FPRINTF=''
+REPLACE_FPURGE=''
+REPLACE_FREOPEN=''
+REPLACE_FSEEK=''
+REPLACE_FSEEKO=''
+REPLACE_FSTAT=''
+REPLACE_FSTATAT=''
+REPLACE_FTELL=''
+REPLACE_FTELLO=''
+REPLACE_FUTIMENS=''
+REPLACE_GETCWD=''
+REPLACE_GETGROUPS=''
+REPLACE_GETLINE=''
+REPLACE_GETPAGESIZE=''
+REPLACE_GETTIMEOFDAY=''
+REPLACE_ISWCNTRL=''
+REPLACE_LCHOWN=''
+REPLACE_LINK=''
+REPLACE_LINKAT=''
+REPLACE_LOCALTIME_R=''
+REPLACE_LSEEK=''
+REPLACE_LSTAT=''
+REPLACE_MBRLEN=''
+REPLACE_MBRTOWC=''
+REPLACE_MBSINIT=''
+REPLACE_MBSNRTOWCS=''
+REPLACE_MBSRTOWCS=''
+REPLACE_MBSTATE_T=''
+REPLACE_MEMCHR=''
+REPLACE_MEMMEM=''
+REPLACE_MKDIR=''
+REPLACE_MKFIFO=''
+REPLACE_MKNOD=''
+REPLACE_MKSTEMP=''
+REPLACE_MKTIME=''
+REPLACE_NANOSLEEP=''
+REPLACE_NULL=''
+REPLACE_OBSTACK_PRINTF=''
+REPLACE_OPEN=''
+REPLACE_OPENAT=''
+REPLACE_OPENDIR=''
+REPLACE_PERROR=''
+REPLACE_POPEN=''
+REPLACE_PREAD=''
+REPLACE_PRINTF=''
+REPLACE_PUTENV=''
+REPLACE_READLINK=''
+REPLACE_REALPATH=''
+REPLACE_REMOVE=''
+REPLACE_RENAME=''
+REPLACE_RENAMEAT=''
+REPLACE_RMDIR=''
+REPLACE_SELECT=''
+REPLACE_SETENV=''
+REPLACE_SLEEP=''
+REPLACE_SNPRINTF=''
+REPLACE_SPRINTF=''
+REPLACE_STAT=''
+REPLACE_STDIO_WRITE_FUNCS=''
+REPLACE_STRCASESTR=''
+REPLACE_STRDUP=''
+REPLACE_STRERROR=''
+REPLACE_STRNDUP=''
+REPLACE_STRPTIME=''
+REPLACE_STRSIGNAL=''
+REPLACE_STRSTR=''
+REPLACE_STRTOD=''
+REPLACE_STRTOK_R=''
+REPLACE_SYMLINK=''
+REPLACE_TIMEGM=''
+REPLACE_UNLINK=''
+REPLACE_UNLINKAT=''
+REPLACE_UNSETENV=''
+REPLACE_USLEEP=''
+REPLACE_UTIMENSAT=''
+REPLACE_VASPRINTF=''
+REPLACE_VDPRINTF=''
+REPLACE_VFPRINTF=''
+REPLACE_VPRINTF=''
+REPLACE_VSNPRINTF=''
+REPLACE_VSPRINTF=''
+REPLACE_WCRTOMB=''
+REPLACE_WCSNRTOMBS=''
+REPLACE_WCSRTOMBS=''
+REPLACE_WCTOB=''
+REPLACE_WCWIDTH=''
+REPLACE_WRITE=''
+SET_MAKE=''
+SHELL='/bin/sh'
+SIG_ATOMIC_T_SUFFIX=''
+SIZE_T_SUFFIX=''
+STDARG_H=''
+STDBOOL_H=''
+STDDEF_H=''
+STDINT_H=''
+STRIP=''
+SYSEXITS_H=''
+SYS_SOCKET_H=''
+SYS_TIME_H=''
+SYS_TIME_H_DEFINES_STRUCT_TIMESPEC=''
+TIME_H_DEFINES_STRUCT_TIMESPEC=''
+TRANS_APROPOS=''
+TRANS_APROPOS_UPPER=''
+TRANS_CATMAN=''
+TRANS_CATMAN_UPPER=''
+TRANS_LEXGROG=''
+TRANS_LEXGROG_UPPER=''
+TRANS_MAN=''
+TRANS_MANCONV=''
+TRANS_MANCONV_UPPER=''
+TRANS_MANDB=''
+TRANS_MANDB_UPPER=''
+TRANS_MANPATH=''
+TRANS_MANPATH_UPPER=''
+TRANS_MAN_UPPER=''
+TRANS_WHATIS=''
+TRANS_WHATIS_UPPER=''
+TRANS_ZSOELIM=''
+TRANS_ZSOELIM_UPPER=''
+TROFF='groff'
+UNDEFINE_STRTOK_R=''
+UNISTD_H_HAVE_WINSOCK2_H=''
+UNISTD_H_HAVE_WINSOCK2_H_AND_USE_SOCKETS=''
+USE_INCLUDED_LIBINTL=''
+USE_NLS=''
+VERSION='2.5.7'
+WCHAR_T_SUFFIX=''
+WCTYPE_H=''
+WINDRES=''
+WINT_T_SUFFIX=''
+WOE32=''
+WOE32DLL=''
+XGETTEXT=''
+XGETTEXT_015=''
+XGETTEXT_EXTRA_OPTIONS=''
+ac_ct_CC='gcc'
+am__EXEEXT_FALSE=''
+am__EXEEXT_TRUE=''
+am__fastdepCC_FALSE=''
+am__fastdepCC_TRUE='#'
+am__include='include'
+am__isrc=''
+am__leading_dot='.'
+am__quote=''
+am__tar='${AMTAR} chof - "$$tardir"'
+am__untar='${AMTAR} xf -'
+bindir='${exec_prefix}/bin'
+browser='exec www-browser'
+build='i386-pc-solaris2.11'
+build_alias='i386-pc-solaris2.11'
+build_cpu='i386'
+build_os='solaris2.11'
+build_vendor='pc'
+bunzip2='bzip2 -dc'
+bzip2='bzip2'
+cat='cat'
+col='col'
+compress='compress'
+compress_ext='gz'
+compressor='gzip -c7'
+config_file='/etc/manpath.config'
+config_file_basename='manpath.config'
+config_file_dirname='/etc'
+datadir='${datarootdir}'
+datarootdir='${prefix}/share'
+date='2010-02-16'
+docdir='${datarootdir}/doc/${PACKAGE_TARNAME}'
+dvidir='${docdir}'
+eqn='eqn'
+exec_prefix='NONE'
+gl_LIBOBJS=''
+gl_LTLIBOBJS=''
+gltests_LIBOBJS=''
+gltests_LTLIBOBJS=''
+grap='grap'
+grep='grep'
+gunzip='gzip -dc'
+gzip='gzip'
+host='i386-pc-solaris2.11'
+host_alias=''
+host_cpu='i386'
+host_os='solaris2.11'
+host_vendor='pc'
+htmldir='${docdir}'
+includedir='${prefix}/include'
+infodir='${prefix}/share/info'
+install_sh='${SHELL} /myshare/nexenta/src/2/man-db/man-db-2.5.7/tools/install-sh'
+libdir='${exec_prefix}/lib'
+libexecdir='${libdir}'
+localedir='${datarootdir}/locale'
+localstatedir='/var'
+lzma='lzma'
+man_mode='4755'
+man_owner='man'
+mandir='${prefix}/share/man'
+mkdir_p='/usr/gnu/bin/mkdir -p'
+neqn='neqn'
+nroff='nroff -mandoc'
+oldincludedir='/usr/include'
+pager='pager -s'
+pdfdir='${docdir}'
+pic='pic -S'
+preconv='preconv'
+prefix='/usr'
+program_transform_name='s,x,x,'
+psdir='${docdir}'
+refer='refer'
+roff_version='2.5.7'
+sbindir='${exec_prefix}/sbin'
+sections='1 n l 8 3 2 3posix 3pm 3perl 5 4 9 6 7'
+sharedstatedir='${prefix}/com'
+sysconfdir='/etc'
+target_alias=''
+tbl='tbl'
+tr='tr'
+troff='groff -mandoc'
+uncompress='compress -dc'
+unlzma='lzma -dc'
+vgrind='vgrind'
+
+## ----------- ##
+## confdefs.h. ##
+## ----------- ##
+
+/* confdefs.h */
+#define PACKAGE_NAME "man-db"
+#define PACKAGE_TARNAME "man-db"
+#define PACKAGE_VERSION "2.5.7"
+#define PACKAGE_STRING "man-db 2.5.7"
+#define PACKAGE_BUGREPORT "cjwatson@debian.org"
+#define PACKAGE_URL ""
+#define PACKAGE "man-db"
+#define VERSION "2.5.7"
+#define SECURE_MAN_UID "man"
+#define UNDOC_COMMAND "man 7 undocumented"
+#define MAN_DB_UPDATES 1
+#define MAN_CATS 1
+#define STDC_HEADERS 1
+#define HAVE_SYS_TYPES_H 1
+#define HAVE_SYS_STAT_H 1
+#define HAVE_STDLIB_H 1
+#define HAVE_STRING_H 1
+#define HAVE_MEMORY_H 1
+#define HAVE_STRINGS_H 1
+#define HAVE_INTTYPES_H 1
+#define HAVE_STDINT_H 1
+#define HAVE_UNISTD_H 1
+#define __EXTENSIONS__ 1
+#define _ALL_SOURCE 1
+#define _GNU_SOURCE 1
+#define _POSIX_PTHREAD_SEMANTICS 1
+#define _TANDEM_SOURCE 1
+#define HAVE_BROWSER 1
+#define HAVE_PAGER 1
+#define HAVE_NROFF 1
+#define GNU_NROFF 1
+#define TROFF_IS_GROFF 1
+#define HAS_TROFF 1
+#define MULTIBYTE_GROFF 1
+#define HAVE_EQN 1
+#define HAVE_NEQN 1
+#define HAVE_TBL 1
+#define HAVE_COL 1
+#define HAVE_VGRIND 1
+#define HAVE_REFER 1
+#define HAVE_GRAP 1
+#define HAVE_PIC 1
+#define HAVE_GZIP 1
+#define HAVE_COMPRESS 1
+#define HAVE_BZIP2 1
+#define HAVE_LZMA 1
+#define COMP_CAT 1
+#define COMP_SRC 1
+#define HAVE_LIBZ 1
+#define MANDIR_LAYOUT "Solaris"
+
+configure: caught signal 2
+configure: exit 1
