--- apt-0.8.10.3+squeeze1.orig/apt-pkg/contrib/strutl.cc
+++ apt-0.8.10.3+squeeze1/apt-pkg/contrib/strutl.cc
@@ -69,7 +69,7 @@
   {
      char *outptr = outbuf;
      size_t outsize = bufsize;
-     size_t const err = iconv(cd, &inptr, &insize, &outptr, &outsize);
+     size_t const err = iconv(cd, (const char**)&inptr, &insize, &outptr, &outsize);
      dest->append(outbuf, outptr - outbuf);
      if (err == (size_t)(-1))
      {
--- apt-0.8.10.3+squeeze1.orig/apt-pkg/deb/cfmakeraw.h
+++ apt-0.8.10.3+squeeze1/apt-pkg/deb/cfmakeraw.h
@@ -0,0 +1,11 @@
+
+void cfmakeraw(struct termios *t) {
+  if (t != NULL) {
+    t->c_iflag &= ~(IMAXBEL|IGNBRK|BRKINT|PARMRK|ISTRIP|INLCR|IGNCR|ICRNL|IXON);
+    t->c_oflag &= ~OPOST;
+    t->c_lflag &= ~(ECHO|ECHONL|ICANON|ISIG|IEXTEN);
+    t->c_cflag &= ~(CSIZE|PARENB);
+    t->c_cflag |= CS8;
+  }
+}
+
--- apt-0.8.10.3+squeeze1.orig/apt-pkg/deb/dpkgpm.cc
+++ apt-0.8.10.3+squeeze1/apt-pkg/deb/dpkgpm.cc
@@ -36,7 +36,14 @@
 #include <termios.h>
 #include <unistd.h>
 #include <sys/ioctl.h>
+#ifdef __sun
+#include "memrchr.h"
+#include "cfmakeraw.h"
+#include "openpty.h"
+typedef void (*sighandler_t) (int);
+#else
 #include <pty.h>
+#endif
 
 #include <config.h>
 #include <apti18n.h>
@@ -614,7 +621,8 @@
 
    // now move the unprocessed bits (after the final \n that is now a 0x0) 
    // to the start and update dpkgbuf_pos
-   p = (char*)memrchr(dpkgbuf, 0, dpkgbuf_pos);
+//   p = (char*)memrchr(dpkgbuf, 0, dpkgbuf_pos);
+   p = (char*)memchr(dpkgbuf, 0, dpkgbuf_pos);
    if(p == NULL)
       return;
 
@@ -1021,7 +1029,8 @@
       /* Mask off sig int/quit. We do this because dpkg also does when 
          it forks scripts. What happens is that when you hit ctrl-c it sends
 	 it to all processes in the group. Since dpkg ignores the signal 
-	 it doesn't die but we do! So we must also ignore it */
+	 it doesn
+	 't die but we do! So we must also ignore it */
       sighandler_t old_SIGQUIT = signal(SIGQUIT,SIG_IGN);
       sighandler_t old_SIGINT = signal(SIGINT,SIG_IGN);
 
--- apt-0.8.10.3+squeeze1.orig/apt-pkg/deb/memrchr.h
+++ apt-0.8.10.3+squeeze1/apt-pkg/deb/memrchr.h
@@ -0,0 +1,161 @@
+/* memrchr -- find the last occurrence of a byte in a memory block
+
+   Copyright (C) 1991, 1993, 1996-1997, 1999-2000, 2003-2010 Free Software
+   Foundation, Inc.
+
+   Based on strlen implementation by Torbjorn Granlund (tege@sics.se),
+   with help from Dan Sahlin (dan@sics.se) and
+   commentary by Jim Blandy (jimb@ai.mit.edu);
+   adaptation to memchr suggested by Dick Karpinski (dick@cca.ucsf.edu),
+   and implemented by Roland McGrath (roland@ai.mit.edu).
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#if defined _LIBC
+# include <memcopy.h>
+#else
+# include <config.h>
+# define reg_char char
+#endif
+
+#include <string.h>
+#include <limits.h>
+
+#undef __memrchr
+#ifdef _LIBC
+# undef memrchr
+#endif
+
+#ifndef weak_alias
+# define __memrchr memrchr
+#endif
+
+/* Search no more than N bytes of S for C.  */
+void *
+__memrchr (void const *s, int c_in, size_t n)
+{
+  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned
+     long instead of a 64-bit uintmax_t tends to give better
+     performance.  On 64-bit hardware, unsigned long is generally 64
+     bits already.  Change this typedef to experiment with
+     performance.  */
+  typedef unsigned long int longword;
+
+  const unsigned char *char_ptr;
+  const longword *longword_ptr;
+  longword repeated_one;
+  longword repeated_c;
+  unsigned reg_char c;
+
+  c = (unsigned char) c_in;
+
+  /* Handle the last few bytes by reading one byte at a time.
+     Do this until CHAR_PTR is aligned on a longword boundary.  */
+  for (char_ptr = (const unsigned char *) s + n;
+       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;
+       --n)
+    if (*--char_ptr == c)
+      return (void *) char_ptr;
+
+  longword_ptr = (const longword *) char_ptr;
+
+  /* All these elucidatory comments refer to 4-byte longwords,
+     but the theory applies equally well to any size longwords.  */
+
+  /* Compute auxiliary longword values:
+     repeated_one is a value which has a 1 in every byte.
+     repeated_c has c in every byte.  */
+  repeated_one = 0x01010101;
+  repeated_c = c | (c << 8);
+  repeated_c |= repeated_c << 16;
+  if (0xffffffffU < (longword) -1)
+    {
+      repeated_one |= repeated_one << 31 << 1;
+      repeated_c |= repeated_c << 31 << 1;
+      if (8 < sizeof (longword))
+        {
+          size_t i;
+
+          for (i = 64; i < sizeof (longword) * 8; i *= 2)
+            {
+              repeated_one |= repeated_one << i;
+              repeated_c |= repeated_c << i;
+            }
+        }
+    }
+
+  /* Instead of the traditional loop which tests each byte, we will test a
+     longword at a time.  The tricky part is testing if *any of the four*
+     bytes in the longword in question are equal to c.  We first use an xor
+     with repeated_c.  This reduces the task to testing whether *any of the
+     four* bytes in longword1 is zero.
+
+     We compute tmp =
+       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).
+     That is, we perform the following operations:
+       1. Subtract repeated_one.
+       2. & ~longword1.
+       3. & a mask consisting of 0x80 in every byte.
+     Consider what happens in each byte:
+       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,
+         and step 3 transforms it into 0x80.  A carry can also be propagated
+         to more significant bytes.
+       - If a byte of longword1 is nonzero, let its lowest 1 bit be at
+         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,
+         the byte ends in a single bit of value 0 and k bits of value 1.
+         After step 2, the result is just k bits of value 1: 2^k - 1.  After
+         step 3, the result is 0.  And no carry is produced.
+     So, if longword1 has only non-zero bytes, tmp is zero.
+     Whereas if longword1 has a zero byte, call j the position of the least
+     significant zero byte.  Then the result has a zero at positions 0, ...,
+     j-1 and a 0x80 at position j.  We cannot predict the result at the more
+     significant bytes (positions j+1..3), but it does not matter since we
+     already have a non-zero bit at position 8*j+7.
+
+     So, the test whether any byte in longword1 is zero is equivalent to
+     testing whether tmp is nonzero.  */
+
+  while (n >= sizeof (longword))
+    {
+      longword longword1 = *--longword_ptr ^ repeated_c;
+
+      if ((((longword1 - repeated_one) & ~longword1)
+           & (repeated_one << 7)) != 0)
+        {
+          longword_ptr++;
+          break;
+        }
+      n -= sizeof (longword);
+    }
+
+  char_ptr = (const unsigned char *) longword_ptr;
+
+  /* At this point, we know that either n < sizeof (longword), or one of the
+     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian
+     machines, we could determine the first such byte without any further
+     memory accesses, just by looking at the tmp result from the last loop
+     iteration.  But this does not work on big-endian machines.  Choose code
+     that works in both cases.  */
+
+  while (n-- > 0)
+    {
+      if (*--char_ptr == c)
+        return (void *) char_ptr;
+    }
+
+  return NULL;
+}
+#ifdef weak_alias
+weak_alias (__memrchr, memrchr)
+#endif
--- apt-0.8.10.3+squeeze1.orig/apt-pkg/deb/openpty.h
+++ apt-0.8.10.3+squeeze1/apt-pkg/deb/openpty.h
@@ -0,0 +1,155 @@
+/* Open a pseudo-terminal.
+   Copyright (C) 2010 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#include <config.h>
+
+/* Specification.  */
+#ifndef __sun
+#include <pty.h>
+#endif
+
+#if HAVE_OPENPTY
+
+/* Provide a wrapper with the prototype of glibc-2.8 and newer.  */
+# undef openpty
+int
+rpl_openpty (int *amaster, int *aslave, char *name,
+             struct termios const *termp, struct winsize const *winp)
+{
+  /* Cast away const, for implementations with weaker prototypes.  */
+  return openpty (amaster, aslave, name, (struct termios *) termp,
+                  (struct winsize *) winp);
+}
+
+#else /* AIX 5.1, HP-UX 11, IRIX 6.5, Solaris 10, mingw */
+
+# include <fcntl.h>
+# include <string.h>
+# include <sys/ioctl.h>
+# include <termios.h>
+# include <unistd.h>
+# if defined __sun || defined __hpux /* Solaris, HP-UX */
+#  include <stropts.h>
+# endif
+
+int
+openpty (int *amaster, int *aslave, char *name,
+         struct termios const *termp, struct winsize const *winp)
+{
+  int master;
+  char *slave_name;
+  int slave;
+
+# if HAVE__GETPTY /* IRIX */
+
+  slave_name = _getpty (&master, O_RDWR, 0622, 0);
+  if (slave_name == NULL)
+    return -1;
+
+# else /* AIX 5.1, HP-UX 11, Solaris 10, mingw */
+
+#  if HAVE_POSIX_OPENPT /* Solaris 10 */
+
+  master = posix_openpt (O_RDWR | O_NOCTTY);
+  if (master < 0)
+    return -1;
+
+#  else /* AIX 5.1, HP-UX 11, Solaris 9, mingw */
+
+#   ifdef _AIX /* AIX */
+
+  master = open ("/dev/ptc", O_RDWR | O_NOCTTY);
+  if (master < 0)
+    return -1;
+
+#   else /* HP-UX 11, Solaris 9, mingw */
+
+  /* HP-UX, Solaris have /dev/ptmx.
+     HP-UX also has /dev/ptym/clone, but this should not be needed.
+     Linux also has /dev/ptmx, but Linux already has openpty().
+     MacOS X also has /dev/ptmx, but MacOS X already has openpty().
+     OSF/1 also has /dev/ptmx and /dev/ptmx_bsd, but OSF/1 already has
+     openpty().  */
+  master = open ("/dev/ptmx", O_RDWR | O_NOCTTY);
+  if (master < 0)
+    return -1;
+
+#   endif
+
+#  endif
+
+  /* If all this does not work, we could try to open, one by one:
+     - On MacOS X: /dev/pty[p-w][0-9a-f]
+     - On *BSD:    /dev/pty[p-sP-S][0-9a-v]
+     - On AIX:     /dev/ptyp[0-9a-f]
+     - On HP-UX:   /dev/pty[p-r][0-9a-f]
+     - On OSF/1:   /dev/pty[p-q][0-9a-f]
+     - On Solaris: /dev/pty[p-r][0-9a-f]
+   */
+# endif
+
+  /* This call does not require a dependency to the 'grantpt' module,
+     because AIX, HP-UX, IRIX, Solaris all have the grantpt() function.  */
+  if (grantpt (master))
+    goto fail;
+
+  /* This call does not require a dependency to the 'unlockpt' module,
+     because AIX, HP-UX, IRIX, Solaris all have the unlockpt() function.  */
+  if (unlockpt (master))
+    goto fail;
+
+# if !HAVE__GETPTY /* !IRIX */
+  slave_name = ptsname (master);
+  if (slave_name == NULL)
+    goto fail;
+# endif
+
+  slave = open (slave_name, O_RDWR | O_NOCTTY);
+  if (slave == -1)
+    goto fail;
+
+# if defined __sun || defined __hpux /* Solaris, HP-UX */
+  if (ioctl (slave, I_PUSH, "ptem") < 0
+      || ioctl (slave, I_PUSH, "ldterm") < 0
+#  if defined __sun
+      || ioctl (slave, I_PUSH, "ttcompat") < 0
+#  endif
+     )
+    {
+      close (slave);
+      goto fail;
+    }
+# endif
+
+  /* XXX Should we ignore errors here?  */
+  if (termp)
+    tcsetattr (slave, TCSAFLUSH, termp);
+  if (winp)
+    ioctl (slave, TIOCSWINSZ, winp);
+
+  *amaster = master;
+  *aslave = slave;
+  if (name != NULL)
+    strcpy (name, slave_name);
+
+  return 0;
+
+ fail:
+  close (master);
+  return -1;
+}
+
+#endif
--- apt-0.8.10.3+squeeze1.orig/apt-pkg/makefile
+++ apt-0.8.10.3+squeeze1/apt-pkg/makefile
@@ -14,7 +14,8 @@
 LIBRARY=apt-pkg
 MAJOR=$(LIBAPTPKG_MAJOR)
 MINOR=$(LIBAPTPKG_RELEASE)
-SLIBS=$(PTHREADLIB) $(INTLLIBS) -lutil -ldl -lz
+LIBSTDCPP=$(shell g++ -print-file-name=libstdc++.a)
+SLIBS=$(PTHREADLIB) $(INTLLIBS) -ldl -lz ${LIBSTDCPP}
 APT_DOMAIN:=libapt-pkg$(LIBAPTPKG_MAJOR)
 
 # Source code for the contributed non-core things

--- apt-0.8.10.3+squeeze1.orig/buildlib/environment.mak.in
+++ apt-0.8.10.3+squeeze1/buildlib/environment.mak.in
@@ -37,8 +37,8 @@
 # Gettext settings
 GMSGFMT = @GMSGFMT@
 XGETTEXT = @XGETTEXT@
-MSGCOMM:=$(dir $(XGETTEXT))/msgcomm
-MSGMERGE:=$(dir $(XGETTEXT))/msgmerge
+MSGCOMM:= /usr/bin/msgcomm
+MSGMERGE:= /usr/bin/msgmerge
 BASH = @BASH@
 
 # Various library checks
@@ -59,7 +59,7 @@
 
 # Shared library things
 HOST_OS = @host_os@
-ifneq ($(words $(filter gnu% linux-gnu% kfreebsd-gnu% %-gnu,$(HOST_OS))),0)
+ifneq ($(words $(filter gnu% linux-gnu% kfreebsd-gnu% %-gnu solaris2%,$(HOST_OS))),0)
    SONAME_MAGIC=-Wl,-soname -Wl,
    LFLAGS_SO=
 else
--- apt-0.8.10.3+squeeze1.orig/cmdline/apt-get.cc
+++ apt-0.8.10.3+squeeze1/cmdline/apt-get.cc
@@ -25,8 +25,8 @@
    ##################################################################### */
 									/*}}}*/
 // Include Files							/*{{{*/
-#define _LARGEFILE_SOURCE
-#define _LARGEFILE64_SOURCE
+//#define _LARGEFILE_SOURCE
+//#define _LARGEFILE64_SOURCE
 
 #include <apt-pkg/aptconfiguration.h>
 #include <apt-pkg/error.h>
@@ -68,7 +68,11 @@
 #include <sys/wait.h>
 #include <sstream>
 
+#ifdef __sun
+#define statfs statvfs64
+#else
 #define statfs statfs64
+#endif
 #define statvfs statvfs64
 									/*}}}*/
 
--- apt-0.8.10.3+squeeze1.orig/cmdline/apt-key
+++ apt-0.8.10.3+squeeze1/cmdline/apt-key
@@ -13,8 +13,8 @@
 #MASTER_KEYRING=/usr/share/keyrings/debian-master-keyring.gpg
 #ARCHIVE_KEYRING_URI=http://ftp.debian.org/debian/debian-archive-keyring.gpg
 
-ARCHIVE_KEYRING=/usr/share/keyrings/debian-archive-keyring.gpg
-REMOVED_KEYS=/usr/share/keyrings/debian-archive-removed-keys.gpg
+ARCHIVE_KEYRING=/usr/share/keyrings/nexenta-archive-keyring.gpg
+REMOVED_KEYS=/usr/share/keyrings/nexenta-archive-removed-keys.gpg
 
 add_keys_with_verify_against_master_keyring() {
     ADD_KEYRING=$1
--- apt-0.8.10.3+squeeze1.orig/cmdline/makefile
+++ apt-0.8.10.3+squeeze1/cmdline/makefile
@@ -14,7 +14,7 @@
 
 # The apt-get program
 PROGRAM=apt-get
-SLIBS = -lapt-pkg -lutil $(INTLLIBS)
+SLIBS = -lapt-pkg $(INTLLIBS)
 LIB_MAKES = apt-pkg/makefile
 SOURCE = apt-get.cc acqprogress.cc
 include $(PROGRAM_H)
--- apt-0.8.10.3+squeeze1.orig/doc/apt-clone.8.xml
+++ apt-0.8.10.3+squeeze1/doc/apt-clone.8.xml
@@ -0,0 +1,185 @@
+<?xml version="1.0" encoding="utf-8" standalone="no"?>
+<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
+  "http://www.oasis-open.org/docbook/xml/4.2/docbookx.dtd" [
+
+<!ENTITY % aptent SYSTEM "apt.ent">
+%aptent;
+
+<!ENTITY % aptverbatiment SYSTEM "apt-verbatim.ent">
+%aptverbatiment;
+
+]>
+
+<refentry>
+
+ <refentryinfo>
+   &apt-author.jgunthorpe;
+   &apt-author.team;
+   &apt-email;
+   &apt-product;
+   <!-- The last update date -->
+   <date>3 January 2008</date>
+ </refentryinfo>
+ 
+ <refmeta>
+   <refentrytitle>apt-clone</refentrytitle>
+   <manvolnum>8</manvolnum>
+    <refmiscinfo class="manual">APT</refmiscinfo>    
+ </refmeta>
+ 
+ <!-- Man page title -->
+ <refnamediv>
+    <refname>apt-clone</refname>
+    <refpurpose>ZFS integrated APT package handling utility -- command-line interface</refpurpose>
+ </refnamediv>
+
+ <!-- Arguments -->
+ <refsynopsisdiv>
+   <cmdsynopsis>
+      <command>apt-clone</command>
+      <arg><option>-hltsyv</option></arg>
+      <arg><option>-a=<replaceable>clone-name</replaceable></option></arg>
+      <arg><option>-r=<replaceable>clone-name</replaceable></option></arg>
+      <arg><option>-b=<replaceable>bootmenu-count</replaceable></option></arg>
+      <arg><option>-k=<replaceable>clone-count</replaceable></option></arg>
+      <arg><option>-x=<replaceable>http-proxy</replaceable></option></arg>
+      <arg><option>apt-cmd</option></arg>
+      <arg choice="plain" rep="repeat"><replaceable>pkg1 pkg2</replaceable></arg>
+   </cmdsynopsis>
+ </refsynopsisdiv>
+ 
+ <refsect1><title>Description</title>
+   <para><command>apt-clone</command> is the command-line tool for handling packages, and may be 
+   considered the user's "front-end" to the &apt-get;. It manages GRUB menu and ZFS 'syspool' filesystems. Two
+   upgrade methods supported: 1) safe upgrades via cloning a currently active filesystem and later chrooting into it to
+   perform actual upgrade operation; 2) in-place (live) upgrades by checkpointing a currently active filesystem prior to
+   any upgrade modifications done by apt-get utility. The live upgrading, as the name implies, happens in-place on
+   the running system, and without reboot. Unless the safe <option>-s</option> option is explicitly specified,
+   the system will automatically detect whether the upgrade will require reboot, and if so, it will clone the
+   active filesystem and safely perform the software upgrade within this ZFS clone. A user then has two
+   options: reboot into the new (upgraded) system folder or continue working (and possibly activate
+   the upgrade and reboot into it later).
+   </para>
+
+   <para>Nexenta clone name format is 'syspool/rootfs-nmu-###', where ### is zeroes started decimal number
+   (i.e. 'slot') precaculated during upgrade.</para>
+
+   <para>Safe upgrade is done in specially prepared chroot environment and do not disturbs running services. Upgrade checkpointing is ZFS clone created prior to upgrade modifications to the active root filesystem.</para>
+
+   <para>The default behavior (i.e. when no command line options given) of apt-clone utility is this:
+   1) detect set of packages which needs to be upgraded;
+   2) verify if &dpkg; or &apt-get; needs to be upgraded, and upgrade them unconditionally;
+   3) calculate free space which is required by the upgrade and compare with what is available in ZFS pool named 'syspool';
+   4) verify if at least one of the core packages (i.e. 'sunwcakr', 'sunwkvm', 'sunwcsr', 'sunwckr', 'sunwcnetr', 'sunwcsu', 'sunwcsd' or 'sunwcsl') requires upgrade, and if so, than enable safe upgrade option by using specially prepared chroot environment. See <option>-s</option> option for details;
+   5) if no core packages requires upgrade, do upgrade checkpointing which is simply ZFS clone created prior to upgrade modifications done by &apt-get; utility;
+   6) run &apt-get; for all or only provided set of packages.</para>
+
+   <para>If the <option>-h</option>, or <option>--help</option> option is given, other options
+   will be disregarded.</para>
+ </refsect1>
+ 
+ <refsect1><title>options</title>
+
+   <variablelist>
+     <varlistentry><term><option>apt-cmd</option></term>
+     <listitem><para>One of the apt-get commands: upgrade, dist-upgrade, install, remove or autoremove
+     </para></listitem>
+     </varlistentry>
+
+     <varlistentry><term><option>-l</option></term>
+     <listitem><para>List upgraded clones; ZFS clones for system pool 'syspool' as
+     they listed in GRUB menu.</para></listitem>
+     </varlistentry>
+
+     <varlistentry><term><option>-i</option></term>
+     <listitem><para>Initiate application rollback checkpoint; ZFS clone which could be used to
+     rollback folowing modifications made by human or application.</para></listitem>
+     </varlistentry>
+
+     <varlistentry><term><option>-a clone-name</option></term>
+     <listitem><para>Activate given ZFS clone name; GRUB menu default will set to
+     given clone name.</para></listitem>
+     </varlistentry>
+
+     <varlistentry><term><option>-r clone-name</option></term>
+     <listitem><para>Rollback/Destroy upgrade changes for ZFS clone name; only non-active and non-default ZFS clone
+     could be rolled back. Upgrade rollback means destroy of clone which is no longer in use, such as failed upgrade or
+     custom checkpoint.</para></listitem>
+     </varlistentry>
+
+     <varlistentry><term><option>-b bootmenu-count</option></term>
+     <listitem><para>Maximum number of GRUB's boot menu entries to keep; retention policy, default is 16.</para></listitem>
+     </varlistentry>
+
+     <varlistentry><term><option>-k clone-count</option></term>
+     <listitem><para>Maximum number of cloned ZFS root filesystems to keep; retention policy, default is 32.</para></listitem>
+     </varlistentry>
+
+     <varlistentry><term><option>-x http-proxy</option></term>
+     <listitem><para>Remote repository HTTP proxy server; See &apt-get; for more details.</para></listitem>
+     </varlistentry>
+
+     <varlistentry><term><option>-t</option></term>
+     <listitem><para>Dry-run. Perform simulated upgrade; do not change data on system volume. Upgrade
+     checkpoint will not be created.</para></listitem>
+     </varlistentry>
+
+     <varlistentry><term><option>-s</option></term>
+     <listitem><para>Safe upgrade in cloned ZFS root filesystem; using chroot environment, do not disturbs currently
+     running system and services, requires reboot, could be used to force upgrade in chroot environment
+     for normal (i.e. non-core) packages. The default behavior is to create checkpoint for non-core packages or use
+     safe upgrade option for core packages. It is not possible to disable safe upgrade if one of core packages
+     detected in calculated dependencies.</para></listitem>
+     </varlistentry>
+
+     <varlistentry><term><option>-y</option></term>
+     <listitem><para>Do not ask any questions, assume Yes to all questions.</para></listitem>
+     </varlistentry>
+
+     <varlistentry><term><option>-v</option></term>
+     <listitem><para>Verbose output.</para></listitem>
+     </varlistentry>
+
+     <varlistentry><term><option>-h</option></term>
+     <listitem><para>Show a short usage summary.</para></listitem>
+     </varlistentry>
+     
+   </variablelist>
+ </refsect1>
+
+ <refsect1><title>Files</title>
+   <variablelist>
+     <varlistentry><term><filename>/etc/apt/sources.list</filename></term>
+     <listitem><para>Locations to fetch packages from.</para></listitem>
+     </varlistentry>
+     
+     <varlistentry><term><filename>/boot/grub/menu.lst</filename></term>
+     <listitem><para>GRUB configuration file.</para></listitem>
+     </varlistentry>
+   </variablelist>
+ </refsect1>
+
+ <refsect1><title>See Also</title>
+   <para>&apt-get;, &apt-cache;, &apt-cdrom;, &dpkg;, &dselect;, &sources-list;,
+   &apt-conf;, &apt-config;, &apt-secure;, 
+   The APT User's guide in &guidesdir;, &apt-preferences;, the APT Howto.</para>
+ </refsect1>
+
+ <refsect1><title>Diagnostics</title>
+   <para><command>apt-clone</command> returns '0' on normal operation, decimal '1' on error.</para>
+ </refsect1>
+
+ <refsect1><title>Bugs</title>
+   <para><ulink url='https://bugs.launchpad.net/~nexenta'>Nexenta bug page</ulink>. 
+   </para>
+ </refsect1>
+
+ <refsect1><title>Author</title>
+   <para>APT was written by the APT team <email>apt@packages.debian.org</email>.
+   apt-clone utility written and maintained by Nexenta team <email>nexenta-devel@nexenta.org</email>.
+   </para>
+ </refsect1>
+
+    &manbugs;
+     
+</refentry>
--- apt-0.8.10.3+squeeze1.orig/doc/apt-verbatim.ent
+++ apt-0.8.10.3+squeeze1/doc/apt-verbatim.ent
@@ -33,6 +33,12 @@
   </citerefentry>"
 >
 
+<!ENTITY apt-clone "<citerefentry>
+    <refentrytitle><command>apt-clone</command></refentrytitle>
+    <manvolnum>8</manvolnum>
+  </citerefentry>"
+>
+
 <!ENTITY apt-cache "<citerefentry>
     <refentrytitle><command>apt-cache</command></refentrytitle>
     <manvolnum>8</manvolnum>
--- apt-0.8.10.3+squeeze1.orig/doc/po4a.conf
+++ apt-0.8.10.3+squeeze1/doc/po4a.conf
@@ -9,6 +9,7 @@
 [type: entity]  apt.ent $lang:$lang/apt.ent
 [type: docbook] apt-cache.8.xml $lang:$lang/apt-cache.$lang.8.xml add_$lang:xml.add
 [type: docbook] apt-cdrom.8.xml $lang:$lang/apt-cdrom.$lang.8.xml add_$lang:xml.add
+[type: docbook] apt-clone.8.xml $lang:$lang/apt-clone.$lang.8.xml add_$lang:xml.add
 [type: docbook] apt-config.8.xml $lang:$lang/apt-config.$lang.8.xml add_$lang:xml.add
 [type: docbook] apt-extracttemplates.1.xml $lang:$lang/apt-extracttemplates.$lang.1.xml add_$lang:xml.add
 [type: docbook] apt-ftparchive.1.xml $lang:$lang/apt-ftparchive.$lang.1.xml add_$lang:xml.add
--- apt-0.8.10.3+squeeze1.orig/ftparchive/cachedb.cc
+++ apt-0.8.10.3+squeeze1/ftparchive/cachedb.cc
@@ -19,7 +19,11 @@
 #include <apt-pkg/sha256.h>
 #include <apt-pkg/strutl.h>
 #include <apt-pkg/configuration.h>
-    
+
+#ifdef __sun
+#include "memrchr.h"
+#endif
+
 #include <netinet/in.h>       // htonl, etc
 									/*}}}*/
 
--- apt-0.8.10.3+squeeze1.orig/ftparchive/memrchr.h
+++ apt-0.8.10.3+squeeze1/ftparchive/memrchr.h
@@ -0,0 +1,161 @@
+/* memrchr -- find the last occurrence of a byte in a memory block
+
+   Copyright (C) 1991, 1993, 1996-1997, 1999-2000, 2003-2010 Free Software
+   Foundation, Inc.
+
+   Based on strlen implementation by Torbjorn Granlund (tege@sics.se),
+   with help from Dan Sahlin (dan@sics.se) and
+   commentary by Jim Blandy (jimb@ai.mit.edu);
+   adaptation to memchr suggested by Dick Karpinski (dick@cca.ucsf.edu),
+   and implemented by Roland McGrath (roland@ai.mit.edu).
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#if defined _LIBC
+# include <memcopy.h>
+#else
+# include <config.h>
+# define reg_char char
+#endif
+
+#include <string.h>
+#include <limits.h>
+
+#undef __memrchr
+#ifdef _LIBC
+# undef memrchr
+#endif
+
+#ifndef weak_alias
+# define __memrchr memrchr
+#endif
+
+/* Search no more than N bytes of S for C.  */
+void *
+__memrchr (void const *s, int c_in, size_t n)
+{
+  /* On 32-bit hardware, choosing longword to be a 32-bit unsigned
+     long instead of a 64-bit uintmax_t tends to give better
+     performance.  On 64-bit hardware, unsigned long is generally 64
+     bits already.  Change this typedef to experiment with
+     performance.  */
+  typedef unsigned long int longword;
+
+  const unsigned char *char_ptr;
+  const longword *longword_ptr;
+  longword repeated_one;
+  longword repeated_c;
+  unsigned reg_char c;
+
+  c = (unsigned char) c_in;
+
+  /* Handle the last few bytes by reading one byte at a time.
+     Do this until CHAR_PTR is aligned on a longword boundary.  */
+  for (char_ptr = (const unsigned char *) s + n;
+       n > 0 && (size_t) char_ptr % sizeof (longword) != 0;
+       --n)
+    if (*--char_ptr == c)
+      return (void *) char_ptr;
+
+  longword_ptr = (const longword *) char_ptr;
+
+  /* All these elucidatory comments refer to 4-byte longwords,
+     but the theory applies equally well to any size longwords.  */
+
+  /* Compute auxiliary longword values:
+     repeated_one is a value which has a 1 in every byte.
+     repeated_c has c in every byte.  */
+  repeated_one = 0x01010101;
+  repeated_c = c | (c << 8);
+  repeated_c |= repeated_c << 16;
+  if (0xffffffffU < (longword) -1)
+    {
+      repeated_one |= repeated_one << 31 << 1;
+      repeated_c |= repeated_c << 31 << 1;
+      if (8 < sizeof (longword))
+        {
+          size_t i;
+
+          for (i = 64; i < sizeof (longword) * 8; i *= 2)
+            {
+              repeated_one |= repeated_one << i;
+              repeated_c |= repeated_c << i;
+            }
+        }
+    }
+
+  /* Instead of the traditional loop which tests each byte, we will test a
+     longword at a time.  The tricky part is testing if *any of the four*
+     bytes in the longword in question are equal to c.  We first use an xor
+     with repeated_c.  This reduces the task to testing whether *any of the
+     four* bytes in longword1 is zero.
+
+     We compute tmp =
+       ((longword1 - repeated_one) & ~longword1) & (repeated_one << 7).
+     That is, we perform the following operations:
+       1. Subtract repeated_one.
+       2. & ~longword1.
+       3. & a mask consisting of 0x80 in every byte.
+     Consider what happens in each byte:
+       - If a byte of longword1 is zero, step 1 and 2 transform it into 0xff,
+         and step 3 transforms it into 0x80.  A carry can also be propagated
+         to more significant bytes.
+       - If a byte of longword1 is nonzero, let its lowest 1 bit be at
+         position k (0 <= k <= 7); so the lowest k bits are 0.  After step 1,
+         the byte ends in a single bit of value 0 and k bits of value 1.
+         After step 2, the result is just k bits of value 1: 2^k - 1.  After
+         step 3, the result is 0.  And no carry is produced.
+     So, if longword1 has only non-zero bytes, tmp is zero.
+     Whereas if longword1 has a zero byte, call j the position of the least
+     significant zero byte.  Then the result has a zero at positions 0, ...,
+     j-1 and a 0x80 at position j.  We cannot predict the result at the more
+     significant bytes (positions j+1..3), but it does not matter since we
+     already have a non-zero bit at position 8*j+7.
+
+     So, the test whether any byte in longword1 is zero is equivalent to
+     testing whether tmp is nonzero.  */
+
+  while (n >= sizeof (longword))
+    {
+      longword longword1 = *--longword_ptr ^ repeated_c;
+
+      if ((((longword1 - repeated_one) & ~longword1)
+           & (repeated_one << 7)) != 0)
+        {
+          longword_ptr++;
+          break;
+        }
+      n -= sizeof (longword);
+    }
+
+  char_ptr = (const unsigned char *) longword_ptr;
+
+  /* At this point, we know that either n < sizeof (longword), or one of the
+     sizeof (longword) bytes starting at char_ptr is == c.  On little-endian
+     machines, we could determine the first such byte without any further
+     memory accesses, just by looking at the tmp result from the last loop
+     iteration.  But this does not work on big-endian machines.  Choose code
+     that works in both cases.  */
+
+  while (n-- > 0)
+    {
+      if (*--char_ptr == c)
+        return (void *) char_ptr;
+    }
+
+  return NULL;
+}
+#ifdef weak_alias
+weak_alias (__memrchr, memrchr)
+#endif
