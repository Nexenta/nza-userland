Description: Upstream changes introduced in version 2.28.0-1nexenta1
 This patch has been created by dpkg-source during the package build.
 Here's the last changelog entry, hopefully it gives details on why
 those changes were made:
 .
 glib2.0 (2.28.0-1nexenta1) unstable; urgency=low
 .
   * Updated to NCP4 with config from SFW
 .
 The person named in the Author field signed this changelog entry.
Author: Igor Kozhukhov <igor.kozhukhov@nexenta.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- glib2.0-2.28.0.orig/configure
+++ glib2.0-2.28.0/configure
@@ -25591,7 +25591,7 @@ if test x"$have_threads" != xno; then
 	# Sun Studio expands -mt to -D_REENTRANT and -lthread
 	# gcc expands -pthreads to -D_REENTRANT -D_PTHREADS -lpthread
         G_THREAD_CFLAGS="-D_REENTRANT -D_PTHREADS"
-        G_THREAD_LIBS="-lpthread -lthread"
+#        G_THREAD_LIBS="-lpthread -lthread"
         ;;
       *)
         for flag in pthread pthreads mt; do
--- glib2.0-2.28.0.orig/README
+++ glib2.0-2.28.0/README
@@ -1,7 +1,7 @@
 General Information
 ===================
 
-This is GLib version 2.28.0. GLib is the low-level core
+This is GLib version @GLIB_VERSION@. GLib is the low-level core
 library that forms the basis for projects such as GTK+ and GNOME. It
 provides data structure handling for C, portability wrappers, and
 interfaces for such runtime functionality as an event loop, threads,
--- glib2.0-2.28.0.orig/configure.ac
+++ glib2.0-2.28.0/configure.ac
@@ -1921,7 +1921,7 @@ if test x"$have_threads" != xno; then
 	# Sun Studio expands -mt to -D_REENTRANT and -lthread
 	# gcc expands -pthreads to -D_REENTRANT -D_PTHREADS -lpthread
         G_THREAD_CFLAGS="-D_REENTRANT -D_PTHREADS"
-        G_THREAD_LIBS="-lpthread -lthread"
+#        G_THREAD_LIBS="-L/lib -R/lib -lpthread -lthread"
         ;;
       *)
         for flag in pthread pthreads mt; do
--- glib2.0-2.28.0.orig/glib/gatomic.c
+++ glib2.0-2.28.0/glib/gatomic.c
@@ -881,6 +881,7 @@ g_atomic_pointer_compare_and_exchange (v
 #endif /* DEFINE_WITH_WIN32_INTERLOCKED */
 
 #ifdef DEFINE_WITH_MUTEXES
+#include "gthread.h"
 /* We have to use the slow, but safe locking method */
 static GMutex *g_atomic_mutex; 
 
--- /dev/null
+++ glib2.0-2.28.0/glib/glib_probes.h
@@ -0,0 +1,131 @@
+/*
+ * Generated by dtrace(1M).
+ */
+
+#ifndef	_GLIB_PROBES_H_TMP
+#define	_GLIB_PROBES_H_TMP
+
+#include <unistd.h>
+
+#ifdef	__cplusplus
+extern "C" {
+#endif
+
+#if _DTRACE_VERSION
+
+#define	GLIB_MEM_ALLOC(arg0, arg1, arg2, arg3) \
+	__dtrace_glib___mem__alloc(arg0, arg1, arg2, arg3)
+#ifndef	__sparc
+#define	GLIB_MEM_ALLOC_ENABLED() \
+	__dtraceenabled_glib___mem__alloc()
+#else
+#define	GLIB_MEM_ALLOC_ENABLED() \
+	__dtraceenabled_glib___mem__alloc(0)
+#endif
+#define	GLIB_MEM_FREE(arg0) \
+	__dtrace_glib___mem__free(arg0)
+#ifndef	__sparc
+#define	GLIB_MEM_FREE_ENABLED() \
+	__dtraceenabled_glib___mem__free()
+#else
+#define	GLIB_MEM_FREE_ENABLED() \
+	__dtraceenabled_glib___mem__free(0)
+#endif
+#define	GLIB_MEM_REALLOC(arg0, arg1, arg2, arg3) \
+	__dtrace_glib___mem__realloc(arg0, arg1, arg2, arg3)
+#ifndef	__sparc
+#define	GLIB_MEM_REALLOC_ENABLED() \
+	__dtraceenabled_glib___mem__realloc()
+#else
+#define	GLIB_MEM_REALLOC_ENABLED() \
+	__dtraceenabled_glib___mem__realloc(0)
+#endif
+#define	GLIB_QUARK_NEW(arg0, arg1) \
+	__dtrace_glib___quark__new(arg0, arg1)
+#ifndef	__sparc
+#define	GLIB_QUARK_NEW_ENABLED() \
+	__dtraceenabled_glib___quark__new()
+#else
+#define	GLIB_QUARK_NEW_ENABLED() \
+	__dtraceenabled_glib___quark__new(0)
+#endif
+#define	GLIB_SLICE_ALLOC(arg0, arg1) \
+	__dtrace_glib___slice__alloc(arg0, arg1)
+#ifndef	__sparc
+#define	GLIB_SLICE_ALLOC_ENABLED() \
+	__dtraceenabled_glib___slice__alloc()
+#else
+#define	GLIB_SLICE_ALLOC_ENABLED() \
+	__dtraceenabled_glib___slice__alloc(0)
+#endif
+#define	GLIB_SLICE_FREE(arg0, arg1) \
+	__dtrace_glib___slice__free(arg0, arg1)
+#ifndef	__sparc
+#define	GLIB_SLICE_FREE_ENABLED() \
+	__dtraceenabled_glib___slice__free()
+#else
+#define	GLIB_SLICE_FREE_ENABLED() \
+	__dtraceenabled_glib___slice__free(0)
+#endif
+
+
+extern void __dtrace_glib___mem__alloc(void *, unsigned int, unsigned int, unsigned int);
+#ifndef	__sparc
+extern int __dtraceenabled_glib___mem__alloc(void);
+#else
+extern int __dtraceenabled_glib___mem__alloc(long);
+#endif
+extern void __dtrace_glib___mem__free(void *);
+#ifndef	__sparc
+extern int __dtraceenabled_glib___mem__free(void);
+#else
+extern int __dtraceenabled_glib___mem__free(long);
+#endif
+extern void __dtrace_glib___mem__realloc(void *, void *, unsigned int, unsigned int);
+#ifndef	__sparc
+extern int __dtraceenabled_glib___mem__realloc(void);
+#else
+extern int __dtraceenabled_glib___mem__realloc(long);
+#endif
+extern void __dtrace_glib___quark__new(char *, unsigned int);
+#ifndef	__sparc
+extern int __dtraceenabled_glib___quark__new(void);
+#else
+extern int __dtraceenabled_glib___quark__new(long);
+#endif
+extern void __dtrace_glib___slice__alloc(void *, unsigned int);
+#ifndef	__sparc
+extern int __dtraceenabled_glib___slice__alloc(void);
+#else
+extern int __dtraceenabled_glib___slice__alloc(long);
+#endif
+extern void __dtrace_glib___slice__free(void *, unsigned int);
+#ifndef	__sparc
+extern int __dtraceenabled_glib___slice__free(void);
+#else
+extern int __dtraceenabled_glib___slice__free(long);
+#endif
+
+#else
+
+#define	GLIB_MEM_ALLOC(arg0, arg1, arg2, arg3)
+#define	GLIB_MEM_ALLOC_ENABLED() (0)
+#define	GLIB_MEM_FREE(arg0)
+#define	GLIB_MEM_FREE_ENABLED() (0)
+#define	GLIB_MEM_REALLOC(arg0, arg1, arg2, arg3)
+#define	GLIB_MEM_REALLOC_ENABLED() (0)
+#define	GLIB_QUARK_NEW(arg0, arg1)
+#define	GLIB_QUARK_NEW_ENABLED() (0)
+#define	GLIB_SLICE_ALLOC(arg0, arg1)
+#define	GLIB_SLICE_ALLOC_ENABLED() (0)
+#define	GLIB_SLICE_FREE(arg0, arg1)
+#define	GLIB_SLICE_FREE_ENABLED() (0)
+
+#endif
+
+
+#ifdef	__cplusplus
+}
+#endif
+
+#endif	/* _GLIB_PROBES_H_TMP */
