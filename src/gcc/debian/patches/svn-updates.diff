# DP: updates from the 4.4 branch upto 20110215 (r170176).

last_updated()
{
	cat > ${dir}LAST_UPDATED <<EOF
Tue Feb 15 15:10:26 CET 2011
Tue Feb 15 14:10:26 UTC 2011 (revision 170176)
EOF
}

svn diff svn://gcc.gnu.org/svn/gcc/tags/gcc_4_4_5_release svn://gcc.gnu.org/svn/gcc/branches/gcc-4_4-branch \
	| sed -r 's,^--- (\S+)\t(\S+)(.*)$,--- a/src/\1\t\2,;s,^\+\+\+ (\S+)\t(\S+)(.*)$,+++ b/src/\1\t\2,' \
	| awk '/^Index:.*\.(class|texi)/ {skip=1; next} /^Index:/ { skip=0 } skip==0'

Index: configure
===================================================================
--- a/src/configure	(.../tags/gcc_4_4_5_release)
+++ b/src/configure	(.../branches/gcc-4_4-branch)
@@ -2078,7 +2078,7 @@
     # Check for target supported by gold.
     case "${target}" in
       i?86-*-* | x86_64-*-* | sparc*-*-* | powerpc*-*-*)
-        configdirs="`echo " ${configdirs} " | sed -e 's/ ld / gold /'`"
+        configdirs=`echo " ${configdirs} " | sed -e 's/ ld / gold /'`
         ;;
     esac
   fi
Index: libgomp/configure.tgt
===================================================================
--- a/src/libgomp/configure.tgt	(.../tags/gcc_4_4_5_release)
+++ b/src/libgomp/configure.tgt	(.../branches/gcc-4_4-branch)
@@ -115,6 +115,10 @@
 	config_path="bsd posix"
 	;;
 
+  mips-sgi-irix6*)
+	# Need to link with -lpthread so libgomp.so is self-contained.
+	XLDFLAGS="${XLDFLAGS} -lpthread"
+	;;
   *)
 	;;
 
Index: libgomp/ChangeLog
===================================================================
--- a/src/libgomp/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/libgomp/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,37 @@
+2011-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-12-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/46874
+	* libgomp.fortran/allocatable6.f90: New test.
+
+2010-12-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-12-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* configure.tgt (mips-sgi-irix6*): Add -lpthread to XLDFLAGS.
+
+2010-12-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-12-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/46753
+	* libgomp.fortran/pr46753.f90: New test.
+
+	PR libgomp/45240
+	* parallel.c (GOMP_parallel_end): Unlock gomp_remaining_threads_lock
+	at the end if sync builtins aren't supported.
+
+2010-12-03  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-12-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/libgomp.fortran/vla8.f90: Use dg-timeout-factor 2.0.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
Index: libgomp/testsuite/libgomp.fortran/allocatable6.f90
===================================================================
--- a/src/libgomp/testsuite/libgomp.fortran/allocatable6.f90	(.../tags/gcc_4_4_5_release)
+++ b/src/libgomp/testsuite/libgomp.fortran/allocatable6.f90	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,45 @@
+! PR fortran/46874
+! { dg-do run }
+
+  interface
+    subroutine sub (a, b, c, d, n)
+      integer :: n
+      integer, allocatable :: a(:), b(:), c(:), d(:)
+    end subroutine
+  end interface
+
+  integer, allocatable :: a(:), b(:), c(:), d(:)
+  integer :: i, j
+  allocate (a(50), b(50), c(50), d(50))
+  do i = 1, 50
+    a(i) = 2 + modulo (i, 7)
+    b(i) = 179 - modulo (i, 11)
+  end do
+  c = 0
+  d = 2147483647
+  call sub (a, b, c, d, 50)
+  do i = 1, 50
+    j = 0
+    if (i .eq. 3) then
+      j = 8
+    else if (i .gt. 1 .and. i .lt. 9) then
+      j = 7
+    end if
+    if (c(i) .ne. j) call abort
+    j = 179 - modulo (i, 11)
+    if (i .gt. 1 .and. i .lt. 9) j = i
+    if (d(i) .ne. j) call abort
+  end do
+  deallocate (a, b, c, d)
+end
+
+subroutine sub (a, b, c, d, n)
+  integer :: n
+  integer, allocatable :: a(:), b(:), c(:), d(:)
+!$omp parallel do shared(a, b) reduction(+:c) reduction(min:d)
+  do i = 1, n
+    c(a(i)) = c(a(i)) + 1
+    d(i) = min(d(i), b(i))
+    d(a(i)) = min(d(a(i)), a(i))
+  end do
+end
Index: libgomp/testsuite/libgomp.fortran/pr46753.f90
===================================================================
--- a/src/libgomp/testsuite/libgomp.fortran/pr46753.f90	(.../tags/gcc_4_4_5_release)
+++ b/src/libgomp/testsuite/libgomp.fortran/pr46753.f90	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,17 @@
+! PR fortran/46753
+! { dg-do run }
+
+  integer :: i, j
+  j = 0
+!$omp parallel do reduction(+:j)
+  do i = 2147483636, 2147483646
+    j = j + 1
+  end do
+  if (j.ne.11) call abort
+  j = 0
+!$omp parallel do reduction(+:j)
+  do i = -2147483637, -2147483647, -1
+    j = j + 1
+  end do
+  if (j.ne.11) call abort
+end
Index: libgomp/testsuite/libgomp.fortran/vla8.f90
===================================================================
--- a/src/libgomp/testsuite/libgomp.fortran/vla8.f90	(.../tags/gcc_4_4_5_release)
+++ b/src/libgomp/testsuite/libgomp.fortran/vla8.f90	(.../branches/gcc-4_4-branch)
@@ -1,4 +1,5 @@
 ! { dg-do run }
+! { dg-timeout-factor 2.0 }
 
   call test
 contains
Index: libgomp/parallel.c
===================================================================
--- a/src/libgomp/parallel.c	(.../tags/gcc_4_4_5_release)
+++ b/src/libgomp/parallel.c	(.../branches/gcc-4_4-branch)
@@ -1,4 +1,4 @@
-/* Copyright (C) 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
+/* Copyright (C) 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
    Contributed by Richard Henderson <rth@redhat.com>.
 
    This file is part of the GNU OpenMP Library (libgomp).
@@ -123,6 +123,7 @@
 #else
 	  gomp_mutex_lock (&gomp_remaining_threads_lock);
 	  gomp_remaining_threads_count -= team->nthreads - 1;
+	  gomp_mutex_unlock (&gomp_remaining_threads_lock);
 #endif
 	}
     }
Index: gcc/cfgloopmanip.c
===================================================================
--- a/src/gcc/cfgloopmanip.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/cfgloopmanip.c	(.../branches/gcc-4_4-branch)
@@ -1546,7 +1546,10 @@
   /* Duplicate loop.  */
   if (!cfg_hook_duplicate_loop_to_header_edge (loop, entry, 1,
 					       NULL, NULL, NULL, 0))
-    return NULL;
+    {
+      entry->flags |= irred_flag;
+      return NULL;
+    }
 
   /* After duplication entry edge now points to new loop head block.
      Note down new head as second_head.  */
Index: gcc/DATESTAMP
===================================================================
--- a/src/gcc/DATESTAMP	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/DATESTAMP	(.../branches/gcc-4_4-branch)
@@ -1 +1 @@
-20101001
+20110215
Index: gcc/configure
===================================================================
--- a/src/gcc/configure	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/configure	(.../branches/gcc-4_4-branch)
@@ -22423,6 +22423,18 @@
   set_have_as_tls=yes
 fi
 fi
+case "$target" in
+  *-*-irix6*)
+    # IRIX 6.5 rld and libc.so lack TLS support, so even if gas and gld
+    # with TLS support are in use, native TLS cannot work.
+    set_have_as_tls=no
+    ;;
+  *-*-osf*)
+    # Tru64 UNIX loader and libc.so lack TLS support, so even if gas and
+    # gld with TLS support are in use, native TLS cannot work.
+    set_have_as_tls=no
+    ;;
+esac
 if test $set_have_as_tls = yes ; then
 
 cat >>confdefs.h <<\_ACEOF
Index: gcc/builtins.c
===================================================================
--- a/src/gcc/builtins.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/builtins.c	(.../branches/gcc-4_4-branch)
@@ -5452,14 +5452,30 @@
 	{
 	  /* If the format specifier was "string\n", call puts("string").  */
 	  size_t len = strlen (fmt_str);
-	  if ((unsigned char)fmt_str[len - 1] == target_newline)
+	  if ((unsigned char)fmt_str[len - 1] == target_newline
+	      && (size_t) (int) len == len
+	      && (int) len > 0)
 	    {
+	      char *newstr;
+	      tree offset_node, string_cst;
+
 	      /* Create a NUL-terminated string that's one char shorter
 		 than the original, stripping off the trailing '\n'.  */
-	      char *newstr = XALLOCAVEC (char, len);
-	      memcpy (newstr, fmt_str, len - 1);
-	      newstr[len - 1] = 0;
-	      arg = build_string_literal (len, newstr);
+	      arg = build_string_literal (len, fmt_str);
+	      string_cst = string_constant (arg, &offset_node);
+#ifdef ENABLE_CHECKING
+	      gcc_assert (string_cst
+			  && (TREE_STRING_LENGTH (string_cst)
+			      == (int) len)
+			  && integer_zerop (offset_node)
+			  && (unsigned char)
+			      TREE_STRING_POINTER (string_cst)[len - 1]
+			      == target_newline);
+#endif
+	      /* build_string_literal creates a new STRING_CST,
+		 modify it in place to avoid double copying.  */
+	      newstr = CONST_CAST (char *, TREE_STRING_POINTER (string_cst));
+	      newstr[len - 1] = '\0';
 	      if (fn_puts)
 		fn = build_call_expr (fn_puts, 1, arg);
 	    }
@@ -12844,15 +12860,30 @@
 	{
 	  /* If the string was "string\n", call puts("string").  */
 	  size_t len = strlen (str);
-	  if ((unsigned char)str[len - 1] == target_newline)
+	  if ((unsigned char)str[len - 1] == target_newline
+	      && (size_t) (int) len == len
+	      && (int) len > 0)
 	    {
+	      char *newstr;
+	      tree offset_node, string_cst;
+
 	      /* Create a NUL-terminated string that's one char shorter
 		 than the original, stripping off the trailing '\n'.  */
-	      char *newstr = XALLOCAVEC (char, len);
-	      memcpy (newstr, str, len - 1);
-	      newstr[len - 1] = 0;
-
-	      newarg = build_string_literal (len, newstr);
+	      newarg = build_string_literal (len, str);
+	      string_cst = string_constant (newarg, &offset_node);
+#ifdef ENABLE_CHECKING
+	      gcc_assert (string_cst
+			  && (TREE_STRING_LENGTH (string_cst)
+			      == (int) len)
+			  && integer_zerop (offset_node)
+			  && (unsigned char)
+			      TREE_STRING_POINTER (string_cst)[len - 1]
+			      == target_newline);
+#endif
+	      /* build_string_literal creates a new STRING_CST,
+		 modify it in place to avoid double copying.  */
+	      newstr = CONST_CAST (char *, TREE_STRING_POINTER (string_cst));
+	      newstr[len - 1] = '\0';
 	      if (fn_puts)
 		call = build_call_expr (fn_puts, 1, newarg);
 	    }
Index: gcc/fold-const.c
===================================================================
--- a/src/gcc/fold-const.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/fold-const.c	(.../branches/gcc-4_4-branch)
@@ -11658,8 +11658,14 @@
 	  if (integer_pow2p (sval) && tree_int_cst_sgn (sval) > 0)
 	    {
 	      tree sh_cnt = TREE_OPERAND (arg1, 1);
-	      unsigned long pow2 = exact_log2 (TREE_INT_CST_LOW (sval));
+	      unsigned long pow2;
 
+	      if (TREE_INT_CST_LOW (sval))
+		pow2 = exact_log2 (TREE_INT_CST_LOW (sval));
+	      else
+		pow2 = exact_log2 (TREE_INT_CST_HIGH (sval))
+		       + HOST_BITS_PER_WIDE_INT;
+
 	      if (strict_overflow_p)
 		fold_overflow_warning (("assuming signed overflow does not "
 					"occur when simplifying A / (B << N)"),
Index: gcc/ChangeLog
===================================================================
--- a/src/gcc/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,308 @@
+2011-02-15  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR pch/14940
+	* config/alpha/host-osf.c: New file.
+	* config/alpha/x-osf: New file.
+	* config.host (alpha*-dec-osf*): Use it.
+
+2011-02-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline:
+	2011-02-07  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* config/pa/pa64-hpux.h (LIB_SPEC): In static links, link against
+	shared libc if not linking against libpthread.
+	* config/pa/pa-hpux11.h (LIB_SPEC): Likewise.
+
+	2010-08-22  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+        PR boehm-gc/34544
+	* gthr-posix.h (__gthread_active_init): Delete.
+	(__gthread_active_p): Do activity check here.
+	Don't include errno.h on hppa-hpux.  Update comment.
+	* gthr-posix95.h (__gthread_active_init): Delete.
+	(__gthread_active_p): Do activity check here.
+	Don't include errno.h on hppa-hpux.  Update comment.
+
+2011-01-31  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+	2010-12-30  Nathan Froyd  <froydnj@codesourcery.com>
+
+        PR target/44606
+        * reload1.c (choose_reload_regs): Don't look for equivalences for
+        output reloads of constant loads.
+
+2011-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2011-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/47318
+	* config/i386/avxintrin.h (_mm_maskload_pd): Change mask to
+	__m128i.
+	(_mm_maskstore_pd): Likewise.
+	(_mm_maskload_ps): Likewise.
+	(_mm_maskstore_ps): Likewise.
+	(_mm256_maskload_pd): Change mask to __m256i.
+	(_mm256_maskstore_pd): Likewise.
+	(_mm256_maskload_ps): Likewise.
+	(_mm256_maskstore_ps): Likewise.
+
+	* config/i386/i386-builtin-types.def: Updated.
+	(ix86_expand_special_args_builtin): Likewise.
+
+	* config/i386/i386.c (ix86_special_builtin_type): Remove
+	V8SF_FTYPE_PCV8SF_V8SF, V4DF_FTYPE_PCV4DF_V4DF,
+	V4SF_FTYPE_PCV4SF_V4SF, V2DF_FTYPE_PCV2DF_V2DF,
+	VOID_FTYPE_PV8SF_V8SF_V8SF, VOID_FTYPE_PV4DF_V4DF_V4DF,
+	VOID_FTYPE_PV4SF_V4SF_V4SF and VOID_FTYPE_PV2DF_V2DF_V2DF.
+	Add V8SF_FTYPE_PCV8SF_V8SI, V4DF_FTYPE_PCV4DF_V4DI,
+	V4SF_FTYPE_PCV4SF_V4SI, V2DF_FTYPE_PCV2DF_V2DI,
+	VOID_FTYPE_PV8SF_V8SI_V8SF, VOID_FTYPE_PV4DF_V4DI_V4DF,
+	VOID_FTYPE_PV4SF_V4SI_V4SF and VOID_FTYPE_PV2DF_V2DI_V2DF.
+	(bdesc_special_args): Update
+	__builtin_ia32_maskloadpd, __builtin_ia32_maskloadps,
+	__builtin_ia32_maskloadpd256, __builtin_ia32_maskloadps256,
+	__builtin_ia32_maskstorepd, __builtin_ia32_maskstoreps,
+	__builtin_ia32_maskstorepd256 and __builtin_ia32_maskstoreps256.
+	(ix86_init_mmx_sse_builtins): Updated.
+
+	* config/i386/sse.md (avx_maskload<ssemodesuffix><avxmodesuffix>):
+	Use <avxpermvecmode> on mask register.
+	(avx_maskstore<ssemodesuffix><avxmodesuffix>): Likewise.
+
+2011-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-12-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/46880
+	* config/i386/sse.md (sse2_loadlpd, sse2_movsd): Fix shufpd source
+	operand.
+
+	PR middle-end/45852
+	* expr.c (store_expr): Ignore alt_rtl if equal to target,
+	but has side-effects.
+
+	2010-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/46865
+	* rtl.c (rtx_equal_p_cb): For last operand of
+	ASM_OPERANDS and ASM_INPUT if integers are different,
+	call locator_eq.
+	* jump.c (rtx_renumbered_equal_p): Likewise.
+
+2011-01-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2011-01-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR target/43309
+	* config/i386/i386.c (legitimize_tls_address)
+	<TLS_MODEL_INITIAL_EXEC>: Handle TARGET_64BIT && TARGET_SUN_TLS.
+	* config/i386/i386.md (UNSPEC_TLS_IE_SUN): Declare.
+	(tls_initial_exec_64_sun): New pattern.
+
+	2010-03-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* config/i386/i386.c (override_options): Don't accept
+	-mtls-dialect=sun any longer.
+	* config/i386/i386.h (TARGET_SUN_TLS): Define as 0.
+	* config/i386/i386.md (*tls_global_dynamic_32_sun): Remove.
+	(*tls_local_dynamic_base_32_sun): Likewise.
+	* config/i386/sol2.h (TARGET_SUN_TLS): Redefine.
+
+2010-12-30  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* config/pa/pa.md: Add ",*" condition to 64-bit add/subtract boolean
+	patterns.
+
+2010-12-27  Yao Qi  <yao@codesourcery.com>
+
+	Backport from mainline:
+	2010-10-14  Yao Qi  <yao@codesourcery.com>
+
+	PR target/45447
+	* config/arm/arm.c (arm_build_builtin_va_list): Assign
+	va_list_name to TYPE_STUB_DECL (va_list_type).
+
+2010-12-22 John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline:
+	2010-12-18  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/46915
+	* config/pa/pa.c (branch_to_delay_slot_p): Use next_active_insn instead
+	of next_real_insn.  Search forward checking for both ASM_INPUT and
+	ASM_OPERANDS asms until exit condition is found.
+	(branch_needs_nop_p): Likewise.
+	(use_skip_p): New function.
+	(output_cbranch): Use use_skip_p.
+	(output_bb, output_bvb): Likewise.
+
+	2009-06-25  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/40468
+	* pa.c (branch_to_delay_slot_p, branch_needs_nop_p): New functions.
+	(output_cbranch): Use new functions.
+	(output_bb, output_bvb, output_dbra, output_movb): Likewise.
+
+2010-12-13  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-09-15  Olivier Hainque  <hainque@adacore.com>
+        	    Jose Ruiz  <ruiz@adacore.com>
+
+	* config/alpha/osf.h (MD_UNWIND_SUPPORT): Define.
+	* config/alpha/osf-unwind.h: New file.
+
+	2009-08-09  Olivier Hainque  <hainque@adacore.com>
+		    Douglas B Rupp  <rupp@gnat.com>
+
+	* config/alpha/alpha.h (DWARF_FRAME_REGNUM): Define.
+
+2010-12-13  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-04-28  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR target/22224
+	* config/alpha/osf.h (ASM_OUTPUT_LOCAL): Redefine.
+
+2010-12-13  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-11-12  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* config/mips/iris.h [!IRIX_USING_GNU_LD]
+	(SUPPORTS_INIT_PRIORITY): Define.
+
+2010-12-13  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-11-02  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* configure.ac (*-*-irix6*): Disable set_have_as_tls.
+	(*-*-osf*): Likewise.
+	* configure: Regenerate.
+
+2010-12-07  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/46534
+	* builtins.c (expand_builtin_printf): Don't copy and modify string
+	before build_string_literal, instead modify what
+	build_string_literal returned.
+
+	Backport from mainline
+	2010-11-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/46534
+	* builtins.c (fold_builtin_printf): Don't copy and modify string
+	before build_string_literal, instead modify what
+	build_string_literal returned.
+
+2010-12-05  Richard Guenther  <rguenther@suse.de>
+	    Ira Rosen  <irar@il.ibm.com>
+
+	PR tree-optimization/46663
+	* tree-vect-patterns.c (vect_recog_pow_pattern): Check that
+	FUNCTION_DECL exists and that it's a builtin.
+
+2010-11-29  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR rtl-optimization/46337
+	Backport from mainline
+	2009-04-20  Ian Lance Taylor  <iant@google.com>
+
+	* dse.c (replace_inc_dec): Reverse parameters to gen_int_mode.
+
+2010-11-12  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-11-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/43690
+	* gimplify.c (gimplify_asm_expr): If a "m" input is a
+	{pre,post}{in,de}crement, fail.
+
+	2010-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/46107
+	* cfgloopmanip.c (loop_version): Set irred_flag back into entry->flags
+	if cfg_hook_duplicate_loop_to_header_edge failed.
+
+2010-11-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR middle-end/46419
+	* config/i386/xmmintrin.h (_mm_cvtpi16_ps): Swap __hisi and __losi.
+	(_mm_cvtpu16_ps): Ditto.
+
+2010-11-04  Uros Bizjak  <ubizjak@gmail.com>
+
+	Revert:
+	2010-10-30  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR middle-end/44569
+	* lower-suberg.c (simplify_subreg_concatn): For VOIDmode elements,
+	determine the mode of a subreg by GET_MODE_INNER of CONCATN RTX.
+
+2010-11-04  Alan Modra  <amodra@gmail.com>
+
+	* config/rs6000/rs6000.c (rs6000_pic_labelno): Make static.
+	(rs6000_emit_load_toc_table): Don't use rs6000_pic_labelno when
+	TARGET_SECURE_PLT.
+	* config/rs6000/sysv4.h (rs6000_pic_labelno): Don't declare.
+	* config/rs6000/rs6000.md (load_toc_v4_PIC_3b): Use "b" constraint
+	on input, "r" on output.
+
+2010-10-30  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR middle-end/44569
+	* lower-suberg.c (simplify_subreg_concatn): For VOIDmode elements,
+	determine the mode of a subreg by GET_MODE_INNER of CONCATN RTX.
+
+2010-10-22  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/45946
+	* config/i386/i386.md (*pushti2): New insn pattern.
+	(pushti2 splitter): New insn splitter.
+
+2010-10-20  Vladimir Makarov  <vmakarov@redhat.com>
+
+	PR fortran/42169
+	* ira-emit.c (store_can_be_removed_p): Return false instead of
+	gcc_unreachable.
+
+2010-10-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/46019
+	* fold-const.c (fold_binary_loc): If integer_pow2p has
+	TREE_INT_CST_LOW zero, look at TREE_INT_CST_HIGH.
+
+2010-10-07  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR target/45820
+	* config/pa/pa.c (pa_secondary_reload): Handle symbolic operands
+	earlier.
+
+2010-10-01  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-09-30  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/45843
+	* config/i386/i386.c (ix86_gimplify_va_arg): Use
+	INTVAL (XEXP (slot, 1)) as prev_size.
+
+	2010-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/44575
+	* config/i386/i386.c (ix86_gimplify_va_arg): When copying
+	va_arg from a set of register save slots into a temporary,
+	if the container is bigger than type size, do the copying
+	using smaller mode or using memcpy.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
@@ -111,9 +421,9 @@
 	2010-09-01  Ian Bolton  <ian.bolton@arm.com>
 
 	* Makefile.in (tree-switch-conversion.o): Update dependencies.
-	
+
 	2010-08-19  Ian Bolton  <ian.bolton@arm.com>
-	
+
 	PR target/45070
 	* config/arm/arm.c (arm_output_epilogue): Ensure that return
 	value of size 1-3 is handled correctly.
@@ -124,7 +434,7 @@
 	type for the conditional has wide enough range.
 
 	2010-08-07  Marcus Shawcroft  <marcus.shawcroft@arm.com>
-	
+
 	* config/arm/linux-atomic.c (SUBWORD_VAL_CAS): Instantiate with
 	'unsigned short' and 'unsigned char' instead of 'short' and 'char'.
 	(SUBWORD_BOOL_CAS): Likewise.
@@ -133,9 +443,9 @@
 	(FETCH_AND_OP_WORD): Parenthesise INF_OP
 	(SUBWORD_SYNC_OP): Likewise.
 	(OP_AND_FETCH_WORD): Likewise.
-	
+
 2010-09-02  Jakub Jelinek  <jakub@redhat.com>
-	
+
 	Backport from mainline
 	2010-08-30  Jakub Jelinek  <jakub@redhat.com>
 
Index: gcc/testsuite/gcc.c-torture/execute/pr46019.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr46019.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr46019.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,14 @@
+/* PR middle-end/46019 */
+
+extern void abort (void);
+
+int
+main (void)
+{
+  unsigned long long l = 0x40000000000ULL;
+  int n;
+  for (n = 0; n < 8; n++)
+    if (l / (0x200000000ULL << n) != (0x200 >> n))
+      abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/execute/pr44575.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/execute/pr44575.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.c-torture/execute/pr44575.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,49 @@
+/* PR target/44575 */
+
+#include <stdarg.h>
+
+int fails = 0;
+struct S { float a[3]; };
+struct S a[5];
+
+void
+check (int z, ...)
+{
+  struct S arg, *p;
+  va_list ap;
+  int j = 0, k = 0;
+  int i;
+  va_start (ap, z);
+  for (i = 2; i < 4; ++i)
+    {
+      p = 0;
+      j++;
+      k += 2;
+      switch ((z << 4) | i)
+	{
+	case 0x12:
+	case 0x13:
+	  p = &a[2];
+	  arg = va_arg (ap, struct S);
+	  break;
+	default:
+	  ++fails;
+	  break;
+	}
+      if (p && p->a[2] != arg.a[2])
+	++fails;
+      if (fails)
+	break;
+    }
+  va_end (ap);
+}
+
+int
+main ()
+{
+  a[2].a[2] = -49026;
+  check (1, a[2], a[2]);
+  if (fails)
+    abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr46107.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr46107.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr46107.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,16 @@
+/* PR tree-optimization/46107 */
+
+int foo (void) __attribute__ ((noreturn));
+
+void
+bar (int x, int *y, int z)
+{
+  static void *j[] = { &&l1, &&l2 };
+l1:
+  if (*y)
+    goto *j[z];
+  foo ();
+l2:
+  *y ^= (x & 1) ? -1 : 0;
+  goto *j[x];
+}
Index: gcc/testsuite/gcc.c-torture/compile/pr46534.c
===================================================================
--- a/src/gcc/testsuite/gcc.c-torture/compile/pr46534.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.c-torture/compile/pr46534.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,17 @@
+/* PR middle-end/46534 */
+
+extern int printf (const char *, ...);
+
+#define S1 "                    "
+#define S2 S1 S1 S1 S1 S1 S1 S1 S1 S1 S1
+#define S3 S2 S2 S2 S2 S2 S2 S2 S2 S2 S2
+#define S4 S3 S3 S3 S3 S3 S3 S3 S3 S3 S3
+#define S5 S4 S4 S4 S4 S4 S4 S4 S4 S4 S4
+#define S6 S5 S5 S5 S5 S5 S5 S5 S5 S5 S5
+#define S7 S6 S6 S6 S6 S6 S6 S6 S6 S6 S6
+
+void
+foo (void)
+{
+  printf (S7 "\n");
+}
Index: gcc/testsuite/gcc.target/arm/pr45447.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/arm/pr45447.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/arm/pr45447.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,3 @@
+/* { dg-do compile } */
+/* { dg-options "-g -femit-struct-debug-baseonly" } */
+typedef __builtin_va_list x;
Index: gcc/testsuite/gcc.target/i386/i386.exp
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/i386.exp	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/i386.exp	(.../branches/gcc-4_4-branch)
@@ -161,13 +161,24 @@
 
 # If the linker used understands -M <mapfile>, pass it to clear hardware
 # capabilities set by the Sun assembler.
-set FLAGS ""
 set clearcap_ldflags "-Wl,-M,$srcdir/$subdir/clearcap.map"
 
 if [check_no_compiler_messages mapfile executable {
 	int main (void) { return 0; }
   } $clearcap_ldflags ] {
-  set FLAGS $clearcap_ldflags
+
+  if { [info procs gcc_target_compile] != [list] \
+	&& [info procs saved_gcc_target_compile] == [list] } {
+    rename gcc_target_compile saved_gcc_target_compile
+
+    proc gcc_target_compile { source dest type options } {
+      global clearcap_ldflags
+      # Always pass -Wl,-M,<mapfile>, but don't let it show up in gcc.sum.
+      lappend options "additional_flags=$clearcap_ldflags"
+
+      return [saved_gcc_target_compile $source $dest $type $options]
+    }
+  }
 }
 
 # If a testcase doesn't have special options, use these.
@@ -194,7 +205,7 @@
 set tests [prune $tests $srcdir/$subdir/vect-args.c]
 
 # Main loop.
-dg-runtest $tests $FLAGS $DEFAULT_CFLAGS
+dg-runtest $tests "" $DEFAULT_CFLAGS
 
 # All done.
 dg-finish
Index: gcc/testsuite/gcc.target/i386/avx-check.h
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx-check.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx-check.h	(.../branches/gcc-4_4-branch)
@@ -13,7 +13,7 @@
     return 0;
 
   /* Run AVX test only if host has AVX support.  */
-  if (ecx & bit_AVX)
+  if ((ecx & (bit_AVX | bit_OSXSAVE)) == (bit_AVX | bit_OSXSAVE))
     {
       avx_test ();
 #ifdef DEBUG
Index: gcc/testsuite/gcc.target/i386/pr45946.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr45946.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr45946.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-require-effective-target dfp } */
+/* { dg-options "-std=gnu99 -Os -fno-omit-frame-pointer" } */
+
+void
+__attribute__((noinline))
+bar (_Decimal128, _Decimal128, _Decimal128, _Decimal128, _Decimal128,
+     _Decimal128, _Decimal128, _Decimal128, _Decimal128);
+
+void
+foo (void)
+{
+  bar (0, 0, 0, 0, 0, 0, 0, 0, 0);
+}
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-1.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-1.c	(.../branches/gcc-4_4-branch)
@@ -16,10 +16,11 @@
   int i;
   int m[8] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3), mask_v(4), mask_v(5), mask_v(6), mask_v(7)};
   float s[8] = {1,2,3,4,5,6,7,8};
-  union256 u, mask;
+  union256 u;
+  union256i_d mask;
   float e [8] = {0.0};
 
-  mask.x = _mm256_loadu_ps ((float*)m);
+  mask.x = _mm256_loadu_si256 ((__m256i *)m);
   u.x = _mm256_maskload_ps (s, mask.x);
 
   for (i = 0 ; i < 8; i++) 
Index: gcc/testsuite/gcc.target/i386/pr46880.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr46880.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr46880.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,28 @@
+/* PR target/46880 */
+/* { dg-do run } */
+/* { dg-options "-O2 -fno-strict-aliasing -msse2" } */
+/* { dg-require-effective-target sse2_runtime } */
+
+typedef double __m128d __attribute__ ((__vector_size__ (16), __may_alias__));
+typedef double (*T)[2];
+
+static __attribute__ ((noinline)) __m128d
+foo (__m128d c, __m128d d)
+{
+  T cp = (T) &c;
+  T dp = (T) &d;
+  __m128d e = { (*cp)[1], (*dp)[1] };
+  return e;
+}
+
+int
+main ()
+{
+  __m128d c = { 1.0, 2.0 };
+  __m128d d = { 3.0, 4.0 };
+  union { __m128d x; double d[2]; } u;
+  u.x = foo (c, d);
+  if (u.d[0] != 2.0 || u.d[1] != 4.0)
+    __builtin_abort ();
+  return 0;
+}
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovps-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovps-1.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovps-1.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-options "-O2 -mavx" } */
+
+#include "avx-check.h"
+
+#ifndef MASK
+#define MASK 134
+#endif
+
+#define mask_v(pos) (((MASK & (0x1 << (pos))) >> (pos)) << 31)
+
+void static
+avx_test (void)
+{
+  int i;
+  int m[4] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3)};
+  float s[4] = {1,2,3,4};
+  union128 u;
+  union128i_d mask;
+  float e[4] = {0.0};
+
+  mask.x = _mm_loadu_si128 ((__m128i *)m);
+  u.x = _mm_maskload_ps (s, mask.x);
+
+  for (i = 0 ; i < 4; i++) 
+    e[i] = m[i] ? s[i] : 0;
+   
+  if (check_union128 (u, e))
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-1.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-1.c	(.../branches/gcc-4_4-branch)
@@ -14,12 +14,13 @@
 avx_test (void)
 {
   int i;
-  long long m[8] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3)};
+  long long m[4] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3)};
   double s[4] = {1.1, 2.2, 3.3, 4.4};
-  union256d u, mask;
+  union256d u;
+  union256i_q mask;
   double e [4] = {0.0};
 
-  mask.x = _mm256_loadu_pd ((double*)m);
+  mask.x = _mm256_loadu_si256 ((__m256i *)m);
   u.x = _mm256_maskload_pd (s, mask.x);
 
   for (i = 0 ; i < 4; i++) 
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-1.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-1.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,31 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-options "-O2 -mavx" } */
+
+#include "avx-check.h"
+
+#ifndef MASK
+#define MASK 7
+#endif
+
+#define mask_v(pos) (((MASK & (0x1ULL << (pos))) >> (pos)) << 63)
+
+void static
+avx_test (void)
+{
+  int i;
+  long long m[2] = {mask_v(0), mask_v(1)};
+  double s[2] = {1.1, 2.2};
+  union128d u;
+  union128i_q mask;
+  double e[2] = {0.0};
+
+  mask.x = _mm_loadu_si128 ((__m128i *)m);
+  u.x = _mm_maskload_pd (s, mask.x);
+
+  for (i = 0 ; i < 2; i++) 
+    e[i] = m[i] ? s[i] : 0;
+   
+  if (check_union128d (u, e))
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/pr46865-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr46865-1.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr46865-1.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,31 @@
+/* PR rtl-optimization/46865 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+extern unsigned long f;
+
+#define m1(f)							\
+  if (f & 1)							\
+    asm volatile ("nop /* asmnop */\n");			\
+  else								\
+    asm volatile ("nop /* asmnop */\n");
+
+#define m2(f)							\
+  if (f & 1)							\
+    asm volatile ("nop /* asmnop */\n" : : "i" (6) : "cx");	\
+  else								\
+    asm volatile ("nop /* asmnop */\n" : : "i" (6) : "cx");
+
+void
+foo (void)
+{
+  m1 (f);
+}
+
+void
+bar (void)
+{
+  m2 (f);
+}
+
+/* { dg-final { scan-assembler-times "asmnop" 2 } } */
Index: gcc/testsuite/gcc.target/i386/pr45852.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr45852.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr45852.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,16 @@
+/* PR middle-end/45852 */
+/* { dg-options "-O2 -mcmodel=small" } */
+/* { dg-do compile { target { { i?86-*-linux* x86_64-*-linux* } && lp64 } } } */
+/* { dg-require-visibility "" } */
+
+struct S { int s; };
+
+volatile struct S globvar __attribute__((visibility ("hidden"))) = { -6 };
+
+void
+foo (void)
+{
+  globvar = globvar;
+}
+
+/* { dg-final { scan-assembler-times "globvar.%?rip" 2 } } */
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-2.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovps-256-2.c	(.../branches/gcc-4_4-branch)
@@ -16,12 +16,13 @@
   int i;
   int m[8] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3), mask_v(4), mask_v(5), mask_v(6), mask_v(7)};
   float s[8] = {1,2,3,4,5,6,7,8};
-  union256 src, mask;
+  union256 src;
+  union256i_d mask;
   float e [8] = {0.0};
   float d [8] = {0.0};
 
   src.x = _mm256_loadu_ps (s);
-  mask.x = _mm256_loadu_ps ((float *)m);
+  mask.x = _mm256_loadu_si256 ((__m256i *)m);
   _mm256_maskstore_ps (d, mask.x, src.x);
 
   for (i = 0 ; i < 8; i++) 
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovps-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovps-2.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovps-2.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-options "-O2 -mavx" } */
+
+#include "avx-check.h"
+
+#ifndef MASK
+#define MASK 214
+#endif
+
+#define mask_v(pos) (((MASK & (0x1 << (pos))) >> (pos)) << 31)
+
+void static
+avx_test (void)
+{
+  int i;
+  int m[4] = {mask_v(0), mask_v(1), mask_v(2), mask_v(3)};
+  float s[4] = {1,2,3,4};
+  union128 src;
+  union128i_d mask;
+  float e[4] = {0.0};
+  float d[4] = {0.0};
+
+  src.x = _mm_loadu_ps (s);
+  mask.x = _mm_loadu_si128 ((__m128i *)m);
+  _mm_maskstore_ps (d, mask.x, src.x);
+
+  for (i = 0 ; i < 4; i++) 
+    e[i] = m[i] ? s[i] : 0;
+   
+  if (checkVf (d, e, 4))
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-2.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-256-2.c	(.../branches/gcc-4_4-branch)
@@ -18,10 +18,11 @@
   double s[4] = {1.1, 2.2, 3.3, 4.4};
   double e [4] = {0.0};
   double d [4] = {0.0};
-  union256d src, mask;
+  union256d src;
+  union256i_q mask;
   
   src.x = _mm256_loadu_pd (s);
-  mask.x = _mm256_loadu_pd ((double*)m);
+  mask.x = _mm256_loadu_si256 ((__m256i *)m);
   _mm256_maskstore_pd (d, mask.x, src.x);
 
   for (i = 0 ; i < 4; i++) 
Index: gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-2.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/avx-vmaskmovpd-2.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,33 @@
+/* { dg-do run } */
+/* { dg-require-effective-target avx } */
+/* { dg-options "-O2 -mavx" } */
+
+#include "avx-check.h"
+
+#ifndef MASK
+#define MASK 6
+#endif
+
+#define mask_v(pos) (((MASK & (0x1ULL << (pos))) >> (pos)) << 63)
+
+void static
+avx_test (void)
+{
+  int i;
+  long long m[2] = {mask_v(0), mask_v(1)};
+  double s[2] = {1.1, 2.2};
+  double e[2] = {0.0};
+  double d[2] = {0.0};
+  union128d src;
+  union128i_q mask;
+  
+  src.x = _mm_loadu_pd (s);
+  mask.x = _mm_loadu_si128 ((__m128i *)m);
+  _mm_maskstore_pd (d, mask.x, src.x);
+
+  for (i = 0 ; i < 2; i++) 
+    e[i] = m[i] ? s[i] : 0;
+   
+  if (checkVd (d, e, 2))
+    abort ();
+}
Index: gcc/testsuite/gcc.target/i386/pr46419.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr46419.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr46419.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,39 @@
+/* { dg-do run } */
+/* { dg-options "-O2 -msse" } */
+/* { dg-require-effective-target sse } */
+
+#include "sse-check.h"
+
+#include <xmmintrin.h>
+
+void __attribute__((noinline))
+sse_test (void)
+{
+  char image[4];
+  __m128 image4;
+  float out[4] __attribute__ ((aligned (16)));
+  int i;
+
+  for (i = 0; i < 4; i++)
+    image[i] = i + 1;
+
+  image4 =
+    _mm_cvtpi8_ps (_mm_setr_pi8
+		   (image[0], image[1], image[2], image[3], 0, 0, 0, 0));
+  _mm_store_ps (out, image4);
+  _mm_empty ();
+
+  for (i = 0; i < 4; i++)
+    if (out[i] != (float) (i + 1))
+      abort ();
+
+  image4 =
+    _mm_cvtpu8_ps (_mm_setr_pi8
+		   (image[0], image[1], image[2], image[3], 0, 0, 0, 0));
+  _mm_store_ps (out, image4);
+  _mm_empty ();
+
+  for (i = 0; i < 4; i++)
+    if (out[i] != (float) (i + 1))
+      abort ();
+}
Index: gcc/testsuite/gcc.target/i386/pr46865-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/i386/pr46865-2.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/i386/pr46865-2.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,32 @@
+/* PR rtl-optimization/46865 */
+/* { dg-do compile } */
+/* { dg-options "-O2 -save-temps" } */
+
+extern unsigned long f;
+
+#define m1(f)							\
+  if (f & 1)							\
+    asm volatile ("nop /* asmnop */\n");			\
+  else								\
+    asm volatile ("nop /* asmnop */\n");
+
+#define m2(f)							\
+  if (f & 1)							\
+    asm volatile ("nop /* asmnop */\n" : : "i" (6) : "cx");	\
+  else								\
+    asm volatile ("nop /* asmnop */\n" : : "i" (6) : "cx");
+
+void
+foo (void)
+{
+  m1 (f);
+}
+
+void
+bar (void)
+{
+  m2 (f);
+}
+
+/* { dg-final { scan-assembler-times "asmnop" 2 } } */
+/* { dg-final { cleanup-saved-temps } } */
Index: gcc/testsuite/gcc.target/mips/save-restore-3.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/save-restore-3.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/mips/save-restore-3.c	(.../branches/gcc-4_4-branch)
@@ -1,6 +1,7 @@
 /* Check that we can use the save instruction to save spilled arguments
    when the argument save area is out of range of a direct load or store.  */
 /* { dg-options "(-mips16) isa_rev>=1 -mabi=32 -O2" } */
+/* { dg-skip-if "PR target/46610" { mips-sgi-irix6* } } */
 
 void bar (int *);
 
Index: gcc/testsuite/gcc.target/mips/save-restore-4.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/save-restore-4.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/mips/save-restore-4.c	(.../branches/gcc-4_4-branch)
@@ -1,5 +1,6 @@
 /* Check that we can use the save instruction to save $16, $17 and $31.  */
 /* { dg-options "(-mips16) isa_rev>=1 -mabi=32 -O2" } */
+/* { dg-skip-if "PR target/46610" { mips-sgi-irix6* } } */
 
 void bar (void);
 
Index: gcc/testsuite/gcc.target/mips/save-restore-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/save-restore-1.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/mips/save-restore-1.c	(.../branches/gcc-4_4-branch)
@@ -1,5 +1,6 @@
 /* Check that we can use the save instruction to save varargs.  */
 /* { dg-options "(-mips16) isa_rev>=1 -mabi=32 -O2" } */
+/* { dg-skip-if "PR target/46610" { mips-sgi-irix6* } } */
 
 #include <stdarg.h>
 
Index: gcc/testsuite/gcc.target/mips/save-restore-5.c
===================================================================
--- a/src/gcc/testsuite/gcc.target/mips/save-restore-5.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.target/mips/save-restore-5.c	(.../branches/gcc-4_4-branch)
@@ -1,5 +1,6 @@
 /* Check that we don't try to save the same register twice.  */
 /* { dg-options "(-mips16) isa_rev>=1 -mgp32 -O2" } */
+/* { dg-skip-if "PR target/46610" { mips-sgi-irix6* } } */
 
 int bar (int, int, int, int);
 void frob (void);
Index: gcc/testsuite/gnat.dg/pack9.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/pack9.adb	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gnat.dg/pack9.adb	(.../branches/gcc-4_4-branch)
@@ -14,5 +14,5 @@
 
 end Pack9;
 
--- { dg-final { scan-tree-dump-not "__gnat_rcheck" "final_cleanup" } }
+-- { dg-final { scan-tree-dump-not "gnat_rcheck" "final_cleanup" } }
 -- { dg-final { cleanup-tree-dump "final_cleanup" } }
Index: gcc/testsuite/gnat.dg/aliasing2.adb
===================================================================
--- a/src/gcc/testsuite/gnat.dg/aliasing2.adb	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gnat.dg/aliasing2.adb	(.../branches/gcc-4_4-branch)
@@ -18,5 +18,5 @@
 
 end Aliasing2;
 
--- { dg-final { scan-tree-dump-not "__gnat_rcheck" "final_cleanup" } }
+-- { dg-final { scan-tree-dump-not "gnat_rcheck" "final_cleanup" } }
 -- { dg-final { cleanup-tree-dump "final_cleanup" } }
Index: gcc/testsuite/ada/acats/run_acats
===================================================================
--- a/src/gcc/testsuite/ada/acats/run_acats	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/ada/acats/run_acats	(.../branches/gcc-4_4-branch)
@@ -14,9 +14,9 @@
 # Fall back to whence which ksh88 and ksh93 provide, but bash does not.
 
 which () {
-    type -p $* 2>/dev/null && return 0
-    type $* 2>/dev/null | awk '{print $3}' && return 0
-    whence $* 2>/dev/null && return 0
+    path=`type -p $* 2>/dev/null` && { echo $path; return 0; }
+    path=`type $* 2>/dev/null | awk '{print $NF}'` && { echo $path; return 0; }
+    path=`whence $* 2>/dev/null` && { echo $path; return 0; }
     return 1
 }
 
Index: gcc/testsuite/gcc.dg/pragma-init-fini.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pragma-init-fini.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.dg/pragma-init-fini.c	(.../branches/gcc-4_4-branch)
@@ -1,6 +1,7 @@
 /* Tests for #pragma init and #pragma fini.  */
 
 /* { dg-do run { target *-*-solaris2.* } } */
+/* { dg-skip-if "no .pushsection/.popsection" { i?86-*-solaris2.8 && { ! gas } } } */
 
 extern void abort ();
 
Index: gcc/testsuite/gcc.dg/20061124-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/20061124-1.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.dg/20061124-1.c	(.../branches/gcc-4_4-branch)
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-require-effective-target sync_char_short } */
+/* { dg-options "-mcpu=v9" { target sparc*-*-* } } */
 
 /* This testcase failed on s390 because no compare instruction for
    the check of FLAG was emitted.  */
Index: gcc/testsuite/gcc.dg/torture/pr41555.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr41555.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr41555.c	(.../branches/gcc-4_4-branch)
@@ -1,5 +1,6 @@
 /* { dg-do run } */
 /* { dg-options "-std=c99" } */
+/* { dg-require-effective-target stdint_types } */
 
 #include <stdint.h>
 #include <limits.h>
Index: gcc/testsuite/gcc.dg/torture/pr45678-1.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr45678-1.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr45678-1.c	(.../branches/gcc-4_4-branch)
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-options "-fno-common" { target { { hppa*-*-hpux* } && { ! hppa*64*-*-* } } } } */
 
 typedef float V __attribute__ ((vector_size (16)));
 V g;
Index: gcc/testsuite/gcc.dg/torture/pr45678-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/torture/pr45678-2.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.dg/torture/pr45678-2.c	(.../branches/gcc-4_4-branch)
@@ -1,4 +1,5 @@
 /* { dg-do run } */
+/* { dg-options "-fno-common" { target { { hppa*-*-hpux* } && { ! hppa*64*-*-* } } } } */
 
 typedef float V __attribute__ ((vector_size (16)));
 V g;
Index: gcc/testsuite/gcc.dg/pragma-init-fini-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pragma-init-fini-2.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.dg/pragma-init-fini-2.c	(.../branches/gcc-4_4-branch)
@@ -2,6 +2,7 @@
 
 /* { dg-do link { target *-*-solaris2.* } } */
 /* { dg-options "-fpic" } */
+/* { dg-xfail-if "no .pushsection/.popsection" { i?86-*-solaris2.8 && { ! gas } } } */
 
 #include <stdio.h>
 
Index: gcc/testsuite/gcc.dg/compat/vector-1b_main.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/compat/vector-1b_main.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.dg/compat/vector-1b_main.c	(.../branches/gcc-4_4-branch)
@@ -1,12 +1,10 @@
 /* { dg-skip-if "test AVX vector" { ! { i?86-*-* x86_64-*-* } } } */
-/* { dg-require-effective-target avx } */
+/* { dg-require-effective-target avx_runtime } */
 
 /* Test compatibility of vector types: layout between separately-compiled
    modules, parameter passing, and function return.  This test uses
    vectors of integer values.  */
 
-#include "cpuid.h"
-
 extern void vector_1_x (void);
 extern void exit (int);
 int fails;
@@ -14,14 +12,6 @@
 int
 main ()
 {
-  unsigned int eax, ebx, ecx, edx;
-
-  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))
-    return 0;
-
-  /* Run AVX vector test only if host has AVX support.  */
-  if (ecx & bit_AVX)
-    vector_1_x ();
-
+  vector_1_x ();
   exit (0);
 }
Index: gcc/testsuite/gcc.dg/compat/vector-2b_main.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/compat/vector-2b_main.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.dg/compat/vector-2b_main.c	(.../branches/gcc-4_4-branch)
@@ -1,12 +1,10 @@
 /* { dg-skip-if "test AVX support" { ! { i?86-*-* x86_64-*-* } } } */
-/* { dg-require-effective-target avx } */
+/* { dg-require-effective-target avx_runtime } */
 
 /* Test compatibility of vector types: layout between separately-compiled
    modules, parameter passing, and function return.  This test uses
    vectors of floating points values.  */
 
-#include "cpuid.h"
-
 extern void vector_2_x (void);
 extern void exit (int);
 int fails;
@@ -14,14 +12,6 @@
 int
 main ()
 {
-  unsigned int eax, ebx, ecx, edx;
-
-  if (!__get_cpuid (1, &eax, &ebx, &ecx, &edx))
-    return 0;
-
-  /* Run AVX vector test only if host has AVX support.  */
-  if (ecx & bit_AVX)
-    vector_2_x ();
-
+  vector_2_x ();
   exit (0);
 }
Index: gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.dg/debug/dwarf2/inline2.c	(.../branches/gcc-4_4-branch)
@@ -21,27 +21,27 @@
    - One for each subroutine inlined into main, that's 3.
    - One for earch subroutine inline into the out of line instances
      of third, second and first.  */
-/* { dg-final { scan-assembler-times "\\(DIE \\(.*?\\) DW_TAG_inlined_subroutine" 6 } } */
+/* { dg-final { scan-assembler-times "\\(DIE \\(\[^\n\]*\\) DW_TAG_inlined_subroutine" 6 } } */
 
 /* Likewise we should have 6 DW_TAG_lexical_block DIEs:
    - One for each subroutine inlined into main, so that's 3.
    - One for each subroutine inlined in the out of line instances
      of third, second and first, that's 3.
 */
-/* { dg-final { scan-assembler-times "\\(DIE \\(.*?\\) DW_TAG_lexical_block" 6 } } */
+/* { dg-final { scan-assembler-times "\\(DIE \\(\[^\n\]*\\) DW_TAG_lexical_block" 6 } } */
 
 
 /* There are 3 DW_AT_inline attributes: one per abstract inline instance.
    The value of the attribute must be 0x3, meaning the function was
    actually inlined.  */
-/* { dg-final { scan-assembler-times "byte.*?0x3.*? DW_AT_inline" 3 } } */
+/* { dg-final { scan-assembler-times  "(?:byte|data1)\[^\n\]*0x3\[^\n\]* DW_AT_inline" 3 } } */
 
+volatile int *a;
 
 inline void
 third (int arg3)
 {
   int var3 = arg3;
-  int* a = 0;
   a[0] = var3;
 }
 
Index: gcc/testsuite/gcc.dg/pr28796-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr28796-2.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.dg/pr28796-2.c	(.../branches/gcc-4_4-branch)
@@ -2,6 +2,7 @@
 /* { dg-options "-O2 -funsafe-math-optimizations -fno-finite-math-only -DUNSAFE" } */
 /* { dg-options "-mieee -O2 -funsafe-math-optimizations -fno-finite-math-only -DUNSAFE" { target alpha*-*-* } } */
 /* { dg-skip-if "No Inf/NaN support" { spu-*-* } } */
+/* { dg-skip-if "Bug in _Q_dtoq" { sparc*-sun-solaris2.8 } } */
 
 #include "tg-tests.h"
 
Index: gcc/testsuite/gcc.dg/pr44606.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/pr44606.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.dg/pr44606.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,52 @@
+/* PR target/44606 */
+/* { dg-do run } */
+/* { dg-options "-O2" } */
+
+#include <stdio.h>
+
+extern void abort (void);
+
+ typedef struct _PixelPacket { 	unsigned char r, g, b; }
+ PixelPacket;
+#define ARRAYLEN(X) (sizeof(X)/sizeof(X[0]))
+PixelPacket q[6];
+#define COLS (ARRAYLEN(q) - 1)
+PixelPacket p[2*COLS + 22];
+#define Minify(POS, WEIGHT) do {	\
+	total_r += (WEIGHT)*(p[POS].r);	\
+	total_g += (WEIGHT)*(p[POS].g);	\
+	total_b += (WEIGHT)*(p[POS].b);	\
+} while (0)
+unsigned long columns = COLS;
+int main(void)
+{
+	static const unsigned char answers[COLS] = { 31, 32, 34, 35, 36 };
+	unsigned long x;
+	for (x = 0; x < sizeof(p)/sizeof(p[0]); x++) {
+		p[x].b = (x + 34) | 1;
+	}
+	for (x = 0; x < columns; x++) {
+		double total_r = 0, total_g = 0, total_b = 0;
+		double saved_r = 0, saved_g = 0, saved_b = 0;
+		Minify(2*x +  0,  3.0);
+		Minify(2*x +  1,  7.0);
+		Minify(2*x +  2,  7.0);
+		saved_r = total_r;
+		saved_g = total_g;
+		Minify(2*x + 11, 15.0);
+		Minify(2*x + 12,  7.0);
+		Minify(2*x + 18,  7.0);
+		Minify(2*x + 19, 15.0);
+		Minify(2*x + 20, 15.0);
+		Minify(2*x + 21,  7.0);
+		q[x].r = (unsigned char)(total_r/128.0 + 0.5);
+		q[x].g = (unsigned char)(total_g/128.0 + 0.5);
+		q[x].b = (unsigned char)(total_b/128.0 + 0.5);
+		fprintf(stderr, "r:%f g:%f b:%f\n", saved_r, saved_g, saved_b);
+	}
+	for (x = 0; x < COLS; x++) {
+		if (answers[x] != q[x].b)
+			abort();
+	}
+	return 0;
+}
Index: gcc/testsuite/gcc.dg/vect/pr46663.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/pr46663.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/pr46663.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,14 @@
+/* { dg-do compile } */
+/* { dg-options "-O -ftree-vectorize -fdump-tree-vect-details -fexceptions" } */
+
+typedef __attribute__ ((const)) int (*bart) (void);
+
+int foo (bart bar, int m)
+{
+  int i, j = 0;
+  for (i = 0; i < m; i++)
+    j += bar();
+  return j;
+}
+
+/* { dg-final { cleanup-tree-dump "vect" } } */
Index: gcc/testsuite/gcc.dg/vect/slp-multitypes-2.c
===================================================================
--- a/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-2.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gcc.dg/vect/slp-multitypes-2.c	(.../branches/gcc-4_4-branch)
@@ -1,4 +1,5 @@
 /* { dg-require-effective-target vect_int } */
+/* { dg-do run { xfail { sparc*-*-* && ilp32 } } } PR rtl-opt/46603 */
 
 #include <stdarg.h>
 #include <stdio.h>
Index: gcc/testsuite/ChangeLog
===================================================================
--- a/src/gcc/testsuite/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,342 @@
+2011-02-14  Tobias Burnus  <burnus@net-b.de>
+
+	* gfortran.dg/argument_checking_13.f90: Update dg-error.
+	* gfortran.dg/argument_checking_17.f90: New.
+
+2011-02-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR target/46610
+	* gcc.target/mips/save-restore-1.c: Skip on mips-sgi-irix6*.
+	* gcc.target/mips/save-restore-3.c: Likewise.
+	* gcc.target/mips/save-restore-4.c: Likewise.
+	* gcc.target/mips/save-restore-5.c: Likewise.
+
+2011-02-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-07-23  Uros Bizjak  <ubizjak@gmail.com>
+
+	* lib/target-supports.exp (check_avx_hw_available): New procedure.
+	(check_effective_target_avx_runtime): New procedure.
+
+	* gcc.dg/compat/vector-1b_main.c: Use avx_runtime effective target.
+	Remove cpuid.h include and __get_cpuid test.
+	* gcc.dg/compat/vector-2b_main.c: Ditto.
+
+	* gcc.target/i386/avx-check.h (main): Also check bit_OSXSAVE.
+
+2011-02-03  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	PR c++/47589
+	* g++.dg/pr47589.C: New test.
+
+2011-01-31  Nathan Froyd  <froydnj@codesourcery.com>
+
+	Backport from mainline:
+	2010-12-30  Nathan Froyd  <froydnj@codesourcery.com>
+
+	PR target/44606
+	* gcc.dg/pr44606.c: New test.
+
+2011-01-24  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gfortran.dg/cray_pointers_2.f90: Avoid cycling through
+	optimization options.
+
+2011-01-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* g++.dg/other/anon5.C: Skip on mips-sgi-irix*.
+
+	Backport from mainline:
+	2010-11-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* g++.dg/other/anon5.C: Skip on alpha*-dec-osf*.
+
+2011-01-17  Eric Botcazou  <ebotcazou@adacore.com>
+
+	Backport from mainline
+	2010-11-22  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gcc.dg/pr28796-2.c: SKIP on SPARC/Solaris 8.
+
+	PR rtl-optimization/46603
+	* gcc.dg/vect/slp-multitypes-2.c: XFAIL execution on SPARC 32-bit.
+
+2011-01-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* g++.old-deja/g++.other/init19.C: Don't XFAIL on mips-sgi-irix*.
+
+2011-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	Backport from mainline
+	2011-01-17  H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/47318
+	* gcc.target/i386/avx-vmaskmovpd-1.c: New.
+	* gcc.target/i386/avx-vmaskmovpd-2.c: Likewise.
+	* gcc.target/i386/avx-vmaskmovps-1.c: Likewise.
+	* gcc.target/i386/avx-vmaskmovps-1.c: Likewise.
+
+	* gcc.target/i386/avx-vmaskmovpd-256-1.c (avx_test): Load mask
+	as __m256i.
+	* gcc.target/i386/avx-vmaskmovpd-256-2.c (avx_test): Likewise.
+	* gcc.target/i386/avx-vmaskmovps-256-1.c (avx_test): Likewise.
+	* gcc.target/i386/avx-vmaskmovps-256-2.c (avx_test): Likewise.
+
+2011-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-12-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/46880
+	* gcc.target/i386/pr46880.c: New test.
+
+	PR middle-end/45852
+	* gcc.target/i386/pr45852.c: New test.
+
+	2010-12-10  Jakub Jelinek  <jakub@redhat.com>
+
+	PR rtl-optimization/46865
+	* gcc.target/i386/pr46865-1.c: New test.
+	* gcc.target/i386/pr46865-2.c: New test.
+
+2011-01-13  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gfortran.dg/cray_pointers_2.f90: Use dg-timeout-factor 4.
+
+2011-01-12  Eric Botcazou  <ebotcazou@adacore.com>
+
+	PR testsuite/33033
+	* gcc.dg/20061124-1.c: Pass -mcpu=v9 on the SPARC.
+
+2010-12-27  Yao Qi  <yao@codesourcery.com>
+
+	Backport from mainline:
+	2010-10-14  Yao Qi  <yao@codesourcery.com>
+
+	PR target/45447
+	* gcc.target/arm/pr45447.c: New test.
+
+2010-12-13  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-04-01  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* g++.dg/cpp/_Pragma1.C: Skip on alpha*-dec-osf*.
+	* g++.dg/eh/spbp.C: Likewise.
+	* g++.dg/other/pragma-ep-1.C: Properly define p, remove
+	superfluous casts.
+	* objc.dg/dwarf-1.m: Skip on  alpha*-dec-osf*.
+	* objc.dg/dwarf-2.m: Likewise.
+
+2010-12-13  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-11-12  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* lib/prune.exp (prune_gcc_output): Ignore IRIX 6 linker multiline
+	warning.
+	* g++.dg/cpp/_Pragma1.C: Skip on mips-sgi-irix*.
+
+2010-12-09  Daniel Kraft  <d@domob.eu>
+
+	PR fortran/46794
+	* gfortran.dg/power2.f90: New test.
+
+2010-12-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/45081
+	* gfortran.dg/derived_array_intrinsics_1.f90 : New test.
+
+2010-12-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-11-20  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/46538
+	* g++.dg/other/error34.C: New test.
+
+	2010-11-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/46534
+	* gcc.c-torture/compile/pr46534.c: New test.
+
+2010-12-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* ada/acats/run_acats (which): Assign output to temporary
+	variable, only use if successful.
+	Use last field of type output.
+
+2010-12-05  Richard Guenther  <rguenther@suse.de>
+	    Ira Rosen  <irar@il.ibm.com>
+
+	PR tree-optimization/46663
+	* gcc.dg/vect/pr46663.c: New test.
+
+2010-11-28  Eric Botcazou  <ebotcazou@adacore.com>
+
+	* gnat.dg/aliasing2.adb (dg-final): Robustify pattern matching.
+	* gnat.dg/pack9.adb (dg-final): Likewise.
+
+2010-11-27  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/46638
+	PR fortran/46668
+	* gfortran.dg/transfer_simplify_10.f90: Fix endian issue.
+
+2010-11-25  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/46638
+	* gfortran.dg/transfer_simplify_10.f90: New.
+
+2010-11-13  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/45742
+	* gfortran.dg/volatile12.f90: New.
+
+2010-11-12  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-11-05  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/43690
+	* c-c++-common/pr43690.c: New test.
+
+	2010-11-03  Jakub Jelinek  <jakub@redhat.com>
+
+	PR tree-optimization/46107
+	* gcc.c-torture/compile/pr46107.c: New test.
+
+2010-11-10  Uros Bizjak  <ubizjak@gmail.com>
+
+	PR target/46419
+	* gcc-target/i386/pr46419.c: New test.
+
+2010-11-08  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-11-05  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc.target/i386/i386.exp (FLAGS): Remove.
+	Wrap gcc_target_compile with $clearcap_ldflags added to options.
+
+2010-11-03  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from mainline:
+	PR libgfortran/46010
+	* gfortran.dg/namelist_66.f90: New test.
+
+2010-10-22  Uros Bizjak  <ubizjak@gmail.com>
+	    H.J. Lu  <hongjiu.lu@intel.com>
+
+	PR target/45946
+	* gcc.target/i386/pr45946.c: New test.
+
+2010-10-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-10-20  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR c++/46024
+	* g++.dg/warn/miss-format-1.C: Enclose dg-error target list in braces.
+
+	2010-08-04  Daniel Gutson  <dgutson@codesourcery.com>
+
+	* g++.dg/warn/miss-format-1.C: Update line number.
+
+	2010-05-03  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* g++.dg/warn/miss-format-1.C (bar): xfail dg-warning on
+	alpha*-dec-osf*.
+
+2010-10-18  Jakub Jelinek  <jakub@redhat.com>
+
+	PR middle-end/46019
+	* gcc.c-torture/execute/pr46019.c: New test.
+
+2010-10-16  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline
+	2010-09-06  Jakub Jelinek  <jakub@redhat.com>
+
+	PR testsuite/45543
+	* g++.dg/debug/dwarf2/typedef1.C: Expect just one
+	DW_TAG_enumeration_type DIE.
+
+	2010-09-04  Andreas Schwab  <schwab@linux-m68k.org>
+	* g++.dg/debug/dwarf2/typedef1.C: Replace ".*" by "\[^\n\]*".
+
+	2009-11-07  Jason Merrill  <jason@redhat.com>
+
+	PR c++/18451
+	PR c++/40738
+	* g++.dg/other/typedef1.C: Update expected errors.
+
+	2009-08-03  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR testsuite/40858
+	* g++.dg/debug/dwarf2/typedef1.C: Also match assembler string used with
+	.ascii.
+
+	2010-09-04  Andreas Schwab  <schwab@linux-m68k.org>
+	* g++.dg/debug/dwarf2/pubnames-1.C: Replace ".*" by "\[^\n\]*".
+
+	2010-07-07  Tom Tromey  <tromey@redhat.com>
+	* g++.dg/debug/dwarf2/pubnames-1.C: Make darwin-specific.
+
+	2009-09-08  Dodji Seketeli  <dodji@redhat.com>
+	* g++.dg/debug/dwarf2/pubnames-1.C: Use -fno-merge-debug-string
+	and adjust.  Also, adjust to take darwin specifics in account.
+
+2010-10-12  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* gcc.dg/pragma-init-fini.c: Skip on i?86-*-solaris2.8 && !gas.
+	* gcc.dg/pragma-init-fini-2.c: XFAIL on i?86-*-solaris2.8 && !gas.
+
+2010-10-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline
+	2010-09-04  Andreas Schwab  <schwab@linux-m68k.org>
+
+	* gcc.dg/debug/dwarf2/inline2.c: Replace ".*" by "\[^\n\]*".
+
+	2010-03-24  Jakub Jelinek  <jakub@redhat.com>
+
+	* gcc.dg/debug/dwarf2/inline2.c (third): Make a a global var
+	and add volatile keyword.
+
+	2009-11-23  Steve Ellcey  <sje@cup.hp.com>
+
+	* gcc.dg/debug/dwarf2/inline2.c: Modify scan.
+
+2010-10-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* gcc.dg/torture/pr41555.c: Require stdint types.
+
+2010-10-06  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from mainline
+	PR libfortran/45710
+	* gfortran.dg/namelist_65.f90: New test.
+
+2010-10-04  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	* gcc.dg/torture/pr45678-1.c: Add -fno-common to options on 32-bit
+	hppa*-*-hpux*.
+	* gcc.dg/torture/pr45678-2.c: Likewise.
+
+2010-10-01  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-09-30  Jakub Jelinek  <jakub@redhat.com>
+
+	* g++.dg/torture/pr45843.C: New test.
+
+	2010-06-21  Jakub Jelinek  <jakub@redhat.com>
+
+	PR target/44575
+	* gcc.c-torture/execute/pr44575.c: New test.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
@@ -84,7 +423,7 @@
 
 	PR middle-end/40386
 	* gcc.c-torture/execute/{pr40386.c,pr40386.x}: New testcase.
-	
+
 2010-09-08  Jakub Jelinek  <jakub@redhat.com>
 
 	PR fortran/45595
@@ -94,14 +433,14 @@
 
 	Backport from mainline
 	2010-08-19  Ian Bolton  <ian.bolton@arm.com>
-	
+
 	PR target/45070
 	* gcc.c-torture/execute/pr45070.c: New.
 
 	2010-08-19  Ian Bolton  <ian.bolton@arm.com>
 
 	* g++.dg/pr44328.C: New test.
-	
+
 	2010-08-07  Marcus Shawcroft <marcus.shawcroft@arm.com>
 
 	* lib/target-supports.exp: (check_effective_target_sync_int_long):
Index: gcc/testsuite/g++.old-deja/g++.other/init19.C
===================================================================
--- a/src/gcc/testsuite/g++.old-deja/g++.other/init19.C	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/g++.old-deja/g++.other/init19.C	(.../branches/gcc-4_4-branch)
@@ -1,4 +1,4 @@
-// { dg-do run { xfail { { ! cxa_atexit } && { ! *-*-solaris2* } } } }
+// { dg-do run { xfail { { ! cxa_atexit } && { ! { mips-sgi-irix* *-*-solaris2* } } } } }
 #include <stdlib.h>
 
 #define assert(x) do { if (! (x)) abort(); } while (0)
Index: gcc/testsuite/g++.dg/other/error34.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/other/error34.C	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/g++.dg/other/error34.C	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,6 @@
+// PR c++/46538
+// { dg-do compile }
+// { dg-options "" }
+
+S () : str(__PRETTY_FUNCTION__) {}	// { dg-error "forbids declaration" }
+// { dg-error "only constructors" "" { target *-*-* } 5 }
Index: gcc/testsuite/g++.dg/other/anon5.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/other/anon5.C	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/g++.dg/other/anon5.C	(.../branches/gcc-4_4-branch)
@@ -1,5 +1,5 @@
 // PR c++/34094
-// { dg-do link { target { ! { *-*-darwin* *-*-hpux* *-*-solaris2.* } } } }
+// { dg-do link { target { ! { *-*-darwin* *-*-hpux* *-*-solaris2.* alpha*-dec-osf* mips-sgi-irix* } } } }
 // { dg-options "-g" }
 
 namespace {
Index: gcc/testsuite/g++.dg/other/pragma-ep-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/other/pragma-ep-1.C	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/g++.dg/other/pragma-ep-1.C	(.../branches/gcc-4_4-branch)
@@ -22,6 +22,6 @@
 
 extern "C" int four(void);
 
-void *p[] = {
-  (void *) one, (void *) two, (void *) three, (void *) four
+int (*p[])(void) = {
+  one, two, three, four
 };
Index: gcc/testsuite/g++.dg/cpp/_Pragma1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/cpp/_Pragma1.C	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/g++.dg/cpp/_Pragma1.C	(.../branches/gcc-4_4-branch)
@@ -2,7 +2,7 @@
 // This is supposed to succeed only if
 // the target defines HANDLE_PRAGMA_PACK_PUSH_POP 
 // and doesn't define HANDLE_PRAGMA_PACK_WITH_EXPANSION.
-// { dg-do compile { target { ! { powerpc-ibm-aix* *-*-solaris2* fido-*-* m68k-*-* sh*-[us]*-elf m32c-*-* } } } }
+// { dg-do compile { target { ! { powerpc-ibm-aix* *-*-solaris2* fido-*-* m68k-*-* mips-sgi-irix* sh*-[us]*-elf m32c-*-* alpha*-dec-osf* } } } }
 
 #define push bar
 #define foo _Pragma ("pack(push)")
Index: gcc/testsuite/g++.dg/pr47589.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/pr47589.C	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/g++.dg/pr47589.C	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,26 @@
+// PR c++/47589
+// { dg-do compile }
+
+struct F
+{
+    typedef void(*Cb)();
+
+    F(Cb);
+};
+
+struct C
+{
+    template<class D> static void f();
+};
+
+template<class D>
+struct TF : F
+{
+    TF() : F(C::f<D>) { }
+};
+
+struct DTC : TF<DTC>
+{
+    DTC() { }
+};
+
Index: gcc/testsuite/g++.dg/debug/dwarf2/pubnames-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/debug/dwarf2/pubnames-1.C	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/g++.dg/debug/dwarf2/pubnames-1.C	(.../branches/gcc-4_4-branch)
@@ -1,14 +1,22 @@
 // Contributed by Dodji Seketeli <dodji@redhat.com>
 // Origin PR debug/39706
-// { dg-options "-g -dA" }
-// { dg-do compile }
-// { dg-final { scan-assembler-times ".debug_pubnames" 1 } }
-// { dg-final { scan-assembler-times "\"main\".*external name" 1 } }
-// { dg-final { scan-assembler-times "\"ns::ns_x.*external name" 1 } }
-// { dg-final { scan-assembler-times "\"y::y_x.*external name" 1 } }
+// { dg-do compile { target *-*-darwin* } }
+// { dg-options "-g -dA -fno-merge-debug-strings" }
+//
+// There should be one debug_pubnames section generated.
+// On Darwin though, there is also a label pointing at the begining of the
+// debug_pubnames section. The assembly code of that label adds an occurence
+// of section declaration assembly. So on Darwin, we need to check for two
+// occurences of the debug_pubnames section declaration.
+// { dg-final { scan-assembler-times "\.section\[\t \]\[^\n\]*debug_pubnames" 1 { target { ! *-*-darwin* } } } }
+// { dg-final { scan-assembler-times "\.section\[\t \]\[^\n\]*debug_pubnames" 2 { target { *-*-darwin* } } } }
+//
+// Then check of the presence of the names we are interested in.
+// { dg-final { scan-assembler-times "\"main.0\"\[^\n\]*external name" 1 } }
+// { dg-final { scan-assembler-times "\"ns::ns_x\[^\n\]*external name" 1 } }
+// { dg-final { scan-assembler-times "\"y::y_x\[^\n\]*external name" 1 } }
 
 namespace ns { int ns_x; }
 class y { public: static int y_x; };
 int y::y_x;
 int main() { return ns::ns_x; }
-
Index: gcc/testsuite/g++.dg/debug/dwarf2/typedef1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/debug/dwarf2/typedef1.C	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/g++.dg/debug/dwarf2/typedef1.C	(.../branches/gcc-4_4-branch)
@@ -3,12 +3,12 @@
 // { dg-options "-g -dA" }
 // { dg-do compile }
 // { dg-final { scan-assembler-times "DW_TAG_structure_type" 2 } }
-// { dg-final { scan-assembler-times "DW_AT_name: \"foo<1u>\"" 1 } }
+// { dg-final { scan-assembler-times "DW_AT_name: \"foo<1u>\"|\"foo<1u>..\"\[^\n\]*DW_AT_name" 1 } }
 // { dg-final { scan-assembler-times "DW_TAG_enumeration_type" 2 } }
-// { dg-final { scan-assembler-times "DW_AT_name: \"typedef foo<1u>::type type\"" 1 } }
-// { dg-final { scan-assembler-times "DIE (.*) DW_TAG_enumeration_type" 2 } }
-// { dg-final { scan-assembler-times "\"e0..\".*DW_AT_name" 1 } }
-// { dg-final { scan-assembler-times "\"e1..\".*DW_AT_name" 1 } }
+// { dg-final { scan-assembler-times "DW_AT_name: \"typedef foo<1u>::type type\"|\"typedef foo<1u>::type type..\"\[^\n\]*DW_AT_name" 1 } }
+// { dg-final { scan-assembler-times "DIE \\(\[^\n\]*\\) DW_TAG_enumeration_type" 1 } }
+// { dg-final { scan-assembler-times "\"e0..\"\[^\n\]*DW_AT_name" 1 } }
+// { dg-final { scan-assembler-times "\"e1..\"\[^\n\]*DW_AT_name" 1 } }
 
 template <unsigned int n>
 struct foo
Index: gcc/testsuite/g++.dg/warn/miss-format-1.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/warn/miss-format-1.C	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/g++.dg/warn/miss-format-1.C	(.../branches/gcc-4_4-branch)
@@ -4,7 +4,7 @@
 /* { dg-options "-Wmissing-format-attribute" } */
 /* { dg-options "-Wmissing-format-attribute -Wno-abi" { target arm_eabi } } */
 /* VxWorks does not provide vscanf, either in kernel or RTP mode.  */
-/* { dg-error "not declared" "" { target *-*-solaris2.[7-8] *-*-vxworks* } 25 } */
+/* { dg-error "not declared" "" { target { *-*-solaris2.[7-8] *-*-vxworks* alpha*-dec-osf* } } 26 } */
 
 #include <stdio.h>
 #include <stdarg.h>
@@ -23,7 +23,7 @@
 {
   va_list ap;
   va_start (ap, fmt);
-  vscanf (fmt, ap); /* { dg-warning "candidate" "scanf attribute warning" { xfail *-*-solaris2.[7-8] *-*-vxworks* } } */
+  vscanf (fmt, ap); /* { dg-warning "candidate" "scanf attribute warning" { xfail *-*-solaris2.[7-8] *-*-vxworks* alpha*-dec-osf* } } */
   va_end (ap);
 }
 
Index: gcc/testsuite/g++.dg/eh/spbp.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/eh/spbp.C	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/g++.dg/eh/spbp.C	(.../branches/gcc-4_4-branch)
@@ -1,6 +1,6 @@
 /* { dg-do run } */
 /* { dg-options "-gdwarf-2" } */
-/* { dg-skip-if "No Dwarf" { { *-*-aix* hppa*-*-hpux* } && { ! hppa*64*-*-* } } { "*" } { "" } } */
+/* { dg-skip-if "No Dwarf" { { *-*-aix* alpha*-dec-osf* hppa*-*-hpux* } && { ! hppa*64*-*-* } } { "*" } { "" } } */
 
 /* This was a bug on x86-darwin, where the register numbering for SP
    and BP was swapped (it's easy to do because on that port it's
Index: gcc/testsuite/g++.dg/torture/pr45843.C
===================================================================
--- a/src/gcc/testsuite/g++.dg/torture/pr45843.C	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/g++.dg/torture/pr45843.C	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,28 @@
+// PR target/45843
+// { dg-do run }
+
+#include <stdarg.h>
+
+extern "C" void abort ();
+struct S { struct T { } a[14]; char b; };
+struct S arg, s;
+
+void
+foo (int z, ...)
+{
+  char c;
+  va_list ap;
+  va_start (ap, z);
+  c = 'a';
+  arg = va_arg (ap, struct S);
+  if (c != 'a')
+    abort ();
+  va_end (ap);
+}
+
+int
+main ()
+{
+  foo (1, s);
+  return 0;
+}
Index: gcc/testsuite/lib/prune.exp
===================================================================
--- a/src/gcc/testsuite/lib/prune.exp	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/lib/prune.exp	(.../branches/gcc-4_4-branch)
@@ -1,4 +1,4 @@
-#   Copyright (C) 1997, 1999, 2000, 2002, 2004, 2007, 2008
+#   Copyright (C) 1997, 1999, 2000, 2002, 2004, 2007, 2008, 2010
 #   Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
@@ -37,6 +37,9 @@
     regsub -all "(^|\n)\[^\n\]*: Additional NOP may be necessary to workaround Itanium processor A/B step errata" $text "" text
     regsub -all "(^|\n)\[^\n*\]*: Assembler messages:\[^\n\]*" $text "" text
 
+    # Ignore second line of IRIX 6 linker multiline message.
+    regsub -all "(^|\n)\[ \t\]*that might degrade performance on an older version \\(rev. 2.2\\) R4000 processor.\[^\n\]*" $text "" text
+
     # It would be nice to avoid passing anything to gcc that would cause it to
     # issue these messages (since ignoring them seems like a hack on our part),
     # but that's too difficult in the general case.  For example, sometimes
Index: gcc/testsuite/lib/target-supports.exp
===================================================================
--- a/src/gcc/testsuite/lib/target-supports.exp	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/lib/target-supports.exp	(.../branches/gcc-4_4-branch)
@@ -1,5 +1,5 @@
-#   Copyright (C) 1999, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
-#    Free Software Foundation, Inc.
+#   Copyright (C) 1999, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
+#   2011 Free Software Foundation, Inc.
 
 # This program is free software; you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
@@ -926,6 +926,30 @@
     }]
 }
 
+# Return 1 if the target supports executing AVX instructions, 0
+# otherwise.  Cache the result.
+
+proc check_avx_hw_available { } {
+    return [check_cached_effective_target avx_hw_available {
+	# If this is not the right target then we can skip the test.
+	if { !([istarget x86_64-*-*] || [istarget i?86-*-*]) } {
+	    expr 0
+	} else {
+	    check_runtime_nocache avx_hw_available {
+		#include "cpuid.h"
+		int main ()
+		{
+		  unsigned int eax, ebx, ecx, edx;
+		  if (__get_cpuid (1, &eax, &ebx, &ecx, &edx))
+		    return ((ecx & (bit_AVX | bit_OSXSAVE))
+			    != (bit_AVX | bit_OSXSAVE));
+		  return 1;
+		}
+	    } ""
+	}
+    }]
+}
+
 # Return 1 if the target supports running SSE executables, 0 otherwise.
 
 proc check_effective_target_sse_runtime { } {
@@ -946,6 +970,16 @@
     }
 }
 
+# Return 1 if the target supports running AVX executables, 0 otherwise.
+
+proc check_effective_target_avx_runtime { } {
+    if { [check_effective_target_avx]
+	 && [check_avx_hw_available] } {
+	return 1
+    }
+    return 0
+}
+
 # Return 1 if the target supports executing AltiVec instructions, 0
 # otherwise.  Cache the result.
 
Index: gcc/testsuite/objc.dg/dwarf-1.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/dwarf-1.m	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/objc.dg/dwarf-1.m	(.../branches/gcc-4_4-branch)
@@ -1,6 +1,6 @@
 /* { dg-options "-gdwarf-2 -dA" } */
 /* { dg-final { scan-assembler "\"id.0\".*DW_AT_name" } } */
-/* { dg-skip-if "No Dwarf" { { *-*-aix* hppa*-*-hpux* } && { ! hppa*64*-*-* } } { "*" } { "" } } */
+/* { dg-skip-if "No Dwarf" { { *-*-aix* alpha*-dec-osf* hppa*-*-hpux* } && { ! hppa*64*-*-* } } { "*" } { "" } } */
 @interface foo
   id x;
 @end
Index: gcc/testsuite/objc.dg/dwarf-2.m
===================================================================
--- a/src/gcc/testsuite/objc.dg/dwarf-2.m	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/objc.dg/dwarf-2.m	(.../branches/gcc-4_4-branch)
@@ -1,4 +1,4 @@
 /* { dg-options "-gdwarf-2 -dA" } */
 /* { dg-final { scan-assembler "0x10\[^0-9a-f\].*DW_AT_language" } } */
-/* { dg-skip-if "No Dwarf" { { *-*-aix* hppa*-*-hpux* } && { ! hppa*64*-*-* } } { "*" } { "" } } */
+/* { dg-skip-if "No Dwarf" { { *-*-aix* alpha*-dec-osf* hppa*-*-hpux* } && { ! hppa*64*-*-* } } { "*" } { "" } } */
 int x;
Index: gcc/testsuite/gfortran.dg/argument_checking_13.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/argument_checking_13.f90	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gfortran.dg/argument_checking_13.f90	(.../branches/gcc-4_4-branch)
@@ -26,9 +26,9 @@
 real, allocatable :: deferred(:,:,:)
 real, pointer     :: ptr(:,:,:)
 call rlv1(deferred(1,1,1))         ! valid since contiguous
-call rlv1(ptr(1,1,1))              ! { dg-error "Element of assumed-shaped array" }
-call rlv1(assumed_sh_dummy(1,1,1)) ! { dg-error "Element of assumed-shaped array" }
-call rlv1(pointer_dummy(1,1,1))    ! { dg-error "Element of assumed-shaped array" }
+call rlv1(ptr(1,1,1))              ! { dg-error "Element of assumed-shaped or pointer array" }
+call rlv1(assumed_sh_dummy(1,1,1)) ! { dg-error "Element of assumed-shaped or pointer array" }
+call rlv1(pointer_dummy(1,1,1))    ! { dg-error "Element of assumed-shaped or pointer array" }
 end
 
 subroutine test2(assumed_sh_dummy, pointer_dummy)
Index: gcc/testsuite/gfortran.dg/namelist_66.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/namelist_66.f90	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gfortran.dg/namelist_66.f90	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,40 @@
+! { dg-do run }
+! PR46010 Failure to read these two examples of namelists
+type ptracer
+   character(len = 2)  :: sname
+   logical              :: lini
+end type ptracer
+type(ptracer) , dimension(3) :: tracer
+namelist/naml1/  tracer
+
+type qptracer
+   character(len = 20)  :: sname  = ""!: short name
+   character(len = 45 ) :: lname  = ""!: long name
+   character(len = 20 ) :: sunit  = "" !: unit
+   logical              :: lini   !: read in a file or not
+   logical              :: lsav   !: ouput the tracer or not 
+end type qptracer
+type(qptracer) , dimension(3) :: qtracer
+namelist/naml2/  qtracer
+
+open (99, file='nml.dat', status="replace")
+write(99,*) "&naml1"
+write(99,*) "   tracer(1)   = 'aa', .true."
+write(99,*) "   tracer(2)   = 'bb', .true."
+write(99,*) "   tracer(3)   = 'cc', .true."
+write(99,*) "/"
+rewind(99)
+read (99, nml=naml1)
+write (*, nml=naml1)
+rewind(99)
+write(99,*) "&naml2     !   just some stuff"
+write(99,*) "   qtracer(1)   = 'dic     ' , 'dissolved inorganic concentration      ',  'mol-c/l' ,  .true.     ,  .true.,"
+write(99,*) "   qtracer(2)   = 'alkalini' , 'total alkalinity concentration         ',  'eq/l '   ,  .true.     ,  .true.,"
+write(99,*) "/"
+rewind(99)
+read (99, nml=naml2)
+write (*, nml=naml2)
+rewind(99)
+
+close (99, status="delete")
+end
Index: gcc/testsuite/gfortran.dg/cray_pointers_2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/cray_pointers_2.f90	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gfortran.dg/cray_pointers_2.f90	(.../branches/gcc-4_4-branch)
@@ -1,5 +1,8 @@
-! { dg-do run }
-! { dg-options "-fcray-pointer -fbounds-check" }
+! Using two spaces between dg-do and run is a hack to keep gfortran-dg-runtest
+! from cycling through optimization options for this expensive test.
+! { dg-do  run }
+! { dg-options "-O3 -fcray-pointer -fbounds-check" }
+! { dg-timeout-factor 4 }
 ! Series of routines for testing a Cray pointer implementation
 program craytest
   common /errors/errors(400)
Index: gcc/testsuite/gfortran.dg/argument_checking_17.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/argument_checking_17.f90	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gfortran.dg/argument_checking_17.f90	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,26 @@
+! { dg-do compile }
+!
+! PR fortran/47569
+!
+! Contributed by Jos de Kloe 
+!
+module teststr
+  implicit none
+  integer, parameter :: GRH_SIZE = 20, NMAX = 41624
+  type strtype
+    integer   :: size
+    character :: mdr(NMAX)
+  end type strtype
+contains
+  subroutine sub2(string,str_size)
+    integer,intent(in)    :: str_size
+    character,intent(out) :: string(str_size)
+    string(:) = 'a'
+  end subroutine sub2
+  subroutine sub1(a)
+    type(strtype),intent(inout) :: a
+    call sub2(a%mdr(GRH_SIZE+1),a%size-GRH_SIZE)
+  end subroutine sub1
+end module teststr
+
+! { dg-final { cleanup-modules "teststr" } }
Index: gcc/testsuite/gfortran.dg/derived_array_intrinisics_1.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/derived_array_intrinisics_1.f90	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gfortran.dg/derived_array_intrinisics_1.f90	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,33 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-original" }
+! Test the fix for PR45081 in which derived type array valued intrinsics failed
+! to simplify, which caused an ICE in trans-array.c
+!
+! Contributed by Thorsten Ohl <ohl@physik.uni-wuerzburg.de>
+! 
+! Modified for GCC 4.4, which does not support (UN)PACK, TRANSPOSE or SPEAD
+! as initialization expressions.
+
+  module m
+    implicit none
+    integer :: i
+    type t
+      integer :: i
+    end type t
+    type(t), dimension(4), parameter :: t1  = [( t(i), i = 1, 4)]
+    type(t), dimension(4), parameter :: t2  = [( t(i), i = 8, 11)]
+    type(t), dimension(2,2), parameter :: a = reshape ( t1, [ 2, 2 ] )
+    type(t), dimension(2,2), parameter :: b = a !transpose (a)
+    type(t), dimension(4), parameter :: c = reshape ( b, [ 4 ] )
+    type(t), dimension(2), parameter :: d = c([2,4]) !pack ( c, [.false.,.true.,.false.,.true.])
+    type(t), dimension(4), parameter :: e = c !unpack (d, [.false.,.true.,.false.,.true.], t2)
+    type(t), dimension(4,2), parameter :: f = reshape([c,c],[4,2]) !spread (e, 2, 2)
+    type(t), dimension(8), parameter :: g = reshape ( f, [ 8 ] )
+    integer, parameter :: total = g(3)%i
+  end module m
+
+    use m
+    integer :: j
+    j = total
+  end
+! { dg-final { scan-tree-dump-times "j = 3" 1 "original" } }
Index: gcc/testsuite/gfortran.dg/volatile12.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/volatile12.f90	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gfortran.dg/volatile12.f90	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,16 @@
+! { dg-do compile }
+! { dg-options "-fdump-tree-optimized -O3" }
+!
+! PR fortran/45742
+!
+
+subroutine sub(arg)
+  integer, volatile :: arg
+  if (arg /= arg) call I_dont_exist()
+end
+
+! { dg-final { scan-tree-dump "integer.kind=.. . volatile arg" "optimized" } }
+! { dg-final { scan-tree-dump-times " =.v. arg;" 2 "optimized" } }
+! { dg-final { scan-tree-dump "i_dont_exist" "optimized" } }
+! { dg-final { cleanup-tree-dump "optimized" } }
+
Index: gcc/testsuite/gfortran.dg/namelist_65.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/namelist_65.f90	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gfortran.dg/namelist_65.f90	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,22 @@
+! { dg-do run }
+! { dg-options "-std=gnu" }
+! PR45710 Adjust format/padding for WRITE of NAMELIST group to internal file
+program oneline
+real :: a=1,b=2,c=3,d=4
+namelist /nl1/ a,b,c
+parameter(ilines=5)
+character(len=80) :: out(ilines)
+
+! fill array out with @
+do i=1,len(out)
+   out(:)(i:i)='@'
+enddo
+
+write(out,nl1)
+if (out(1).ne."&NL1") call abort
+if (out(2).ne." A=  1.0000000    ,") call abort
+if (out(3).ne." B=  2.0000000    ,") call abort
+if (out(4).ne." C=  3.0000000    ,") call abort
+if (out(5).ne." /") call abort
+
+end program oneline
Index: gcc/testsuite/gfortran.dg/power2.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/power2.f90	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gfortran.dg/power2.f90	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,25 @@
+! { dg-do compile }
+! PR fortran/46794
+
+! Check that results of powers of integers with kinds 1 and 2 are
+! correctly converted back; this used to ICE because a conversion
+! from kind 4 to the correct one was missing.
+
+! Contributed by Daniel Kraft, d@domob.eu.
+
+PROGRAM main
+  IMPLICIT NONE
+
+  INTEGER(KIND=1) :: k1
+  INTEGER(KIND=2) :: k2
+
+  k1 = 1_1
+  k2 = 1_2
+
+  k1 = 1_1 + 1_1**k1
+  k2 = 1_2 + 1_2**k2
+
+  k2 = 1_1 + 1_1**k2
+  k2 = 1_1 + 1_2**k1
+  k2 = 1_1 + 1_2**k2
+END PROGRAM main
Index: gcc/testsuite/gfortran.dg/transfer_simplify_10.f90
===================================================================
--- a/src/gcc/testsuite/gfortran.dg/transfer_simplify_10.f90	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/gfortran.dg/transfer_simplify_10.f90	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,34 @@
+! { dg-do run }
+!
+! PR fortran/46638
+!
+! Contributed by James Van Buskirk
+!
+program test5
+   use ISO_C_BINDING
+   implicit none
+   type, bind(C) :: CPUID_type
+      integer(C_INT32_T) eax
+      integer(C_INT32_T) ebx
+      integer(C_INT32_T) edx
+      integer(C_INT32_T) ecx
+      integer(C_INT32_T) bbb
+   end type CPUID_type
+   type(CPUID_TYPE) result
+  result = transfer(achar(10)//achar(0)//achar(0)//achar(0)//'GenuineIntel'//'abcd',result)
+
+  if((     int(z'0000000A') /= result%eax  &
+      .or. int(z'756E6547') /= result%ebx  &
+      .or. int(z'49656E69') /= result%edx  &
+      .or. int(z'6C65746E') /= result%ecx  &
+      .or. int(z'64636261') /= result%bbb) &
+     .and. & ! Big endian
+     (     int(z'0A000000') /= result%eax  &
+      .or. int(z'47656E75') /= result%ebx  &
+      .or. int(z'696E6549') /= result%edx  &
+      .or. int(z'6E74656C') /= result%ecx  &
+      .or. int(z'61626364') /= result%bbb)) then
+    write(*,'(5(z8.8:1x))') result
+    call abort()
+  end if
+end program test5 
Index: gcc/testsuite/c-c++-common/pr43690.c
===================================================================
--- a/src/gcc/testsuite/c-c++-common/pr43690.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/testsuite/c-c++-common/pr43690.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,13 @@
+/* PR middle-end/43690 */
+/* { dg-do compile } */
+/* { dg-options "-O2" } */
+
+void
+foo (char *x)
+{
+  asm ("" : : "m" (x++));	/* { dg-error "is not directly addressable" } */
+  asm ("" : : "m" (++x));	/* { dg-error "is not directly addressable" } */
+  asm ("" : : "m" (x--));	/* { dg-error "is not directly addressable" } */
+  asm ("" : : "m" (--x));	/* { dg-error "is not directly addressable" } */
+  asm ("" : : "m" (x + 1));	/* { dg-error "is not directly addressable" } */
+}
Index: gcc/cp/decl.c
===================================================================
--- a/src/gcc/cp/decl.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/cp/decl.c	(.../branches/gcc-4_4-branch)
@@ -3536,6 +3536,8 @@
   if (current_function_decl)
     {
       struct cp_binding_level *b = current_binding_level;
+      if (b->kind == sk_function_parms)
+	return error_mark_node;
       while (b->level_chain->kind != sk_function_parms)
 	b = b->level_chain;
       pushdecl_with_scope (decl, b, /*is_friend=*/false);
Index: gcc/cp/tree.c
===================================================================
--- a/src/gcc/cp/tree.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/cp/tree.c	(.../branches/gcc-4_4-branch)
@@ -72,7 +72,8 @@
 	  == REFERENCE_TYPE)
     return lvalue_p_1 (TREE_OPERAND (ref, 0));
 
-  if (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)
+  if (TREE_TYPE (ref)
+      && TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)
     {
       /* unnamed rvalue references are rvalues */
       if (TYPE_REF_IS_RVALUE (TREE_TYPE (ref))
Index: gcc/cp/ChangeLog
===================================================================
--- a/src/gcc/cp/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/cp/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,21 @@
+2011-02-03  Jonathan Wakely  <jwakely.gcc@gmail.com>
+
+	PR c++/47589
+	Backport from mainline
+	2010-11-09  Jakub Jelinek  <jakub@redhat.com>
+
+	PR c++/45894
+	* tree.c (lvalue_kind): Don't crash if ref has NULL type.
+
+2010-12-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-11-20  Jakub Jelinek  <jakub@redhat.com>
+ 
+	PR c++/46538
+	* decl.c (cp_make_fname_decl): Return error_mark_node if
+	current_binding_level has already sk_function_parms kind.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
Index: gcc/jump.c
===================================================================
--- a/src/gcc/jump.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/jump.c	(.../branches/gcc-4_4-branch)
@@ -1670,7 +1670,13 @@
 
 	case 'i':
 	  if (XINT (x, i) != XINT (y, i))
-	    return 0;
+	    {
+	      if (((code == ASM_OPERANDS && i == 5)
+		   || (code == ASM_INPUT && i == 1))
+		  && locator_eq (XINT (x, i), XINT (y, i)))
+		break;
+	      return 0;
+	    }
 	  break;
 
 	case 't':
Index: gcc/expr.c
===================================================================
--- a/src/gcc/expr.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/expr.c	(.../branches/gcc-4_4-branch)
@@ -4662,7 +4662,10 @@
       /* If store_expr stores a DECL whose DECL_RTL(exp) == TARGET,
 	 but TARGET is not valid memory reference, TEMP will differ
 	 from TARGET although it is really the same location.  */
-      && !(alt_rtl && rtx_equal_p (alt_rtl, target))
+      && !(alt_rtl
+	   && rtx_equal_p (alt_rtl, target)
+	   && !side_effects_p (alt_rtl)
+	   && !side_effects_p (target))
       /* If there's nothing to copy, don't bother.  Don't call
 	 expr_size unless necessary, because some front-ends (C++)
 	 expr_size-hook must not be given objects that are not
Index: gcc/dse.c
===================================================================
--- a/src/gcc/dse.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/dse.c	(.../branches/gcc-4_4-branch)
@@ -826,7 +826,7 @@
     case POST_INC:
       {
 	rtx r1 = XEXP (x, 0);
-	rtx c = gen_int_mode (Pmode, data->size);
+	rtx c = gen_int_mode (data->size, Pmode);
 	emit_insn_before (gen_rtx_SET (Pmode, r1, 
 				       gen_rtx_PLUS (Pmode, r1, c)),
 			  data->insn);
@@ -837,7 +837,7 @@
     case POST_DEC:
       {
 	rtx r1 = XEXP (x, 0);
-	rtx c = gen_int_mode (Pmode, -data->size);
+	rtx c = gen_int_mode (-data->size, Pmode);
 	emit_insn_before (gen_rtx_SET (Pmode, r1, 
 				       gen_rtx_PLUS (Pmode, r1, c)),
 			  data->insn);
Index: gcc/fortran/interface.c
===================================================================
--- a/src/gcc/fortran/interface.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/fortran/interface.c	(.../branches/gcc-4_4-branch)
@@ -1436,7 +1436,7 @@
 		   int ranks_must_agree, int is_elemental, locus *where)
 {
   gfc_ref *ref;
-  bool rank_check;
+  bool rank_check, is_pointer;
 
   /* If the formal arg has type BT_VOID, it's to one of the iso_c_binding
      procs c_f_pointer or c_f_procpointer, and we need to accept most
@@ -1511,22 +1511,48 @@
     return 1;
 
   /* At this point, we are considering a scalar passed to an array.   This
-     is valid (cf. F95 12.4.1.1; F2003 12.4.1.2),
+     is valid (cf. F95 12.4.1.1, F2003 12.4.1.2, and F2008 12.5.2.4),
      - if the actual argument is (a substring of) an element of a
-       non-assumed-shape/non-pointer array;
-     - (F2003) if the actual argument is of type character.  */
+       non-assumed-shape/non-pointer/non-polymorphic array; or
+     - (F2003) if the actual argument is of type character of default/c_char
+       kind.  */
 
+  is_pointer = actual->expr_type == EXPR_VARIABLE
+	       ? actual->symtree->n.sym->attr.pointer : false;
+
   for (ref = actual->ref; ref; ref = ref->next)
-    if (ref->type == REF_ARRAY && ref->u.ar.type == AR_ELEMENT)
-      break;
+    {
+      if (ref->type == REF_COMPONENT)
+	is_pointer = ref->u.c.component->attr.pointer;
+      else if (ref->type == REF_ARRAY && ref->u.ar.type == AR_ELEMENT
+	       && ref->u.ar.dimen > 0
+	       && (!ref->next 
+		   || (ref->next->type == REF_SUBSTRING && !ref->next->next)))
+	break;
+    }
 
-  /* Not an array element.  */
-  if (formal->ts.type == BT_CHARACTER
-      && (ref == NULL
-          || (actual->expr_type == EXPR_VARIABLE
-	      && (actual->symtree->n.sym->as->type == AS_ASSUMED_SHAPE
-		  || actual->symtree->n.sym->attr.pointer))))
+  if (actual->expr_type != EXPR_NULL && ref && actual->ts.type != BT_CHARACTER
+      && (is_pointer || ref->u.ar.as->type == AS_ASSUMED_SHAPE))
     {
+      if (where)
+	gfc_error ("Element of assumed-shaped or pointer "
+		   "array passed to array dummy argument '%s' at %L",
+		   formal->name, &actual->where);
+      return 0;
+    }
+
+  if (actual->ts.type == BT_CHARACTER && actual->expr_type != EXPR_NULL
+      && (!ref || is_pointer || ref->u.ar.as->type == AS_ASSUMED_SHAPE))
+    {
+      if (formal->ts.kind != 1 && (gfc_option.allow_std & GFC_STD_GNU) == 0)
+	{
+	  if (where)
+	    gfc_error ("Extension: Scalar non-default-kind, non-C_CHAR-kind "
+		       "CHARACTER actual argument with array dummy argument "
+		       "'%s' at %L", formal->name, &actual->where);
+	  return 0;
+	}
+
       if (where && (gfc_option.allow_std & GFC_STD_F2003) == 0)
 	{
 	  gfc_error ("Fortran 2003: Scalar CHARACTER actual argument with "
@@ -1539,7 +1565,8 @@
       else
 	return 1;
     }
-  else if (ref == NULL)
+
+  if (ref == NULL && actual->expr_type != EXPR_NULL)
     {
       if (where)
 	gfc_error ("Rank mismatch in argument '%s' at %L (%d and %d)",
@@ -1548,17 +1575,6 @@
       return 0;
     }
 
-  if (actual->expr_type == EXPR_VARIABLE
-      && actual->symtree->n.sym->as
-      && (actual->symtree->n.sym->as->type == AS_ASSUMED_SHAPE
-	  || actual->symtree->n.sym->attr.pointer))
-    {
-      if (where)
-	gfc_error ("Element of assumed-shaped array passed to dummy "
-		   "argument '%s' at %L", formal->name, &actual->where);
-      return 0;
-    }
-
   return 1;
 }
 
Index: gcc/fortran/trans-expr.c
===================================================================
--- a/src/gcc/fortran/trans-expr.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/fortran/trans-expr.c	(.../branches/gcc-4_4-branch)
@@ -917,6 +917,7 @@
   tree gfc_int4_type_node;
   int kind;
   int ikind;
+  int res_ikind_1, res_ikind_2;
   gfc_se lse;
   gfc_se rse;
   tree fndecl;
@@ -937,6 +938,13 @@
 
   gfc_int4_type_node = gfc_get_int_type (4);
 
+  /* In case of integer operands with kinds 1 or 2, we call the integer kind 4
+     library routine.  But in the end, we have to convert the result back
+     if this case applies -- with res_ikind_K, we keep track whether operand K
+     falls into this case.  */
+  res_ikind_1 = -1;
+  res_ikind_2 = -1;
+
   kind = expr->value.op.op1->ts.kind;
   switch (expr->value.op.op2->ts.type)
     {
@@ -947,6 +955,7 @@
 	case 1:
 	case 2:
 	  rse.expr = convert (gfc_int4_type_node, rse.expr);
+	  res_ikind_2 = ikind;
 	  /* Fall through.  */
 
 	case 4:
@@ -969,7 +978,10 @@
 	case 1:
 	case 2:
 	  if (expr->value.op.op1->ts.type == BT_INTEGER)
-	    lse.expr = convert (gfc_int4_type_node, lse.expr);
+	    {
+	      lse.expr = convert (gfc_int4_type_node, lse.expr);
+	      res_ikind_1 = kind;
+	    }
 	  else
 	    gcc_unreachable ();
 	  /* Fall through.  */
@@ -1080,6 +1092,15 @@
     }
 
   se->expr = build_call_expr (fndecl, 2, lse.expr, rse.expr);
+
+  /* Convert the result back if it is of wrong integer kind.  */
+  if (res_ikind_1 != -1 && res_ikind_2 != -1)
+    {
+      /* We want the maximum of both operand kinds as result.  */
+      if (res_ikind_1 < res_ikind_2)
+	res_ikind_1 = res_ikind_2;
+      se->expr = convert (gfc_get_int_type (res_ikind_1), se->expr);
+    }
 }
 
 
Index: gcc/fortran/trans-common.c
===================================================================
--- a/src/gcc/fortran/trans-common.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/fortran/trans-common.c	(.../branches/gcc-4_4-branch)
@@ -323,6 +323,7 @@
     {
       tree new_type;
       TREE_THIS_VOLATILE (field) = 1;
+      TREE_SIDE_EFFECTS (field) = 1;
       new_type = build_qualified_type (TREE_TYPE (field), TYPE_QUAL_VOLATILE);
       TREE_TYPE (field) = new_type;
     }
Index: gcc/fortran/trans-openmp.c
===================================================================
--- a/src/gcc/fortran/trans-openmp.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/fortran/trans-openmp.c	(.../branches/gcc-4_4-branch)
@@ -477,13 +477,23 @@
   gfc_symbol init_val_sym, outer_sym, intrinsic_sym;
   gfc_expr *e1, *e2, *e3, *e4;
   gfc_ref *ref;
-  tree decl, backend_decl, stmt;
+  tree decl, backend_decl, stmt, type, outer_decl;
   locus old_loc = gfc_current_locus;
   const char *iname;
   gfc_try t;
 
   decl = OMP_CLAUSE_DECL (c);
   gfc_current_locus = where;
+  type = TREE_TYPE (decl);
+  outer_decl = create_tmp_var_raw (type, NULL);
+  if (TREE_CODE (decl) == PARM_DECL
+      && TREE_CODE (type) == REFERENCE_TYPE
+      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (type))
+      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (type)) == GFC_ARRAY_ALLOCATABLE)
+    {
+      decl = build_fold_indirect_ref (decl);
+      type = TREE_TYPE (type);
+    }
 
   /* Create a fake symbol for init value.  */
   memset (&init_val_sym, 0, sizeof (init_val_sym));
@@ -502,7 +512,9 @@
   outer_sym.attr.dummy = 0;
   outer_sym.attr.result = 0;
   outer_sym.attr.flavor = FL_VARIABLE;
-  outer_sym.backend_decl = create_tmp_var_raw (TREE_TYPE (decl), NULL);
+  outer_sym.backend_decl = outer_decl;
+  if (decl != OMP_CLAUSE_DECL (c))
+    outer_sym.backend_decl = build_fold_indirect_ref (outer_decl);
 
   /* Create fake symtrees for it.  */
   symtree1 = gfc_new_symtree (&root1, sym->name);
@@ -619,12 +631,12 @@
 
   /* Create the init statement list.  */
   pushlevel (0);
-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl))
-      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (decl)) == GFC_ARRAY_ALLOCATABLE)
+  if (GFC_DESCRIPTOR_TYPE_P (type)
+      && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)
     {
       /* If decl is an allocatable array, it needs to be allocated
 	 with the same bounds as the outer var.  */
-      tree type = TREE_TYPE (decl), rank, size, esize, ptr;
+      tree rank, size, esize, ptr;
       stmtblock_t block;
 
       gfc_start_block (&block);
@@ -660,8 +672,8 @@
 
   /* Create the merge statement list.  */
   pushlevel (0);
-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl))
-      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (decl)) == GFC_ARRAY_ALLOCATABLE)
+  if (GFC_DESCRIPTOR_TYPE_P (type)
+      && GFC_TYPE_ARRAY_AKIND (type) == GFC_ARRAY_ALLOCATABLE)
     {
       /* If decl is an allocatable array, it needs to be deallocated
 	 afterwards.  */
@@ -681,7 +693,7 @@
   OMP_CLAUSE_REDUCTION_MERGE (c) = stmt;
 
   /* And stick the placeholder VAR_DECL into the clause as well.  */
-  OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = outer_sym.backend_decl;
+  OMP_CLAUSE_REDUCTION_PLACEHOLDER (c) = outer_decl;
 
   gfc_current_locus = old_loc;
 
@@ -1240,8 +1252,9 @@
       if (simple)
 	{
 	  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, dovar, from);
-	  TREE_VEC_ELT (cond, i) = fold_build2 (simple > 0 ? LE_EXPR : GE_EXPR,
-						boolean_type_node, dovar, to);
+	  /* The condition should not be folded.  */
+	  TREE_VEC_ELT (cond, i) = build2 (simple > 0 ? LE_EXPR : GE_EXPR,
+					   boolean_type_node, dovar, to);
 	  TREE_VEC_ELT (incr, i) = fold_build2 (PLUS_EXPR, type, dovar, step);
 	  TREE_VEC_ELT (incr, i) = fold_build2 (MODIFY_EXPR, type, dovar,
 						TREE_VEC_ELT (incr, i));
@@ -1262,8 +1275,9 @@
 	  count = gfc_create_var (type, "count");
 	  TREE_VEC_ELT (init, i) = build2_v (MODIFY_EXPR, count,
 					     build_int_cst (type, 0));
-	  TREE_VEC_ELT (cond, i) = fold_build2 (LT_EXPR, boolean_type_node,
-						count, tmp);
+	  /* The condition should not be folded.  */
+	  TREE_VEC_ELT (cond, i) = build2 (LT_EXPR, boolean_type_node,
+					   count, tmp);
 	  TREE_VEC_ELT (incr, i) = fold_build2 (PLUS_EXPR, type, count,
 						build_int_cst (type, 1));
 	  TREE_VEC_ELT (incr, i) = fold_build2 (MODIFY_EXPR, type,
Index: gcc/fortran/ChangeLog
===================================================================
--- a/src/gcc/fortran/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/fortran/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,59 @@
+2011-02-14  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/47569
+	* interface.c (compare_parameter): Avoid ICE with
+	character components.
+
+2011-01-16  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-12-14  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/46874
+	* trans-openmp.c (gfc_trans_omp_array_reduction): Handle allocatable
+	dummy variables.
+
+2010-12-09  Daniel Kraft  <d@domob.eu>
+
+	PR fortran/46794
+	* trans-expr.c (gfc_conv_power_op): Handle kind of result expression
+	correctly for integer kind 1 and 2 operands.
+
+2010-12-09  Paul Thomas  <pault@gcc.gnu.org>
+
+	PR fortran/45081
+	* simplify.c (is_constant_array_expr): Allow structure array
+	elements as well as constants.
+	(gfc_simplify_reshape): Copy the derived type of source to
+	the result.
+
+2010-12-07  Jakub Jelinek  <jakub@redhat.com>
+
+	Backport from mainline
+	2010-12-02  Jakub Jelinek  <jakub@redhat.com>
+
+	PR fortran/46753
+	* trans-openmp.c (gfc_trans_omp_do): Use build2_loc instead of
+	fold_build2_loc for OMP_FOR conditions.
+
+2010-11-25  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/46638
+	* target-memory.c (gfc_interpret_derived): Correctly handle
+	component offset.
+
+2010-11-13  Tobias Burnus  <burnus@net-b.de>
+
+	PR fortran/45742
+	* trans-common.c (build_field): Add TREE_SIDE_EFFECTS for volatile.
+	* trans-decl.c (gfc_finish_var_decl): Ditto.
+	(create_function_arglist): Handle volatile dummy arguments.
+
+2010-10-25  Steven G. Kargl  <kargl@gcc.gnu.org>
+
+	PR fortran/46140
+	* fortran/scanner.c (include_line): Check return value of load_file.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
Index: gcc/fortran/scanner.c
===================================================================
--- a/src/gcc/fortran/scanner.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/fortran/scanner.c	(.../branches/gcc-4_4-branch)
@@ -1770,7 +1770,9 @@
 		   read by anything else.  */
 
   filename = gfc_widechar_to_char (begin, -1);
-  load_file (filename, NULL, false);
+  if (load_file (filename, NULL, false) == FAILURE)
+    exit (1);
+
   gfc_free (filename);
   return true;
 }
Index: gcc/fortran/trans-decl.c
===================================================================
--- a/src/gcc/fortran/trans-decl.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/fortran/trans-decl.c	(.../branches/gcc-4_4-branch)
@@ -539,6 +539,7 @@
   if (sym->attr.volatile_)
     {
       TREE_THIS_VOLATILE (decl) = 1;
+      TREE_SIDE_EFFECTS (decl) = 1;
       new_type = build_qualified_type (TREE_TYPE (decl), TYPE_QUAL_VOLATILE);
       TREE_TYPE (decl) = new_type;
     } 
@@ -1655,10 +1656,19 @@
 
       if (f->sym->attr.proc_pointer)
         type = build_pointer_type (type);
+ 
+      if (f->sym->attr.volatile_)
+	type = build_qualified_type (type, TYPE_QUAL_VOLATILE);
 
       /* Build the argument declaration.  */
       parm = build_decl (PARM_DECL, gfc_sym_identifier (f->sym), type);
 
+      if (f->sym->attr.volatile_)
+	{
+	  TREE_THIS_VOLATILE (parm) = 1;
+	  TREE_SIDE_EFFECTS (parm) = 1;
+	}
+
       /* Fill in arg stuff.  */
       DECL_CONTEXT (parm) = fndecl;
       DECL_ARG_TYPE (parm) = TREE_VALUE (typelist);
Index: gcc/fortran/target-memory.c
===================================================================
--- a/src/gcc/fortran/target-memory.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/fortran/target-memory.c	(.../branches/gcc-4_4-branch)
@@ -484,7 +484,16 @@
 	     }
 	}
 
-      ptr = TREE_INT_CST_LOW (DECL_FIELD_OFFSET (cmp->backend_decl));
+      /* Calculate the offset, which consists of the the FIELD_OFFSET in
+	 bytes, which appears in multiples of DECL_OFFSET_ALIGN-bit-sized,
+	 and additional bits of FIELD_BIT_OFFSET. The code assumes that all
+	 sizes of the components are multiples of BITS_PER_UNIT,
+	 i.e. there are, e.g., no bit fields.  */
+
+      ptr = TREE_INT_CST_LOW (DECL_FIELD_BIT_OFFSET (cmp->backend_decl));
+      gcc_assert (ptr % 8 == 0);
+      ptr = ptr/8 + TREE_INT_CST_LOW (DECL_FIELD_OFFSET (cmp->backend_decl));
+
       gfc_target_interpret_expr (&buffer[ptr], buffer_size - ptr,
 				 tail->expr);
 
Index: gcc/fortran/simplify.c
===================================================================
--- a/src/gcc/fortran/simplify.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/fortran/simplify.c	(.../branches/gcc-4_4-branch)
@@ -3448,7 +3448,8 @@
     return false;
   
   for (c = e->value.constructor; c; c = c->next)
-    if (c->expr->expr_type != EXPR_CONSTANT)
+    if (c->expr->expr_type != EXPR_CONSTANT
+	  && c->expr->expr_type != EXPR_STRUCTURE)
       return false;
 
   return true;
@@ -3679,6 +3680,11 @@
   e->ts = source->ts;
   e->rank = rank;
 
+  if (source->ts.type == BT_CHARACTER)
+    e->ts.cl = source->ts.cl;
+  else if (source->ts.type == BT_DERIVED)
+    e->ts.derived = source->ts.derived;
+
   return e;
 
 bad_reshape:
Index: gcc/configure.ac
===================================================================
--- a/src/gcc/configure.ac	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/configure.ac	(.../branches/gcc-4_4-branch)
@@ -2838,6 +2838,18 @@
   [$tls_first_major,$tls_first_minor,0], [$tls_as_opt], [$conftest_s],,
   [set_have_as_tls=yes])
 fi
+case "$target" in
+  *-*-irix6*)
+    # IRIX 6.5 rld and libc.so lack TLS support, so even if gas and gld
+    # with TLS support are in use, native TLS cannot work.
+    set_have_as_tls=no
+    ;;
+  *-*-osf*)
+    # Tru64 UNIX loader and libc.so lack TLS support, so even if gas and
+    # gld with TLS support are in use, native TLS cannot work.
+    set_have_as_tls=no
+    ;;
+esac
 if test $set_have_as_tls = yes ; then
   AC_DEFINE(HAVE_AS_TLS, 1,
 	    [Define if your assembler supports thread-local storage.])
Index: gcc/ira-emit.c
===================================================================
--- a/src/gcc/ira-emit.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/ira-emit.c	(.../branches/gcc-4_4-branch)
@@ -368,7 +368,8 @@
 	   prohibit removal of the store in such complicated case.  */
 	return false;
     }
-  gcc_unreachable ();
+  /* It is actually a loop entry -- do not remove the store.  */
+  return false;
 }
 
 /* Generate and attach moves to the edge E.  This looks at the final
Index: gcc/gimplify.c
===================================================================
--- a/src/gcc/gimplify.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/gimplify.c	(.../branches/gcc-4_4-branch)
@@ -4842,6 +4842,13 @@
       /* If the operand is a memory input, it should be an lvalue.  */
       if (!allows_reg && allows_mem)
 	{
+	  tree inputv = TREE_VALUE (link);
+	  STRIP_NOPS (inputv);
+	  if (TREE_CODE (inputv) == PREDECREMENT_EXPR
+	      || TREE_CODE (inputv) == PREINCREMENT_EXPR
+	      || TREE_CODE (inputv) == POSTDECREMENT_EXPR
+	      || TREE_CODE (inputv) == POSTINCREMENT_EXPR)
+	    TREE_VALUE (link) = error_mark_node;
 	  tret = gimplify_expr (&TREE_VALUE (link), pre_p, post_p,
 				is_gimple_lvalue, fb_lvalue | fb_mayfail);
 	  mark_addressable (TREE_VALUE (link));
Index: gcc/tree-vect-patterns.c
===================================================================
--- a/src/gcc/tree-vect-patterns.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/tree-vect-patterns.c	(.../branches/gcc-4_4-branch)
@@ -475,6 +475,9 @@
   type = gimple_expr_type (last_stmt);
 
   fn = gimple_call_fndecl (last_stmt);
+  if (fn == NULL_TREE || DECL_BUILT_IN_CLASS (fn) != BUILT_IN_NORMAL)
+    return NULL;
+
   switch (DECL_FUNCTION_CODE (fn))
     {
     case BUILT_IN_POWIF:
Index: gcc/rtl.c
===================================================================
--- a/src/gcc/rtl.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/rtl.c	(.../branches/gcc-4_4-branch)
@@ -405,7 +405,15 @@
 	case 'n':
 	case 'i':
 	  if (XINT (x, i) != XINT (y, i))
-	    return 0;
+	    {
+#ifndef GENERATOR_FILE
+	      if (((code == ASM_OPERANDS && i == 5)
+		   || (code == ASM_INPUT && i == 1))
+		  && locator_eq (XINT (x, i), XINT (y, i)))
+		break;
+#endif
+	      return 0;
+	    }
 	  break;
 
 	case 'V':
Index: gcc/config.host
===================================================================
--- a/src/gcc/config.host	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config.host	(.../branches/gcc-4_4-branch)
@@ -1,5 +1,5 @@
 # GCC host-specific configuration file.
-# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2006, 2007, 2008
+# Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2006, 2007, 2008, 2011
 # Free Software Foundation, Inc.
 
 #This file is part of GCC.
@@ -155,6 +155,10 @@
 
 # Machine-specific settings.
 case ${host} in
+  alpha*-dec-osf*)
+    out_host_hook_obj=host-osf.o
+    host_xmake_file="${host_xmake_file} alpha/x-osf"
+    ;;
   alpha*-dec-*vms*)
     host_xm_file=alpha/xm-vms.h
     host_xmake_file="${host_xmake_file} alpha/x-vms"
Index: gcc/gthr-posix.h
===================================================================
--- a/src/gcc/gthr-posix.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/gthr-posix.h	(.../branches/gcc-4_4-branch)
@@ -250,61 +250,34 @@
    calls in shared flavors of the HP-UX C library.  Most of the stubs
    have no functionality.  The details are described in the "libc cumulative
    patch" for each subversion of HP-UX 11.  There are two special interfaces
-   provided for checking whether an application is linked to a pthread
+   provided for checking whether an application is linked to a shared pthread
    library or not.  However, these interfaces aren't available in early
-   libc versions.  We also can't use pthread_once as some libc versions
-   call the init function.  So, we use pthread_create to check whether it
-   is possible to create a thread or not.  The stub implementation returns
-   the error number ENOSYS.  */
+   libpthread libraries.  We also need a test that works for archive
+   libraries.  We can't use pthread_once as some libc versions call the
+   init function.  We also can't use pthread_create or pthread_attr_init
+   as these create a thread and thereby prevent changing the default stack
+   size.  The function pthread_default_stacksize_np is available in both
+   the archive and shared versions of libpthread.   It can be used to
+   determine the default pthread stack size.  There is a stub in some
+   shared libc versions which returns a zero size if pthreads are not
+   active.  We provide an equivalent stub to handle cases where libc
+   doesn't provide one.  */
 
 #if defined(__hppa__) && defined(__hpux__)
 
-#include <errno.h>
-
 static volatile int __gthread_active = -1;
 
-static void *
-__gthread_start (void *__arg __attribute__((unused)))
-{
-  return NULL;
-}
-
-static void __gthread_active_init (void) __attribute__((noinline));
-static void
-__gthread_active_init (void)
-{
-  static pthread_mutex_t __gthread_active_mutex = PTHREAD_MUTEX_INITIALIZER;
-  pthread_t __t;
-  pthread_attr_t __a;
-  int __result;
-
-  __gthrw_(pthread_mutex_lock) (&__gthread_active_mutex);
-  if (__gthread_active < 0)
-    {
-      __gthrw_(pthread_attr_init) (&__a);
-      __gthrw_(pthread_attr_setdetachstate) (&__a, PTHREAD_CREATE_DETACHED);
-      __result = __gthrw_(pthread_create) (&__t, &__a, __gthread_start, NULL);
-      if (__result != ENOSYS)
-	__gthread_active = 1;
-      else
-	__gthread_active = 0;
-      __gthrw_(pthread_attr_destroy) (&__a);
-    }
-  __gthrw_(pthread_mutex_unlock) (&__gthread_active_mutex);
-}
-
 static inline int
 __gthread_active_p (void)
 {
   /* Avoid reading __gthread_active twice on the main code path.  */
   int __gthread_active_latest_value = __gthread_active;
+  size_t __s;
 
-  /* This test is not protected to avoid taking a lock on the main code
-     path so every update of __gthread_active in a threaded program must
-     be atomic with regard to the result of the test.  */
   if (__builtin_expect (__gthread_active_latest_value < 0, 0))
     {
-      __gthread_active_init ();
+      pthread_default_stacksize_np (0, &__s);
+      __gthread_active = __s ? 1 : 0;
       __gthread_active_latest_value = __gthread_active;
     }
 
Index: gcc/config/alpha/osf-unwind.h
===================================================================
--- a/src/gcc/config/alpha/osf-unwind.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/alpha/osf-unwind.h	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,329 @@
+/* DWARF2 EH unwinding support for Alpha Tru64.
+   Copyright (C) 2010 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with GCC; see the file COPYING3.  If not see
+<http://www.gnu.org/licenses/>.  */
+
+/* This file implements the MD_FALLBACK_FRAME_STATE_FOR macro, triggered when
+   the GCC table based unwinding process hits a frame for which no unwind info
+   has been registered. This typically occurs when raising an exception from a
+   signal handler, because the handler is actually called from the OS kernel.
+
+   The basic idea is to detect that we are indeed trying to unwind past a
+   signal handler and to fill out the GCC internal unwinding structures for
+   the OS kernel frame as if it had been directly called from the interrupted
+   context.
+
+   This is all assuming that the code to set the handler asked the kernel to
+   pass a pointer to such context information.  */
+
+/* --------------------------------------------------------------------------
+   -- Basic principles of operation:
+   --------------------------------------------------------------------------
+
+   1/ We first need a way to detect if we are trying to unwind past a signal
+      handler.
+
+   The typical method that is used on most platforms is to look at the code
+   around the return address we have and check if it matches the OS code
+   calling a handler.  To determine what this code is expected to be, get a
+   breakpoint into a real signal handler and look at the code around the
+   return address.  Depending on the library versions the pattern of the
+   signal handler is different; this is the reason why we check against more
+   than one pattern.
+
+   On this target, the return address is right after the call and every
+   instruction is 4 bytes long.  For the simple case of a null dereference in
+   a single-threaded app, it went like:
+
+   # Check that we indeed have something we expect: the instruction right
+   # before the return address is within a __sigtramp function and is a call.
+
+   [... run gdb and break at the signal handler entry ...]
+
+   (gdb) x /i $ra-4
+   <__sigtramp+160>: jsr     ra,(a3),0x3ff800d0ed4 <_fpdata+36468>
+
+   # Look at the code around that return address, and eventually observe a
+   # significantly large chunk of *constant* code right before the call:
+
+   (gdb) x /10i  $ra-44
+   <__sigtramp+120>: lda     gp,-27988(gp)
+   <__sigtramp+124>: ldq     at,-18968(gp)
+   <__sigtramp+128>: lda     t0,-1
+   <__sigtramp+132>: stq     t0,0(at)
+   <__sigtramp+136>: ldq     at,-18960(gp)
+   <__sigtramp+140>: ldl     t1,8(at)
+   <__sigtramp+144>: ldq     at,-18960(gp)
+   <__sigtramp+148>: stl     t1,12(at)
+   <__sigtramp+152>: ldq     at,-18960(gp)
+   <__sigtramp+156>: stl     t0,8(at)
+
+   # The hexadecimal equivalent that we will have to match is:
+
+   (gdb) x /10x  $ra-44
+   <__sigtramp+120>: 0x23bd92ac    0xa79db5e8    0x203fffff   0xb43c0000
+   <__sigtramp+136>: 0xa79db5f0    0xa05c0008    0xa79db5f0   0xb05c000c
+   <__sigtramp+152>: 0xa79db5f0    0xb03c0008
+
+   The problem observed on this target with this approach is that although
+   we found a constant set of instruction patterns there were some
+   gp-related offsets that made the machine code to differ from one
+   installation to another.  This problem could have been overcome by masking
+   these offsets, but we found that it would be simpler and more efficient to
+   check whether the return address was part of a signal handler, by comparing
+   it against some expected code offset from __sigtramp.
+
+   # Check that we indeed have something we expect: the instruction
+   # right before the return address is within a __sigtramp
+   # function and is a call. We also need to obtain the offset
+   # between the return address and the start address of __sigtramp.
+
+   [... run gdb and break at the signal handler entry ...]
+
+   (gdb) x /2i $ra-4
+   <__sigtramp+160>: jsr     ra,(a3),0x3ff800d0ed4 <_fpdata+36468>
+   <__sigtramp+164>: ldah    gp,16381(ra)
+
+   (gdb) p (long)$ra - (long)&__sigtramp
+   $2 = 164
+
+   --------------------------------------------------------------------------
+
+   2/ Once we know we are going through a signal handler, we need a way to
+      retrieve information about the interrupted run-time context.
+
+   On this platform, the third handler's argument is a pointer to a structure
+   describing this context (struct sigcontext *). We unfortunately have no
+   direct way to transfer this value here, so a couple of tricks are required
+   to compute it.
+
+   As documented at least in some header files (e.g. sys/machine/context.h),
+   the structure the handler gets a pointer to is located on the stack.  As of
+   today, while writing this macro, we have unfortunately not been able to
+   find a detailed description of the full stack layout at handler entry time,
+   so we'll have to resort to empirism :)
+
+   When unwinding here, we have the handler's CFA at hand, as part of the
+   current unwinding context which is one of our arguments.  We presume that
+   for each call to a signal handler by the same kernel routine, the context's
+   structure location on the stack is always at the same offset from the
+   handler's CFA, and we compute that offset from bare observation:
+
+   For the simple case of a bare null dereference in a single-threaded app,
+   computing the offset was done using GNAT like this:
+
+   # Break on the first handler's instruction, before the prologue to have the
+   # CFA in $sp, and get there:
+
+   (gdb) b *&__gnat_error_handler
+   Breakpoint 1 at 0x120016090: file init.c, line 378.
+
+   (gdb) r
+   Program received signal SIGSEGV, Segmentation fault.
+
+   (gdb) c
+   Breakpoint 1, __gnat_error_handler (sig=..., sip=..., context=...)
+
+   # The displayed argument value are meaningless because we stopped before
+   # their final "homing". We know they are passed through $a0, $a1 and $a2
+   # from the ABI, though, so ...
+
+   # Observe that $sp and the context pointer are in the same (stack) area,
+   # and compute the offset:
+
+   (gdb) p /x $sp
+   $2 = 0x11fffbc80
+
+   (gdb) p /x $a2
+   $3 = 0x11fffbcf8
+
+   (gdb) p /x (long)$a2 - (long)$sp
+   $4 = 0x78
+
+   --------------------------------------------------------------------------
+
+   3/ Once we know we are unwinding through a signal handler and have the
+      address of the structure describing the interrupted context at hand, we
+      have to fill the internal frame-state/unwind-context structures properly
+      to allow the unwinding process to proceed.
+
+   Roughly, we are provided with an *unwinding* CONTEXT, describing the state
+   of some point P in the call chain we are unwinding through.  The macro we
+   implement has to fill a "frame state" structure FS that describe the P's
+   caller state, by way of *rules* to compute its CFA, return address, and
+   **saved** registers *locations*. 
+
+   For the case we are going to deal with, the caller is some kernel code
+   calling a signal handler, and:
+
+   o The saved registers are all in the interrupted run-time context,
+
+   o The CFA is the stack pointer value when the kernel code is entered, that
+     is, the stack pointer value at the interruption point, also part of the
+     interrupted run-time context.
+
+   o We want the return address to appear as the address of the active
+     instruction at the interruption point, so that the unwinder proceeds as
+     if the interruption had been a regular call.  This address is also part
+     of the interrupted run-time context.
+
+   --
+
+   Also, note that there is an important difference between the return address
+   we need to claim for the kernel frame and the value of the return address
+   register at the interruption point.
+
+   The latter might be required to be able to unwind past the interrupted
+   routine, for instance if it is interrupted before saving the incoming
+   register value in its own frame, which may typically happen during stack
+   probes for stack-checking purposes.
+
+   It is then essential that the rules stated to locate the kernel frame
+   return address don't clobber the rules describing where is saved the return
+   address register at the interruption point, so some scratch register state
+   entry should be used for the former. We have DWARF_ALT_FRAME_RETURN_COLUMN
+   at hand exactly for that purpose.
+
+   --------------------------------------------------------------------------
+
+   4/ Depending on the context (single-threaded or multi-threaded app, ...),
+   the code calling the handler and the handler-cfa to interrupted-context
+   offset might change, so we use a simple generic data structure to track
+   the possible variants.  */
+
+/* This is the structure to wrap information about each possible sighandler
+   caller we may have to identify.  */
+
+typedef struct {
+  /* Expected return address when being called from a sighandler.  */
+  void *ra_value;
+
+  /* Offset to get to the sigcontext structure from the handler's CFA
+     when the pattern matches.  */
+  int cfa_to_context_offset;
+
+} sighandler_call_t;
+
+/* Helper macro for MD_FALLBACK_FRAME_STATE_FOR below.
+
+   Look at RA to see if it matches within a sighandler caller.
+   Set SIGCTX to the corresponding sigcontext structure (computed from
+   CFA) if it does, or to 0 otherwise.  */
+
+#define COMPUTE_SIGCONTEXT_FOR(RA,CFA,SIGCTX)				    \
+do {									    \
+  /* Define and register the applicable patterns.  */			    \
+  extern void __sigtramp (void);					    \
+									    \
+  sighandler_call_t sighandler_calls [] = {				    \
+    {__sigtramp + 164, 0x78}						    \
+  };									    \
+									    \
+  int n_patterns_to_match						    \
+    = sizeof (sighandler_calls) / sizeof (sighandler_call_t);		    \
+									    \
+  int pn;  /* pattern number  */					    \
+									    \
+  int match = 0;  /* Did last pattern match ?  */			    \
+									    \
+  /* Try to match each pattern in turn.  */				    \
+  for (pn = 0; !match && pn < n_patterns_to_match; pn ++)		    \
+    match = ((RA) == sighandler_calls[pn].ra_value);			    \
+									    \
+  (SIGCTX) = (struct sigcontext *)					    \
+    (match ? ((CFA) + sighandler_calls[pn - 1].cfa_to_context_offset) : 0); \
+} while (0);
+
+#include <sys/context_t.h>
+
+#define REG_SP  30  /* hard reg for stack pointer */
+#define REG_RA  26  /* hard reg for return address */
+
+#define MD_FALLBACK_FRAME_STATE_FOR alpha_fallback_frame_state
+
+static _Unwind_Reason_Code
+alpha_fallback_frame_state (struct _Unwind_Context *context,
+			    _Unwind_FrameState *fs)
+{
+  /* Return address and CFA of the frame we're attempting to unwind through,
+     possibly a signal handler.  */
+  void *ctx_ra  = (void *)context->ra;
+  void *ctx_cfa = (void *)context->cfa;
+
+  /* CFA of the intermediate abstract kernel frame between the interrupted
+     code and the signal handler, if we're indeed unwinding through a signal
+     handler.  */
+  void *k_cfa;
+
+  /* Pointer to the sigcontext structure pushed by the kernel when we're
+     unwinding through a signal handler.  */
+  struct sigcontext *sigctx;
+  int i;
+
+  COMPUTE_SIGCONTEXT_FOR (ctx_ra, ctx_cfa, sigctx);
+
+  if (sigctx == 0)
+    return _URC_END_OF_STACK;
+
+  /* The kernel frame's CFA is exactly the stack pointer value at the
+     interruption point.  */
+  k_cfa = (void *) sigctx->sc_regs [REG_SP];
+
+  /* State the rules to compute the CFA we have the value of: use the
+     previous CFA and offset by the difference between the two.  See
+     uw_update_context_1 for the supporting details.  */
+  fs->regs.cfa_how = CFA_REG_OFFSET;
+  fs->regs.cfa_reg = __builtin_dwarf_sp_column ();
+  fs->regs.cfa_offset = k_cfa - ctx_cfa;
+
+  /* Fill the internal frame_state structure with information stating
+     where each register of interest in the saved context can be found
+     from the CFA.  */
+
+  /* The general registers are in sigctx->sc_regs.  Leave out r31, which
+     is read-as-zero. It makes no sense restoring it, and we are going to
+     use the state entry for the kernel return address rule below.
+
+     This loop must cover at least all the callee-saved registers, and
+     we just don't bother specializing the set here.  */
+  for (i = 0; i <= 30; i ++)
+    {
+      fs->regs.reg[i].how = REG_SAVED_OFFSET;
+      fs->regs.reg[i].loc.offset
+	= (void *) &sigctx->sc_regs[i] - (void *) k_cfa;
+    }
+
+  /* Ditto for the floating point registers in sigctx->sc_fpregs.  */
+  for (i = 0; i <= 31; i ++)
+    {
+      fs->regs.reg[32+i].how = REG_SAVED_OFFSET;
+      fs->regs.reg[32+i].loc.offset
+	= (void *) &sigctx->sc_fpregs[i] - (void *) k_cfa;
+    }
+
+  /* State the rules to find the kernel's code "return address", which
+     is the address of the active instruction when the signal was caught,
+     in sigctx->sc_pc. Use DWARF_ALT_FRAME_RETURN_COLUMN since the return
+     address register is a general register and should be left alone.  */
+  fs->retaddr_column = DWARF_ALT_FRAME_RETURN_COLUMN;
+  fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].how = REG_SAVED_OFFSET;
+  fs->regs.reg[DWARF_ALT_FRAME_RETURN_COLUMN].loc.offset
+    = (void *) &sigctx->sc_pc - (void *) k_cfa;
+  fs->signal_frame = 1;
+
+  return _URC_NO_REASON;
+}
Index: gcc/config/alpha/alpha.h
===================================================================
--- a/src/gcc/config/alpha/alpha.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/alpha/alpha.h	(.../branches/gcc-4_4-branch)
@@ -913,6 +913,12 @@
 
 #define RETURN_ADDR_RTX  alpha_return_addr
 
+/* Provide a definition of DWARF_FRAME_REGNUM here so that fallback unwinders
+   can use DWARF_ALT_FRAME_RETURN_COLUMN defined below.  This is just the same
+   as the default definition in dwarf2out.c.  */
+#undef DWARF_FRAME_REGNUM
+#define DWARF_FRAME_REGNUM(REG) DBX_REGISTER_NUMBER (REG)
+
 /* Before the prologue, RA lives in $26.  */
 #define INCOMING_RETURN_ADDR_RTX  gen_rtx_REG (Pmode, 26)
 #define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (26)
Index: gcc/config/alpha/host-osf.c
===================================================================
--- a/src/gcc/config/alpha/host-osf.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/alpha/host-osf.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,147 @@
+/* Tru64 UNIX host-specific hook definitions.
+   Copyright (C) 2011 Free Software Foundation, Inc.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published
+   by the Free Software Foundation; either version 3, or (at your
+   option) any later version.
+
+   GCC is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
+   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
+   License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+#include "config.h"
+#include "system.h"
+#include "coretypes.h"
+#include <sys/mman.h>
+/* Inhibit inclusion of <sys/mount.h>, unnecessary and errors out due to
+   use of poisoned bcmp, bcopy.  */
+#define _SYS_MOUNT_H_
+#include <sys/procfs.h>
+#include "hosthooks.h"
+#include "hosthooks-def.h"
+
+
+#undef HOST_HOOKS_GT_PCH_GET_ADDRESS
+#define HOST_HOOKS_GT_PCH_GET_ADDRESS osf_gt_pch_get_address
+#undef HOST_HOOKS_GT_PCH_USE_ADDRESS
+#define HOST_HOOKS_GT_PCH_USE_ADDRESS osf_gt_pch_use_address
+
+/* The mmap ADDR parameter may be ignored without MAP_FIXED set.  Before we
+   give up, check existing mappings with ioctl(PIOCMAP) to see if the space
+   is really free.  */
+
+static void *
+mmap_fixed (void *addr, size_t len, int prot, int flags, int fd, off_t off)
+{
+  void *base;
+
+  base = mmap ((caddr_t) addr, len, prot, flags, fd, off);
+  
+  if (base != addr)
+    {
+      /* PID_MAX is SHRT_MAX on Tru64 UNIX V4.0, but INT_MAX on V5.1.
+	 Allow for both.  "/proc/" + INT_MAX + '\0'.  */
+      char pname[6+10+1];
+      int procfd, nmap;
+      prmap_t *pmap;
+      int i, overlap = 0;
+
+      if (base != (void *) MAP_FAILED)
+	munmap ((caddr_t) base, len);
+
+      /* Check if there's any mapping overlapping [addr, addr+len).  */
+
+      snprintf (pname, sizeof (pname), "/proc/%d", getpid ());
+      procfd = open (pname, O_RDONLY);
+      if (procfd == -1)
+	return ((void *) MAP_FAILED);
+      if (ioctl (procfd, PIOCNMAP, &nmap) == -1)
+	return ((void *) MAP_FAILED);
+      pmap = (prmap_t *) xmalloc (sizeof (*pmap) * (nmap+1));
+      if (ioctl (procfd, PIOCMAP, pmap) == -1)
+	return ((void *) MAP_FAILED);
+
+      /* It seems like pmap[] is sorted by address, but can we rely on
+	 that?  */
+      for (i = 0; i < nmap; i++)
+	{
+	  unsigned long map_start = (unsigned long) pmap[i].pr_vaddr;
+	  unsigned long map_end = map_start + pmap[i].pr_size;
+
+	  if ((unsigned long) addr < map_end
+	      && (unsigned long) addr+len > map_start)
+	    {
+	      overlap = 1;
+	      break;
+	    }
+	}
+      free (pmap);
+      close (procfd);
+
+      if (!overlap)
+	base = mmap ((caddr_t) addr, len, prot, flags | MAP_FIXED, fd, off);
+      else
+	base = mmap ((caddr_t) addr, len, prot, flags, fd, off);
+    }
+
+  return base;
+}
+
+/* For various ports, try to guess a fixed spot in the vm space that's
+   probably free.  Take the middle between start of text segment and
+   dynamic loader space.  See <sys/machine/addrconf.h> and Tru64 UNIX
+   Assembly Language Programmer's Guide, p.6-18, Figure 6-3: Default Layout
+   of Memory (User Program View).  */
+#define TRY_EMPTY_VM_SPACE	0x20050000000
+
+/* Determine a location where we might be able to reliably allocate
+   SIZE bytes.  FD is the PCH file, though we should return with the
+   file unmapped.  */
+
+static void *
+osf_gt_pch_get_address (size_t size, int fd)
+{
+  void *addr;
+
+  addr = mmap_fixed ((caddr_t) TRY_EMPTY_VM_SPACE, size,
+		     PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, 0);
+
+  /* If we failed the map, that means there's *no* free space.  */
+  if (addr == (void *) MAP_FAILED)
+    return NULL;
+  /* Unmap the area before returning.  */
+  munmap ((caddr_t) addr, size);
+
+  return addr;
+}
+
+/* Map SIZE bytes of FD+OFFSET at BASE.  Return 1 if we succeeded at 
+   mapping the data at BASE, -1 if we couldn't.  */
+
+static int
+osf_gt_pch_use_address (void *base, size_t size, int fd, size_t offset)
+{
+  void *addr;
+
+  /* We're called with size == 0 if we're not planning to load a PCH
+     file at all.  This allows the hook to free any static space that
+     we might have allocated at link time.  */
+  if (size == 0)
+    return -1;
+
+  addr = mmap_fixed ((caddr_t) base, size,
+		     PROT_READ | PROT_WRITE, MAP_PRIVATE, fd, offset);
+
+  return addr == base ? 1 : -1;
+}
+
+
+const struct host_hooks host_hooks = HOST_HOOKS_INITIALIZER;
Index: gcc/config/alpha/x-osf
===================================================================
--- a/src/gcc/config/alpha/x-osf	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/alpha/x-osf	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,4 @@
+host-osf.o : $(srcdir)/config/alpha/host-osf.c $(CONFIG_H) $(SYSTEM_H) \
+  coretypes.h hosthooks.h hosthooks-def.h $(HOOKS_H)
+	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) \
+		$(srcdir)/config/alpha/host-osf.c
Index: gcc/config/alpha/osf.h
===================================================================
--- a/src/gcc/config/alpha/osf.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/alpha/osf.h	(.../branches/gcc-4_4-branch)
@@ -1,6 +1,6 @@
 /* Definitions of target machine for GNU compiler, for DEC Alpha on OSF/1.
    Copyright (C) 1992, 1993, 1994, 1995, 1996, 1997, 1998, 2001, 2002, 2003,
-   2004, 2007 Free Software Foundation, Inc.
+   2004, 2007, 2010 Free Software Foundation, Inc.
    Contributed by Richard Kenner (kenner@vlsi1.ultra.nyu.edu)
 
 This file is part of GCC.
@@ -185,6 +185,14 @@
    ? (((GLOBAL) ? DW_EH_PE_indirect : 0) | DW_EH_PE_pcrel | DW_EH_PE_sdata4) \
    : DW_EH_PE_aligned)
 
+/* The Tru64 UNIX assembler warns on .lcomm with SIZE 0, so use 1 in that
+   case.  */
+#undef ASM_OUTPUT_LOCAL
+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE,ROUNDED)	\
+( fputs ("\t.lcomm ", (FILE)),				\
+  assemble_name ((FILE), (NAME)),			\
+  fprintf ((FILE), ","HOST_WIDE_INT_PRINT_UNSIGNED"\n", (SIZE) ? (SIZE) : 1))
+
 /* This is how we tell the assembler that a symbol is weak.  */
 
 #define ASM_OUTPUT_WEAK_ALIAS(FILE, NAME, VALUE)	\
@@ -210,3 +218,5 @@
 /* Handle #pragma extern_prefix.  Technically only needed for Tru64 5.x,
    but easier to manipulate preprocessor bits from here.  */
 #define TARGET_HANDLE_PRAGMA_EXTERN_PREFIX 1
+
+#define MD_UNWIND_SUPPORT "config/alpha/osf-unwind.h"
Index: gcc/config/i386/i386.h
===================================================================
--- a/src/gcc/config/i386/i386.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/i386/i386.h	(.../branches/gcc-4_4-branch)
@@ -1,6 +1,6 @@
 /* Definitions of target machine for GCC for IA-32.
    Copyright (C) 1988, 1992, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
    Free Software Foundation, Inc.
 
 This file is part of GCC.
@@ -422,7 +422,7 @@
 #define TARGET_GNU_TLS		(ix86_tls_dialect == TLS_DIALECT_GNU)
 #define TARGET_GNU2_TLS		(ix86_tls_dialect == TLS_DIALECT_GNU2)
 #define TARGET_ANY_GNU_TLS	(TARGET_GNU_TLS || TARGET_GNU2_TLS)
-#define TARGET_SUN_TLS		(ix86_tls_dialect == TLS_DIALECT_SUN)
+#define TARGET_SUN_TLS		0
 
 extern int ix86_isa_flags;
 
Index: gcc/config/i386/i386.md
===================================================================
--- a/src/gcc/config/i386/i386.md	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/i386/i386.md	(.../branches/gcc-4_4-branch)
@@ -1,6 +1,6 @@
 ;; GCC machine description for IA-32 and x86-64.
 ;; Copyright (C) 1988, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
-;; 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
+;; 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
 ;; Free Software Foundation, Inc.
 ;; Mostly by William Schelter.
 ;; x86_64 support added by Jan Hubicka
@@ -75,6 +75,7 @@
    (UNSPEC_TLS_GD		21)
    (UNSPEC_TLS_LD_BASE		22)
    (UNSPEC_TLSDESC		23)
+   (UNSPEC_TLS_IE_SUN		24)
 
    ; Other random patterns
    (UNSPEC_EH_RETURN		29)
@@ -2561,6 +2562,12 @@
   DONE;
 })
 
+(define_insn "*pushti"
+  [(set (match_operand:TI 0 "push_operand" "=<")
+	(match_operand:TI 1 "general_no_elim_operand" "riF*m"))]
+  "TARGET_64BIT"
+  "#")
+
 (define_insn "*movti_internal"
   [(set (match_operand:TI 0 "nonimmediate_operand" "=x,x,m")
 	(match_operand:TI 1 "vector_move_operand" "C,xm,x"))]
@@ -2668,6 +2675,14 @@
 	       (const_string "DI")))])
 
 (define_split
+  [(set (match_operand:TI 0 "push_operand" "")
+        (match_operand:TI 1 "general_operand" ""))]
+  "TARGET_64BIT && reload_completed
+   && !SSE_REG_P (operands[1])"
+  [(const_int 0)]
+  "ix86_split_long_move (operands); DONE;")
+
+(define_split
   [(set (match_operand:TI 0 "nonimmediate_operand" "")
         (match_operand:TI 1 "general_operand" ""))]
   "reload_completed && !SSE_REG_P (operands[0])
@@ -15875,21 +15890,6 @@
   [(set_attr "type" "multi")
    (set_attr "length" "12")])
 
-(define_insn "*tls_global_dynamic_32_sun"
-  [(set (match_operand:SI 0 "register_operand" "=a")
-	(unspec:SI [(match_operand:SI 1 "register_operand" "b")
-		    (match_operand:SI 2 "tls_symbolic_operand" "")
-		    (match_operand:SI 3 "call_insn_operand" "")]
-		    UNSPEC_TLS_GD))
-   (clobber (match_scratch:SI 4 "=d"))
-   (clobber (match_scratch:SI 5 "=c"))
-   (clobber (reg:CC FLAGS_REG))]
-  "!TARGET_64BIT && TARGET_SUN_TLS"
-  "lea{l}\t{%a2@DTLNDX(%1), %4|%4, %a2@DTLNDX[%1]}
-	push{l}\t%4\;call\t%a2@TLSPLT\;pop{l}\t%4\;nop"
-  [(set_attr "type" "multi")
-   (set_attr "length" "14")])
-
 (define_expand "tls_global_dynamic_32"
   [(parallel [(set (match_operand:SI 0 "register_operand" "")
 		   (unspec:SI
@@ -15958,20 +15958,6 @@
   [(set_attr "type" "multi")
    (set_attr "length" "11")])
 
-(define_insn "*tls_local_dynamic_base_32_sun"
-  [(set (match_operand:SI 0 "register_operand" "=a")
-	(unspec:SI [(match_operand:SI 1 "register_operand" "b")
-                    (match_operand:SI 2 "call_insn_operand" "")]
-		   UNSPEC_TLS_LD_BASE))
-   (clobber (match_scratch:SI 3 "=d"))
-   (clobber (match_scratch:SI 4 "=c"))
-   (clobber (reg:CC FLAGS_REG))]
-  "!TARGET_64BIT && TARGET_SUN_TLS"
-  "lea{l}\t{%&@TMDNX(%1), %3|%3, %&@TMDNX[%1]}
-	push{l}\t%3\;call\t%&@TLSPLT\;pop{l}\t%3"
-  [(set_attr "type" "multi")
-   (set_attr "length" "13")])
-
 (define_expand "tls_local_dynamic_base_32"
   [(parallel [(set (match_operand:SI 0 "register_operand" "")
 		   (unspec:SI [(match_dup 1) (match_dup 2)]
@@ -16097,6 +16083,18 @@
    (set_attr "memory" "load")
    (set_attr "imm_disp" "false")])
 
+;; The Sun linker took the AMD64 TLS spec literally and can only handle
+;; %rax as destination of the initial executable code sequence.
+(define_insn "tls_initial_exec_64_sun"
+  [(set (match_operand:DI 0 "register_operand" "=a")
+	(unspec:DI
+	 [(match_operand:DI 1 "tls_symbolic_operand" "")]
+	 UNSPEC_TLS_IE_SUN))
+   (clobber (reg:CC FLAGS_REG))]
+  "TARGET_64BIT && TARGET_SUN_TLS"
+  "mov{q}\t{%%fs:0, %0|%0, QWORD PTR fs:0}\n\tadd{q}\t{%a1@gottpoff(%%rip), %0|%0, %a1@gottpoff[rip]}"
+  [(set_attr "type" "multi")])
+
 ;; GNU2 TLS patterns can be split.
 
 (define_expand "tls_dynamic_gnu2_32"
Index: gcc/config/i386/sol2.h
===================================================================
--- a/src/gcc/config/i386/sol2.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/i386/sol2.h	(.../branches/gcc-4_4-branch)
@@ -91,6 +91,11 @@
       }							\
   } while (0)
 
+/* Follow Sun requirements for TLS code sequences and use Sun assembler TLS
+   syntax.  */
+#undef TARGET_SUN_TLS
+#define TARGET_SUN_TLS 1
+
 /* The Solaris assembler cannot grok .stabd directives.  */
 #undef NO_DBX_BNSYM_ENSYM
 #define NO_DBX_BNSYM_ENSYM 1
Index: gcc/config/i386/xmmintrin.h
===================================================================
--- a/src/gcc/config/i386/xmmintrin.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/i386/xmmintrin.h	(.../branches/gcc-4_4-branch)
@@ -626,13 +626,13 @@
   __sign = __builtin_ia32_pcmpgtw ((__v4hi)0LL, (__v4hi)__A);
 
   /* Convert the four words to doublewords.  */
+  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, __sign);
   __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, __sign);
-  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, __sign);
 
   /* Convert the doublewords to floating point two at a time.  */
   __zero = (__v4sf) _mm_setzero_ps ();
-  __ra = __builtin_ia32_cvtpi2ps (__zero, __hisi);
-  __rb = __builtin_ia32_cvtpi2ps (__ra, __losi);
+  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);
+  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);
 
   return (__m128) __builtin_ia32_movlhps (__ra, __rb);
 }
@@ -645,13 +645,13 @@
   __v4sf __zero, __ra, __rb;
 
   /* Convert the four words to doublewords.  */
+  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, (__v4hi)0LL);
   __hisi = (__v2si) __builtin_ia32_punpckhwd ((__v4hi)__A, (__v4hi)0LL);
-  __losi = (__v2si) __builtin_ia32_punpcklwd ((__v4hi)__A, (__v4hi)0LL);
 
   /* Convert the doublewords to floating point two at a time.  */
   __zero = (__v4sf) _mm_setzero_ps ();
-  __ra = __builtin_ia32_cvtpi2ps (__zero, __hisi);
-  __rb = __builtin_ia32_cvtpi2ps (__ra, __losi);
+  __ra = __builtin_ia32_cvtpi2ps (__zero, __losi);
+  __rb = __builtin_ia32_cvtpi2ps (__ra, __hisi);
 
   return (__m128) __builtin_ia32_movlhps (__ra, __rb);
 }
Index: gcc/config/i386/sse.md
===================================================================
--- a/src/gcc/config/i386/sse.md	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/i386/sse.md	(.../branches/gcc-4_4-branch)
@@ -4456,7 +4456,7 @@
    movsd\t{%2, %0|%0, %2}
    movlpd\t{%2, %0|%0, %2}
    movsd\t{%2, %0|%0, %2}
-   shufpd\t{$2, %2, %0|%0, %2, 2}
+   shufpd\t{$2, %1, %0|%0, %1, 2}
    movhpd\t{%H1, %0|%0, %H1}
    #
    #
@@ -4533,7 +4533,7 @@
    movsd\t{%2, %0|%0, %2}
    movlpd\t{%2, %0|%0, %2}
    movlpd\t{%2, %0|%0, %2}
-   shufpd\t{$2, %2, %0|%0, %2, 2}
+   shufpd\t{$2, %1, %0|%0, %1, 2}
    movhps\t{%H1, %0|%0, %H1}
    movhps\t{%1, %H0|%H0, %1}"
   [(set_attr "type" "ssemov,ssemov,ssemov,sselog,ssemov,ssemov")
@@ -11657,7 +11657,7 @@
   [(set (match_operand:AVXMODEF2P 0 "register_operand" "=x")
 	(unspec:AVXMODEF2P
 	  [(match_operand:AVXMODEF2P 1 "memory_operand" "m")
-	   (match_operand:AVXMODEF2P 2 "register_operand" "x")
+	   (match_operand:<avxpermvecmode> 2 "register_operand" "x")
 	   (match_dup 0)]
 	  UNSPEC_MASKLOAD))]
   "TARGET_AVX"
@@ -11669,7 +11669,7 @@
 (define_insn "avx_maskstorep<avxmodesuffixf2c><avxmodesuffix>"
   [(set (match_operand:AVXMODEF2P 0 "memory_operand" "=m")
 	(unspec:AVXMODEF2P
-	  [(match_operand:AVXMODEF2P 1 "register_operand" "x")
+	  [(match_operand:<avxpermvecmode> 1 "register_operand" "x")
 	   (match_operand:AVXMODEF2P 2 "register_operand" "x")
 	   (match_dup 0)]
 	  UNSPEC_MASKSTORE))]
Index: gcc/config/i386/avxintrin.h
===================================================================
--- a/src/gcc/config/i386/avxintrin.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/i386/avxintrin.h	(.../branches/gcc-4_4-branch)
@@ -890,55 +890,55 @@
 }
 
 extern __inline __m128d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_maskload_pd (double const *__P, __m128d __M)
+_mm_maskload_pd (double const *__P, __m128i __M)
 {
   return (__m128d) __builtin_ia32_maskloadpd ((const __v2df *)__P,
-					      (__v2df)__M);
+					      (__v2di)__M);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_maskstore_pd (double *__P, __m128d __M, __m128d __A)
+_mm_maskstore_pd (double *__P, __m128i __M, __m128d __A)
 {
-  __builtin_ia32_maskstorepd ((__v2df *)__P, (__v2df)__M, (__v2df)__A);
+  __builtin_ia32_maskstorepd ((__v2df *)__P, (__v2di)__M, (__v2df)__A);
 }
 
 extern __inline __m256d __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_maskload_pd (double const *__P, __m256d __M)
+_mm256_maskload_pd (double const *__P, __m256i __M)
 {
   return (__m256d) __builtin_ia32_maskloadpd256 ((const __v4df *)__P,
-						 (__v4df)__M);
+						 (__v4di)__M);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_maskstore_pd (double *__P, __m256d __M, __m256d __A)
+_mm256_maskstore_pd (double *__P, __m256i __M, __m256d __A)
 {
-  __builtin_ia32_maskstorepd256 ((__v4df *)__P, (__v4df)__M, (__v4df)__A);
+  __builtin_ia32_maskstorepd256 ((__v4df *)__P, (__v4di)__M, (__v4df)__A);
 }
 
 extern __inline __m128 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_maskload_ps (float const *__P, __m128 __M)
+_mm_maskload_ps (float const *__P, __m128i __M)
 {
   return (__m128) __builtin_ia32_maskloadps ((const __v4sf *)__P,
-					     (__v4sf)__M);
+					     (__v4si)__M);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm_maskstore_ps (float *__P, __m128 __M, __m128 __A)
+_mm_maskstore_ps (float *__P, __m128i __M, __m128 __A)
 {
-  __builtin_ia32_maskstoreps ((__v4sf *)__P, (__v4sf)__M, (__v4sf)__A);
+  __builtin_ia32_maskstoreps ((__v4sf *)__P, (__v4si)__M, (__v4sf)__A);
 }
 
 extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_maskload_ps (float const *__P, __m256 __M)
+_mm256_maskload_ps (float const *__P, __m256i __M)
 {
   return (__m256) __builtin_ia32_maskloadps256 ((const __v8sf *)__P,
-						(__v8sf)__M);
+						(__v8si)__M);
 }
 
 extern __inline void __attribute__((__gnu_inline__, __always_inline__, __artificial__))
-_mm256_maskstore_ps (float *__P, __m256 __M, __m256 __A)
+_mm256_maskstore_ps (float *__P, __m256i __M, __m256 __A)
 {
-  __builtin_ia32_maskstoreps256 ((__v8sf *)__P, (__v8sf)__M, (__v8sf)__A);
+  __builtin_ia32_maskstoreps256 ((__v8sf *)__P, (__v8si)__M, (__v8sf)__A);
 }
 
 extern __inline __m256 __attribute__((__gnu_inline__, __always_inline__, __artificial__))
Index: gcc/config/i386/i386.c
===================================================================
--- a/src/gcc/config/i386/i386.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/i386/i386.c	(.../branches/gcc-4_4-branch)
@@ -2999,8 +2999,6 @@
 	ix86_tls_dialect = TLS_DIALECT_GNU;
       else if (strcmp (ix86_tls_dialect_string, "gnu2") == 0)
 	ix86_tls_dialect = TLS_DIALECT_GNU2;
-      else if (strcmp (ix86_tls_dialect_string, "sun") == 0)
-	ix86_tls_dialect = TLS_DIALECT_SUN;
       else
 	error ("bad value (%s) for %stls-dialect=%s %s",
 	       ix86_tls_dialect_string, prefix, suffix, sw);
@@ -6956,7 +6954,7 @@
 	}
       if (need_temp)
 	{
-	  int i;
+	  int i, prev_size = 0;
 	  tree temp = create_tmp_var (type, "va_arg_tmp");
 
 	  /* addr = &temp; */
@@ -6968,14 +6966,32 @@
 	      rtx slot = XVECEXP (container, 0, i);
 	      rtx reg = XEXP (slot, 0);
 	      enum machine_mode mode = GET_MODE (reg);
-	      tree piece_type = lang_hooks.types.type_for_mode (mode, 1);
-	      tree addr_type = build_pointer_type (piece_type);
-	      tree daddr_type = build_pointer_type_for_mode (piece_type,
-							     ptr_mode, true);
+	      tree piece_type;
+	      tree addr_type;
+	      tree daddr_type;
 	      tree src_addr, src;
 	      int src_offset;
 	      tree dest_addr, dest;
+	      int cur_size = GET_MODE_SIZE (mode);
 
+	      gcc_assert (prev_size <= INTVAL (XEXP (slot, 1)));
+	      prev_size = INTVAL (XEXP (slot, 1));
+	      if (prev_size + cur_size > size)
+		{
+		  cur_size = size - prev_size;
+		  mode = mode_for_size (cur_size * BITS_PER_UNIT, MODE_INT, 1);
+		  if (mode == BLKmode)
+		    mode = QImode;
+		}
+	      piece_type = lang_hooks.types.type_for_mode (mode, 1);
+	      if (mode == GET_MODE (reg))
+		addr_type = build_pointer_type (piece_type);
+	      else
+		addr_type = build_pointer_type_for_mode (piece_type, ptr_mode,
+							 true);
+	      daddr_type = build_pointer_type_for_mode (piece_type, ptr_mode,
+							true);
+
 	      if (SSE_REGNO_P (REGNO (reg)))
 		{
 		  src_addr = sse_addr;
@@ -6989,14 +7005,26 @@
 	      src_addr = fold_convert (addr_type, src_addr);
 	      src_addr = fold_build2 (POINTER_PLUS_EXPR, addr_type, src_addr,
 				      size_int (src_offset));
-	      src = build_va_arg_indirect_ref (src_addr);
 
 	      dest_addr = fold_convert (daddr_type, addr);
 	      dest_addr = fold_build2 (POINTER_PLUS_EXPR, daddr_type, dest_addr,
-				       size_int (INTVAL (XEXP (slot, 1))));
-	      dest = build_va_arg_indirect_ref (dest_addr);
+				       size_int (prev_size));
+	      if (cur_size == GET_MODE_SIZE (mode))
+		{
+		  src = build_va_arg_indirect_ref (src_addr);
+		  dest = build_va_arg_indirect_ref (dest_addr);
 
-	      gimplify_assign (dest, src, pre_p);
+		  gimplify_assign (dest, src, pre_p);
+		}
+	      else
+		{
+		  tree copy
+		    = build_call_expr (implicit_built_in_decls[BUILT_IN_MEMCPY],
+				       3, dest_addr, src_addr,
+				       size_int (cur_size));
+		  gimplify_and_add (copy, pre_p);
+		}
+	      prev_size += cur_size;
 	    }
 	}
 
@@ -9839,6 +9867,17 @@
     case TLS_MODEL_INITIAL_EXEC:
       if (TARGET_64BIT)
 	{
+	  if (TARGET_SUN_TLS)
+	    {
+	      /* The Sun linker took the AMD64 TLS spec literally
+		 and can only handle %rax as destination of the
+		 initial executable code sequence.  */
+
+	      dest = gen_reg_rtx (Pmode);
+	      emit_insn (gen_tls_initial_exec_64_sun (dest, x));
+	      return dest;
+	    }
+
 	  pic = NULL;
 	  type = UNSPEC_GOTNTPOFF;
 	}
@@ -20767,12 +20806,12 @@
   V4DF_FTYPE_PCDOUBLE,
   V4SF_FTYPE_PCFLOAT,
   V2DF_FTYPE_PCDOUBLE,
-  V8SF_FTYPE_PCV8SF_V8SF,
-  V4DF_FTYPE_PCV4DF_V4DF,
+  V8SF_FTYPE_PCV8SF_V8SI,
+  V4DF_FTYPE_PCV4DF_V4DI,
   V4SF_FTYPE_V4SF_PCV2SF,
-  V4SF_FTYPE_PCV4SF_V4SF,
+  V4SF_FTYPE_PCV4SF_V4SI,
   V2DF_FTYPE_V2DF_PCDOUBLE,
-  V2DF_FTYPE_PCV2DF_V2DF,
+  V2DF_FTYPE_PCV2DF_V2DI,
   V2DI_FTYPE_PV2DI,
   VOID_FTYPE_PV2SF_V4SF,
   VOID_FTYPE_PV4DI_V4DI,
@@ -20785,10 +20824,10 @@
   VOID_FTYPE_PDOUBLE_V2DF,
   VOID_FTYPE_PDI_DI,
   VOID_FTYPE_PINT_INT,
-  VOID_FTYPE_PV8SF_V8SF_V8SF,
-  VOID_FTYPE_PV4DF_V4DF_V4DF,
-  VOID_FTYPE_PV4SF_V4SF_V4SF,
-  VOID_FTYPE_PV2DF_V2DF_V2DF
+  VOID_FTYPE_PV8SF_V8SI_V8SF,
+  VOID_FTYPE_PV4DF_V4DI_V4DF,
+  VOID_FTYPE_PV4SF_V4SI_V4SF,
+  VOID_FTYPE_PV2DF_V2DI_V2DF
 };
 
 /* Builtin types */
@@ -21019,14 +21058,14 @@
   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_movntv4df, "__builtin_ia32_movntpd256", IX86_BUILTIN_MOVNTPD256, UNKNOWN, (int) VOID_FTYPE_PDOUBLE_V4DF },
   { OPTION_MASK_ISA_AVX, CODE_FOR_avx_movntv8sf, "__builtin_ia32_movntps256", IX86_BUILTIN_MOVNTPS256, UNKNOWN, (int) VOID_FTYPE_PFLOAT_V8SF },
 
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadpd, "__builtin_ia32_maskloadpd", IX86_BUILTIN_MASKLOADPD, UNKNOWN, (int) V2DF_FTYPE_PCV2DF_V2DF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadps, "__builtin_ia32_maskloadps", IX86_BUILTIN_MASKLOADPS, UNKNOWN, (int) V4SF_FTYPE_PCV4SF_V4SF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadpd256, "__builtin_ia32_maskloadpd256", IX86_BUILTIN_MASKLOADPD256, UNKNOWN, (int) V4DF_FTYPE_PCV4DF_V4DF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadps256, "__builtin_ia32_maskloadps256", IX86_BUILTIN_MASKLOADPS256, UNKNOWN, (int) V8SF_FTYPE_PCV8SF_V8SF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstorepd, "__builtin_ia32_maskstorepd", IX86_BUILTIN_MASKSTOREPD, UNKNOWN, (int) VOID_FTYPE_PV2DF_V2DF_V2DF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstoreps, "__builtin_ia32_maskstoreps", IX86_BUILTIN_MASKSTOREPS, UNKNOWN, (int) VOID_FTYPE_PV4SF_V4SF_V4SF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstorepd256, "__builtin_ia32_maskstorepd256", IX86_BUILTIN_MASKSTOREPD256, UNKNOWN, (int) VOID_FTYPE_PV4DF_V4DF_V4DF },
-  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstoreps256, "__builtin_ia32_maskstoreps256", IX86_BUILTIN_MASKSTOREPS256, UNKNOWN, (int) VOID_FTYPE_PV8SF_V8SF_V8SF },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadpd, "__builtin_ia32_maskloadpd", IX86_BUILTIN_MASKLOADPD, UNKNOWN, (int) V2DF_FTYPE_PCV2DF_V2DI },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadps, "__builtin_ia32_maskloadps", IX86_BUILTIN_MASKLOADPS, UNKNOWN, (int) V4SF_FTYPE_PCV4SF_V4SI },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadpd256, "__builtin_ia32_maskloadpd256", IX86_BUILTIN_MASKLOADPD256, UNKNOWN, (int) V4DF_FTYPE_PCV4DF_V4DI },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskloadps256, "__builtin_ia32_maskloadps256", IX86_BUILTIN_MASKLOADPS256, UNKNOWN, (int) V8SF_FTYPE_PCV8SF_V8SI },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstorepd, "__builtin_ia32_maskstorepd", IX86_BUILTIN_MASKSTOREPD, UNKNOWN, (int) VOID_FTYPE_PV2DF_V2DI_V2DF },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstoreps, "__builtin_ia32_maskstoreps", IX86_BUILTIN_MASKSTOREPS, UNKNOWN, (int) VOID_FTYPE_PV4SF_V4SI_V4SF },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstorepd256, "__builtin_ia32_maskstorepd256", IX86_BUILTIN_MASKSTOREPD256, UNKNOWN, (int) VOID_FTYPE_PV4DF_V4DI_V4DF },
+  { OPTION_MASK_ISA_AVX, CODE_FOR_avx_maskstoreps256, "__builtin_ia32_maskstoreps256", IX86_BUILTIN_MASKSTOREPS256, UNKNOWN, (int) VOID_FTYPE_PV8SF_V8SI_V8SF },
 };
 
 /* Builtins with variable number of arguments.  */
@@ -22581,40 +22620,40 @@
     = build_pointer_type (build_type_variant (V8SF_type_node, 1, 0));
   tree pcv4df_type_node
     = build_pointer_type (build_type_variant (V4DF_type_node, 1, 0));
-  tree v8sf_ftype_pcv8sf_v8sf
+  tree v8sf_ftype_pcv8sf_v8si
     = build_function_type_list (V8SF_type_node,
-				pcv8sf_type_node, V8SF_type_node,
+				pcv8sf_type_node, V8SI_type_node,
 				NULL_TREE);
-  tree v4df_ftype_pcv4df_v4df
+  tree v4df_ftype_pcv4df_v4di
     = build_function_type_list (V4DF_type_node,
-				pcv4df_type_node, V4DF_type_node,
+				pcv4df_type_node, V4DI_type_node,
 				NULL_TREE);
-  tree v4sf_ftype_pcv4sf_v4sf
+  tree v4sf_ftype_pcv4sf_v4si
     = build_function_type_list (V4SF_type_node,
-				pcv4sf_type_node, V4SF_type_node,
+				pcv4sf_type_node, V4SI_type_node,
 				NULL_TREE);
-  tree v2df_ftype_pcv2df_v2df
+  tree v2df_ftype_pcv2df_v2di
     = build_function_type_list (V2DF_type_node,
-				pcv2df_type_node, V2DF_type_node,
+				pcv2df_type_node, V2DI_type_node,
 				NULL_TREE);
-  tree void_ftype_pv8sf_v8sf_v8sf
+  tree void_ftype_pv8sf_v8si_v8sf
     = build_function_type_list (void_type_node,
-			        pv8sf_type_node, V8SF_type_node,
+			        pv8sf_type_node, V8SI_type_node,
 				V8SF_type_node,
 				NULL_TREE);
-  tree void_ftype_pv4df_v4df_v4df
+  tree void_ftype_pv4df_v4di_v4df
     = build_function_type_list (void_type_node,
-			        pv4df_type_node, V4DF_type_node,
+			        pv4df_type_node, V4DI_type_node,
 				V4DF_type_node,
 				NULL_TREE);
-  tree void_ftype_pv4sf_v4sf_v4sf
+  tree void_ftype_pv4sf_v4si_v4sf
     = build_function_type_list (void_type_node,
-			        pv4sf_type_node, V4SF_type_node,
+			        pv4sf_type_node, V4SI_type_node,
 				V4SF_type_node,
 				NULL_TREE);
-  tree void_ftype_pv2df_v2df_v2df
+  tree void_ftype_pv2df_v2di_v2df
     = build_function_type_list (void_type_node,
-			        pv2df_type_node, V2DF_type_node,
+			        pv2df_type_node, V2DI_type_node,
 				V2DF_type_node,
 				NULL_TREE);
   tree v4df_ftype_v2df
@@ -22720,23 +22759,23 @@
 	case V2DF_FTYPE_PCDOUBLE:
 	  type = v2df_ftype_pcdouble;
 	  break;
-	case V8SF_FTYPE_PCV8SF_V8SF:
-	  type = v8sf_ftype_pcv8sf_v8sf;
+	case V8SF_FTYPE_PCV8SF_V8SI:
+	  type = v8sf_ftype_pcv8sf_v8si;
 	  break;
-	case V4DF_FTYPE_PCV4DF_V4DF:
-	  type = v4df_ftype_pcv4df_v4df;
+	case V4DF_FTYPE_PCV4DF_V4DI:
+	  type = v4df_ftype_pcv4df_v4di;
 	  break;
 	case V4SF_FTYPE_V4SF_PCV2SF:
 	  type = v4sf_ftype_v4sf_pcv2sf;
 	  break;
-	case V4SF_FTYPE_PCV4SF_V4SF:
-	  type = v4sf_ftype_pcv4sf_v4sf;
+	case V4SF_FTYPE_PCV4SF_V4SI:
+	  type = v4sf_ftype_pcv4sf_v4si;
 	  break;
 	case V2DF_FTYPE_V2DF_PCDOUBLE:
 	  type = v2df_ftype_v2df_pcdouble;
 	  break;
-	case V2DF_FTYPE_PCV2DF_V2DF:
-	  type = v2df_ftype_pcv2df_v2df;
+	case V2DF_FTYPE_PCV2DF_V2DI:
+	  type = v2df_ftype_pcv2df_v2di;
 	  break;
 	case VOID_FTYPE_PV2SF_V4SF:
 	  type = void_ftype_pv2sf_v4sf;
@@ -22771,17 +22810,17 @@
 	case VOID_FTYPE_PINT_INT:
 	  type = void_ftype_pint_int;
 	  break;
-	case VOID_FTYPE_PV8SF_V8SF_V8SF:
-	  type = void_ftype_pv8sf_v8sf_v8sf;
+	case VOID_FTYPE_PV8SF_V8SI_V8SF:
+	  type = void_ftype_pv8sf_v8si_v8sf;
 	  break;
-	case VOID_FTYPE_PV4DF_V4DF_V4DF:
-	  type = void_ftype_pv4df_v4df_v4df;
+	case VOID_FTYPE_PV4DF_V4DI_V4DF:
+	  type = void_ftype_pv4df_v4di_v4df;
 	  break;
-	case VOID_FTYPE_PV4SF_V4SF_V4SF:
-	  type = void_ftype_pv4sf_v4sf_v4sf;
+	case VOID_FTYPE_PV4SF_V4SI_V4SF:
+	  type = void_ftype_pv4sf_v4si_v4sf;
 	  break;
-	case VOID_FTYPE_PV2DF_V2DF_V2DF:
-	  type = void_ftype_pv2df_v2df_v2df;
+	case VOID_FTYPE_PV2DF_V2DI_V2DF:
+	  type = void_ftype_pv2df_v2di_v2df;
 	  break;
 	default:
 	  gcc_unreachable ();
@@ -24611,18 +24650,18 @@
       klass = load;
       memory = 1;
       break;
-    case V8SF_FTYPE_PCV8SF_V8SF:
-    case V4DF_FTYPE_PCV4DF_V4DF:
-    case V4SF_FTYPE_PCV4SF_V4SF:
-    case V2DF_FTYPE_PCV2DF_V2DF:
+    case V8SF_FTYPE_PCV8SF_V8SI:
+    case V4DF_FTYPE_PCV4DF_V4DI:
+    case V4SF_FTYPE_PCV4SF_V4SI:
+    case V2DF_FTYPE_PCV2DF_V2DI:
       nargs = 2;
       klass = load;
       memory = 0;
       break;
-    case VOID_FTYPE_PV8SF_V8SF_V8SF:
-    case VOID_FTYPE_PV4DF_V4DF_V4DF:
-    case VOID_FTYPE_PV4SF_V4SF_V4SF:
-    case VOID_FTYPE_PV2DF_V2DF_V2DF:
+    case VOID_FTYPE_PV8SF_V8SI_V8SF:
+    case VOID_FTYPE_PV4DF_V4DI_V4DF:
+    case VOID_FTYPE_PV4SF_V4SI_V4SF:
+    case VOID_FTYPE_PV2DF_V2DI_V2DF:
       nargs = 2;
       klass = store;
       /* Reserve memory operand for target.  */
Index: gcc/config/rs6000/rs6000.c
===================================================================
--- a/src/gcc/config/rs6000/rs6000.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/rs6000/rs6000.c	(.../branches/gcc-4_4-branch)
@@ -199,7 +199,7 @@
 
 /* Label number of label created for -mrelocatable, to call to so we can
    get the address of the GOT section */
-int rs6000_pic_labelno;
+static int rs6000_pic_labelno;
 
 #ifdef USING_ELFOS_H
 /* Which abi to adhere to */
@@ -15330,7 +15330,8 @@
       char buf[30];
       rtx lab, tmp1, tmp2, got;
 
-      ASM_GENERATE_INTERNAL_LABEL (buf, "LCF", rs6000_pic_labelno);
+      lab = gen_label_rtx ();
+      ASM_GENERATE_INTERNAL_LABEL (buf, "L", CODE_LABEL_NUMBER (lab));
       lab = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));
       if (flag_pic == 2)
 	got = gen_rtx_SYMBOL_REF (Pmode, toc_label_name);
@@ -15343,8 +15344,7 @@
 	  tmp2 = gen_reg_rtx (Pmode);
 	}
       emit_insn (gen_load_toc_v4_PIC_1 (lab));
-      emit_move_insn (tmp1,
-			     gen_rtx_REG (Pmode, LR_REGNO));
+      emit_move_insn (tmp1, gen_rtx_REG (Pmode, LR_REGNO));
       emit_insn (gen_load_toc_v4_PIC_3b (tmp2, tmp1, got, lab));
       emit_insn (gen_load_toc_v4_PIC_3c (dest, tmp2, got, lab));
     }
@@ -15371,8 +15371,7 @@
 	  symL = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));
 
 	  emit_insn (gen_load_toc_v4_PIC_1 (symF));
-	  emit_move_insn (dest,
-			  gen_rtx_REG (Pmode, LR_REGNO));
+	  emit_move_insn (dest, gen_rtx_REG (Pmode, LR_REGNO));
 	  emit_insn (gen_load_toc_v4_PIC_2 (temp0, dest, symL, symF));
 	}
       else
Index: gcc/config/rs6000/rs6000.md
===================================================================
--- a/src/gcc/config/rs6000/rs6000.md	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/rs6000/rs6000.md	(.../branches/gcc-4_4-branch)
@@ -10737,8 +10737,8 @@
   [(set_attr "type" "load")])
 
 (define_insn "load_toc_v4_PIC_3b"
-  [(set (match_operand:SI 0 "gpc_reg_operand" "=b")
-	(plus:SI (match_operand:SI 1 "gpc_reg_operand" "r")
+  [(set (match_operand:SI 0 "gpc_reg_operand" "=r")
+	(plus:SI (match_operand:SI 1 "gpc_reg_operand" "b")
 		 (high:SI
 		   (minus:SI (match_operand:SI 2 "symbol_ref_operand" "s")
 			     (match_operand:SI 3 "symbol_ref_operand" "s")))))]
Index: gcc/config/rs6000/sysv4.h
===================================================================
--- a/src/gcc/config/rs6000/sysv4.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/rs6000/sysv4.h	(.../branches/gcc-4_4-branch)
@@ -416,8 +416,6 @@
    Some svr4 assemblers need to also have something extra said about the
    function's return value.  We allow for that here.  */
 
-extern int rs6000_pic_labelno;
-
 /* Override elfos.h definition.  */
 #undef	ASM_DECLARE_FUNCTION_NAME
 #define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)			\
Index: gcc/config/arm/arm.c
===================================================================
--- a/src/gcc/config/arm/arm.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/arm/arm.c	(.../branches/gcc-4_4-branch)
@@ -964,6 +964,7 @@
 			     va_list_type);
   DECL_ARTIFICIAL (va_list_name) = 1;
   TYPE_NAME (va_list_type) = va_list_name;
+  TYPE_STUB_DECL (va_list_type) = va_list_name;
   /* Create the __ap field.  */
   ap_field = build_decl (FIELD_DECL, 
 			 get_identifier ("__ap"),
Index: gcc/config/pa/pa64-hpux.h
===================================================================
--- a/src/gcc/config/pa/pa64-hpux.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/pa/pa64-hpux.h	(.../branches/gcc-4_4-branch)
@@ -57,36 +57,42 @@
 #if ((TARGET_DEFAULT | TARGET_CPU_DEFAULT) & MASK_GNU_LD)
 #define LIB_SPEC \
   "%{!shared:\
-     %{!p:%{!pg:%{static|mt|pthread:%{fopenmp:%{static:-a shared} -lrt\
-		  %{static:-a archive}} -lpthread} -lc\
-	    %{static:%{!nolibdld:-a shared -ldld -a archive -lc}}}}\
+     %{!p:%{!pg:%{fopenmp:%{static:-a shared} -lrt %{static:-a archive}}\
+	    %{mt|pthread:-lpthread} -lc\
+	    %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\
+		%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\
      %{p:%{!pg:%{static:%{!mhp-ld:-a shared}%{mhp-ld:-a archive_shared}}\
 	   -lprof %{static:-a archive}\
-	   %{static|mt|pthread:%{fopenmp:%{static:-a shared} -lrt\
-	     %{static:-a archive}} -lpthread} -lc\
-	   %{static:%{!nolibdld:-a shared -ldld -a archive -lc}}}}\
+	   %{fopenmp:%{static:-a shared} -lrt %{static:-a archive}}\
+	   %{mt|pthread:-lpthread} -lc\
+	   %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\
+		%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\
      %{pg:%{static:%{!mhp-ld:-a shared}%{mhp-ld:-a archive_shared}}\
        -lgprof %{static:-a archive}\
-       %{static|mt|pthread:%{fopenmp:%{static:-a shared} -lrt\
-	 %{static:-a archive}} -lpthread} -lc\
-       %{static:%{!nolibdld:-a shared -ldld -a archive -lc}}}}\
+       %{fopenmp:%{static:-a shared} -lrt %{static:-a archive}}\
+       %{mt|pthread:-lpthread} -lc\
+       %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\
+		%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\
    %{shared:%{mt|pthread:-lpthread}}"
 #else
 #define LIB_SPEC \
   "%{!shared:\
-     %{!p:%{!pg:%{static|mt|pthread:%{fopenmp:%{static:-a shared} -lrt\
-		  %{static:-a archive}} -lpthread} -lc\
-	    %{static:%{!nolibdld:-a shared -ldld -a archive -lc}}}}\
+     %{!p:%{!pg:%{fopenmp:%{static:-a shared} -lrt %{static:-a archive}}\
+	    %{mt|pthread:-lpthread} -lc\
+	    %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\
+		%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\
      %{p:%{!pg:%{static:%{mgnu-ld:-a shared}%{!mgnu-ld:-a archive_shared}}\
 	   -lprof %{static:-a archive}\
-	   %{static|mt|pthread:%{fopenmp:%{static:-a shared} -lrt\
-	     %{static:-a archive}} -lpthread} -lc\
-	   %{static:%{!nolibdld:-a shared -ldld -a archive -lc}}}}\
+	   %{fopenmp:%{static:-a shared} -lrt %{static:-a archive}}\
+	   %{mt|pthread:-lpthread} -lc\
+	   %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\
+		%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\
      %{pg:%{static:%{mgnu-ld:-a shared}%{!mgnu-ld:-a archive_shared}}\
        -lgprof %{static:-a archive}\
-       %{static|mt|pthread:%{fopenmp:%{static:-a shared} -lrt\
-	 %{static:-a archive}} -lpthread} -lc\
-       %{static:%{!nolibdld:-a shared -ldld -a archive -lc}}}}\
+       %{fopenmp:%{static:-a shared} -lrt %{static:-a archive}}\
+       %{mt|pthread:-lpthread} -lc\
+       %{static:%{!nolibdld:-a shared -ldld -a archive -lc}\
+		%{!mt:%{!pthread:-a shared -lc -a archive}}}}}\
    %{shared:%{mt|pthread:-lpthread}}"
 #endif
 
Index: gcc/config/pa/pa.md
===================================================================
--- a/src/gcc/config/pa/pa.md	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/pa/pa.md	(.../branches/gcc-4_4-branch)
@@ -998,7 +998,7 @@
 			 (match_operand:DI 3 "arith11_operand" "rI"))
 		 (match_operand:DI 1 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub%I3 %3,%2,%%r0\;add,dc %%r0,%1,%0"
+  "sub%I3,* %3,%2,%%r0\;add,dc %%r0,%1,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -1020,7 +1020,7 @@
 			 (match_operand:DI 3 "register_operand" "r"))
 		 (match_operand:DI 1 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub %2,%3,%%r0\;add,dc %%r0,%1,%0"
+  "sub,* %2,%3,%%r0\;add,dc %%r0,%1,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -1043,7 +1043,7 @@
 			 (match_operand:DI 3 "int11_operand" "I"))
 		 (match_operand:DI 1 "register_operand" "r")))]
   "TARGET_64BIT"
-  "addi %k3,%2,%%r0\;add,dc %%r0,%1,%0"
+  "addi,* %k3,%2,%%r0\;add,dc %%r0,%1,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -1089,7 +1089,7 @@
 		  (gtu:DI (match_operand:DI 2 "register_operand" "r")
 			  (match_operand:DI 3 "arith11_operand" "rI"))))]
   "TARGET_64BIT"
-  "sub%I3 %3,%2,%%r0\;sub,db %1,%%r0,%0"
+  "sub%I3,* %3,%2,%%r0\;sub,db %1,%%r0,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -1111,7 +1111,7 @@
 				    (match_operand:DI 3 "arith11_operand" "rI")))
 		  (match_operand:DI 4 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub%I3 %3,%2,%%r0\;sub,db %1,%4,%0"
+  "sub%I3,* %3,%2,%%r0\;sub,db %1,%4,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -1133,7 +1133,7 @@
 		  (ltu:DI (match_operand:DI 2 "register_operand" "r")
 			  (match_operand:DI 3 "register_operand" "r"))))]
   "TARGET_64BIT"
-  "sub %2,%3,%%r0\;sub,db %1,%%r0,%0"
+  "sub,* %2,%3,%%r0\;sub,db %1,%%r0,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -1155,7 +1155,7 @@
 				    (match_operand:DI 3 "register_operand" "r")))
 		  (match_operand:DI 4 "register_operand" "r")))]
   "TARGET_64BIT"
-  "sub %2,%3,%%r0\;sub,db %1,%4,%0"
+  "sub,* %2,%3,%%r0\;sub,db %1,%4,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -1178,7 +1178,7 @@
 		  (leu:DI (match_operand:DI 2 "register_operand" "r")
 			  (match_operand:DI 3 "int11_operand" "I"))))]
   "TARGET_64BIT"
-  "addi %k3,%2,%%r0\;sub,db %1,%%r0,%0"
+  "addi,* %k3,%2,%%r0\;sub,db %1,%%r0,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
@@ -1200,7 +1200,7 @@
 				    (match_operand:DI 3 "int11_operand" "I")))
 		  (match_operand:DI 4 "register_operand" "r")))]
   "TARGET_64BIT"
-  "addi %k3,%2,%%r0\;sub,db %1,%4,%0"
+  "addi,* %k3,%2,%%r0\;sub,db %1,%4,%0"
   [(set_attr "type" "binary")
    (set_attr "length" "8")])
 
Index: gcc/config/pa/pa-hpux11.h
===================================================================
--- a/src/gcc/config/pa/pa-hpux11.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/pa/pa-hpux11.h	(.../branches/gcc-4_4-branch)
@@ -116,16 +116,17 @@
    -z %{mlinker-opt:-O} %{!shared:-u main -u __gcc_plt_call}\
    %{static:-a archive} %{shared:-b}"
 
-/* HP-UX 11 has posix threads.  HP libc contains pthread stubs so that
-   non-threaded applications can be linked with a thread-safe libc
-   without a subsequent loss of performance.  For more details, see
-   <http://docs.hp.com/en/1896/pthreads.html>.  */
+/* HP-UX 11 has posix threads.  HP's shared libc contains pthread stubs
+   so that non-threaded applications can be linked with a thread-safe
+   libc without a subsequent loss of performance.  For more details,
+   see <http://docs.hp.com/en/1896/pthreads.html>.  */
 #undef LIB_SPEC
 #define LIB_SPEC \
   "%{!shared:\
-     %{static|mt|pthread:%{fopenmp:%{static:-a archive_shared} -lrt\
-       %{static:-a archive}} -lpthread} -lc\
-     %{static:%{!nolibdld:-a archive_shared -ldld -a archive -lc}}}\
+     %{fopenmp:%{static:-a archive_shared} -lrt %{static:-a archive}}\
+     %{mt|pthread:-lpthread} -lc\
+     %{static:%{!nolibdld:-a archive_shared -ldld -a archive -lc}\
+       %{!mt:%{!pthread:-a shared -lc -a archive}}}}\
    %{shared:%{mt|pthread:-lpthread}}"
 
 #undef STARTFILE_SPEC
Index: gcc/config/pa/pa.c
===================================================================
--- a/src/gcc/config/pa/pa.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/pa/pa.c	(.../branches/gcc-4_4-branch)
@@ -5699,7 +5699,7 @@
 pa_secondary_reload (bool in_p, rtx x, enum reg_class rclass,
 		     enum machine_mode mode, secondary_reload_info *sri)
 {
-  int is_symbolic, regno;
+  int regno;
 
   /* Handle the easy stuff first.  */
   if (rclass == R1_REGS)
@@ -5732,6 +5732,23 @@
       return NO_REGS;
     }
 
+  /* Secondary reloads of symbolic operands require %r1 as a scratch
+     register when we're generating PIC code and when the operand isn't
+     readonly.  */
+  if (symbolic_expression_p (x))
+    {
+      if (GET_CODE (x) == HIGH)
+	x = XEXP (x, 0);
+
+      if (flag_pic || !read_only_operand (x, VOIDmode))
+	{
+	  gcc_assert (mode == SImode || mode == DImode);
+	  sri->icode = (mode == SImode ? CODE_FOR_reload_insi_r1
+			: CODE_FOR_reload_indi_r1);
+	  return NO_REGS;
+	}
+    }
+
   /* Profiling showed the PA port spends about 1.3% of its compilation
      time in true_regnum from calls inside pa_secondary_reload_class.  */
   if (regno >= FIRST_PSEUDO_REGISTER || GET_CODE (x) == SUBREG)
@@ -5790,49 +5807,8 @@
   if (regno >= 0 && regno < FIRST_PSEUDO_REGISTER
       && (REGNO_REG_CLASS (regno) == SHIFT_REGS
       && FP_REG_CLASS_P (rclass)))
-    {
-      sri->icode = in_p ? reload_in_optab[mode] : reload_out_optab[mode];
-      return NO_REGS;
-    }
+    sri->icode = in_p ? reload_in_optab[mode] : reload_out_optab[mode];
 
-  /* Secondary reloads of symbolic operands require %r1 as a scratch
-     register when we're generating PIC code and when the operand isn't
-     readonly.  */
-  if (GET_CODE (x) == HIGH)
-    x = XEXP (x, 0);
-
-  /* Profiling has showed GCC spends about 2.6% of its compilation
-     time in symbolic_operand from calls inside pa_secondary_reload_class.
-     So, we use an inline copy to avoid useless work.  */
-  switch (GET_CODE (x))
-    {
-      rtx op;
-
-      case SYMBOL_REF:
-        is_symbolic = !SYMBOL_REF_TLS_MODEL (x);
-        break;
-      case LABEL_REF:
-        is_symbolic = 1;
-        break;
-      case CONST:
-	op = XEXP (x, 0);
-	is_symbolic = (((GET_CODE (XEXP (op, 0)) == SYMBOL_REF
-			 && !SYMBOL_REF_TLS_MODEL (XEXP (op, 0)))
-			|| GET_CODE (XEXP (op, 0)) == LABEL_REF)
-		       && GET_CODE (XEXP (op, 1)) == CONST_INT);
-        break;
-      default:
-        is_symbolic = 0;
-        break;
-    }
-
-  if (is_symbolic && (flag_pic || !read_only_operand (x, VOIDmode)))
-    {
-      gcc_assert (mode == SImode || mode == DImode);
-      sri->icode = (mode == SImode ? CODE_FOR_reload_insi_r1
-		    : CODE_FOR_reload_indi_r1);
-    }
-
   return NO_REGS;
 }
 
@@ -6118,6 +6094,95 @@
     }
 }
 
+/* Return TRUE if INSN, a jump insn, has an unfilled delay slot and
+   it branches into the delay slot.  Otherwise, return FALSE.  */
+
+static bool
+branch_to_delay_slot_p (rtx insn)
+{
+  rtx jump_insn;
+
+  if (dbr_sequence_length ())
+    return FALSE;
+
+  jump_insn = next_active_insn (JUMP_LABEL (insn));
+  while (insn)
+    {
+      insn = next_active_insn (insn);
+      if (jump_insn == insn)
+	return TRUE;
+
+      /* We can't rely on the length of asms.  So, we return FALSE when
+	 the branch is followed by an asm.  */
+      if (!insn
+	  || GET_CODE (PATTERN (insn)) == ASM_INPUT
+	  || asm_noperands (PATTERN (insn)) >= 0
+	  || get_attr_length (insn) > 0)
+	break;
+    }
+
+  return FALSE;
+}
+
+/* Return TRUE if INSN, a forward jump insn, needs a nop in its delay slot.
+
+   This occurs when INSN has an unfilled delay slot and is followed
+   by an asm.  Disaster can occur if the asm is empty and the jump
+   branches into the delay slot.  So, we add a nop in the delay slot
+   when this occurs.  */
+
+static bool
+branch_needs_nop_p (rtx insn)
+{
+  rtx jump_insn;
+
+  if (dbr_sequence_length ())
+    return FALSE;
+
+  jump_insn = next_active_insn (JUMP_LABEL (insn));
+  while (insn)
+    {
+      insn = next_active_insn (insn);
+      if (!insn || jump_insn == insn)
+	return TRUE;
+
+      if (!(GET_CODE (PATTERN (insn)) == ASM_INPUT
+	   || asm_noperands (PATTERN (insn)) >= 0)
+	  && get_attr_length (insn) > 0)
+	break;
+    }
+
+  return FALSE;
+}
+
+/* Return TRUE if INSN, a forward jump insn, can use nullification
+   to skip the following instruction.  This avoids an extra cycle due
+   to a mis-predicted branch when we fall through.  */
+
+static bool
+use_skip_p (rtx insn)
+{
+  rtx jump_insn = next_active_insn (JUMP_LABEL (insn));
+
+  while (insn)
+    {
+      insn = next_active_insn (insn);
+
+      /* We can't rely on the length of asms, so we can't skip asms.  */
+      if (!insn
+	  || GET_CODE (PATTERN (insn)) == ASM_INPUT
+	  || asm_noperands (PATTERN (insn)) >= 0)
+	break;
+      if (get_attr_length (insn) == 4
+	  && jump_insn == next_active_insn (insn))
+	return TRUE;
+      if (get_attr_length (insn) > 0)
+	break;
+    }
+
+  return FALSE;
+}
+
 /* This routine handles all the normal conditional branch sequences we
    might need to generate.  It handles compare immediate vs compare
    register, nullification of delay slots, varying length branches,
@@ -6129,7 +6194,7 @@
 output_cbranch (rtx *operands, int negated, rtx insn)
 {
   static char buf[100];
-  int useskip = 0;
+  bool useskip;
   int nullify = INSN_ANNULLED_BRANCH_P (insn);
   int length = get_attr_length (insn);
   int xdelay;
@@ -6143,7 +6208,7 @@
      slot and the same branch target as this branch.  We could check
      for this but jump optimization should eliminate nop jumps.  It
      is always safe to emit a nop.  */
-  if (next_real_insn (JUMP_LABEL (insn)) == next_real_insn (insn))
+  if (branch_to_delay_slot_p (insn))
     return "nop";
 
   /* The doubleword form of the cmpib instruction doesn't have the LEU
@@ -6167,12 +6232,7 @@
   /* A forward branch over a single nullified insn can be done with a
      comclr instruction.  This avoids a single cycle penalty due to
      mis-predicted branch if we fall through (branch not taken).  */
-  if (length == 4
-      && next_real_insn (insn) != 0
-      && get_attr_length (next_real_insn (insn)) == 4
-      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))
-      && nullify)
-    useskip = 1;
+  useskip = (length == 4 && nullify) ? use_skip_p (insn) : FALSE;
 
   switch (length)
     {
@@ -6192,7 +6252,12 @@
 	if (useskip)
 	  strcat (buf, " %2,%r1,%%r0");
 	else if (nullify)
-	  strcat (buf, ",n %2,%r1,%0");
+	  {
+	    if (branch_needs_nop_p (insn))
+	      strcat (buf, ",n %2,%r1,%0%#");
+	    else
+	      strcat (buf, ",n %2,%r1,%0");
+	  }
 	else
 	  strcat (buf, " %2,%r1,%0");
 	break;
@@ -6455,7 +6520,7 @@
 output_bb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)
 {
   static char buf[100];
-  int useskip = 0;
+  bool useskip;
   int nullify = INSN_ANNULLED_BRANCH_P (insn);
   int length = get_attr_length (insn);
   int xdelay;
@@ -6465,7 +6530,7 @@
      is only used when optimizing; jump optimization should eliminate the
      jump.  But be prepared just in case.  */
 
-  if (next_real_insn (JUMP_LABEL (insn)) == next_real_insn (insn))
+  if (branch_to_delay_slot_p (insn))
     return "nop";
 
   /* If this is a long branch with its delay slot unfilled, set `nullify'
@@ -6481,14 +6546,8 @@
   /* A forward branch over a single nullified insn can be done with a
      extrs instruction.  This avoids a single cycle penalty due to
      mis-predicted branch if we fall through (branch not taken).  */
+  useskip = (length == 4 && nullify) ? use_skip_p (insn) : FALSE;
 
-  if (length == 4
-      && next_real_insn (insn) != 0
-      && get_attr_length (next_real_insn (insn)) == 4
-      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))
-      && nullify)
-    useskip = 1;
-
   switch (length)
     {
 
@@ -6511,11 +6570,21 @@
 	if (useskip)
 	  strcat (buf, " %0,%1,1,%%r0");
 	else if (nullify && negated)
-	  strcat (buf, ",n %0,%1,%3");
+	  {
+	    if (branch_needs_nop_p (insn))
+	      strcat (buf, ",n %0,%1,%3%#");
+	    else
+	      strcat (buf, ",n %0,%1,%3");
+	  }
 	else if (nullify && ! negated)
-	  strcat (buf, ",n %0,%1,%2");
+	  {
+	    if (branch_needs_nop_p (insn))
+	      strcat (buf, ",n %0,%1,%2%#");
+	    else
+	      strcat (buf, ",n %0,%1,%2");
+	  }
 	else if (! nullify && negated)
-	  strcat (buf, "%0,%1,%3");
+	  strcat (buf, " %0,%1,%3");
 	else if (! nullify && ! negated)
 	  strcat (buf, " %0,%1,%2");
 	break;
@@ -6636,7 +6705,7 @@
 output_bvb (rtx *operands ATTRIBUTE_UNUSED, int negated, rtx insn, int which)
 {
   static char buf[100];
-  int useskip = 0;
+  bool useskip;
   int nullify = INSN_ANNULLED_BRANCH_P (insn);
   int length = get_attr_length (insn);
   int xdelay;
@@ -6646,7 +6715,7 @@
      is only used when optimizing; jump optimization should eliminate the
      jump.  But be prepared just in case.  */
 
-  if (next_real_insn (JUMP_LABEL (insn)) == next_real_insn (insn))
+  if (branch_to_delay_slot_p (insn))
     return "nop";
 
   /* If this is a long branch with its delay slot unfilled, set `nullify'
@@ -6662,14 +6731,8 @@
   /* A forward branch over a single nullified insn can be done with a
      extrs instruction.  This avoids a single cycle penalty due to
      mis-predicted branch if we fall through (branch not taken).  */
+  useskip = (length == 4 && nullify) ? use_skip_p (insn) : FALSE;
 
-  if (length == 4
-      && next_real_insn (insn) != 0
-      && get_attr_length (next_real_insn (insn)) == 4
-      && JUMP_LABEL (insn) == next_nonnote_insn (next_real_insn (insn))
-      && nullify)
-    useskip = 1;
-
   switch (length)
     {
 
@@ -6692,11 +6755,21 @@
 	if (useskip)
 	  strcat (buf, "{ %0,1,%%r0| %0,%%sar,1,%%r0}");
 	else if (nullify && negated)
-	  strcat (buf, "{,n %0,%3|,n %0,%%sar,%3}");
+	  {
+	    if (branch_needs_nop_p (insn))
+	      strcat (buf, "{,n %0,%3%#|,n %0,%%sar,%3%#}");
+	    else
+	      strcat (buf, "{,n %0,%3|,n %0,%%sar,%3}");
+	  }
 	else if (nullify && ! negated)
-	  strcat (buf, "{,n %0,%2|,n %0,%%sar,%2}");
+	  {
+	    if (branch_needs_nop_p (insn))
+	      strcat (buf, "{,n %0,%2%#|,n %0,%%sar,%2%#}");
+	    else
+	      strcat (buf, "{,n %0,%2|,n %0,%%sar,%2}");
+	  }
 	else if (! nullify && negated)
-	  strcat (buf, "{%0,%3|%0,%%sar,%3}");
+	  strcat (buf, "{ %0,%3| %0,%%sar,%3}");
 	else if (! nullify && ! negated)
 	  strcat (buf, "{ %0,%2| %0,%%sar,%2}");
 	break;
@@ -6818,7 +6891,7 @@
   /* A conditional branch to the following instruction (e.g. the delay slot) is
      asking for a disaster.  Be prepared!  */
 
-  if (next_real_insn (JUMP_LABEL (insn)) == next_real_insn (insn))
+  if (branch_to_delay_slot_p (insn))
     {
       if (which_alternative == 0)
 	return "ldo %1(%0),%0";
@@ -6855,7 +6928,12 @@
 	{
 	case 4:
 	  if (nullify)
-	    return "addib,%C2,n %1,%0,%3";
+	    {
+	      if (branch_needs_nop_p (insn))
+		return "addib,%C2,n %1,%0,%3%#";
+	      else
+		return "addib,%C2,n %1,%0,%3";
+	    }
 	  else
 	    return "addib,%C2 %1,%0,%3";
       
@@ -6963,7 +7041,7 @@
   /* A conditional branch to the following instruction (e.g. the delay slot) is
      asking for a disaster.  Be prepared!  */
 
-  if (next_real_insn (JUMP_LABEL (insn)) == next_real_insn (insn))
+  if (branch_to_delay_slot_p (insn))
     {
       if (which_alternative == 0)
 	return "copy %1,%0";
@@ -7001,7 +7079,12 @@
 	{
 	case 4:
 	  if (nullify)
-	    return "movb,%C2,n %1,%0,%3";
+	    {
+	      if (branch_needs_nop_p (insn))
+		return "movb,%C2,n %1,%0,%3%#";
+	      else
+		return "movb,%C2,n %1,%0,%3";
+	    }
 	  else
 	    return "movb,%C2 %1,%0,%3";
 
Index: gcc/config/mips/iris.h
===================================================================
--- a/src/gcc/config/mips/iris.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/config/mips/iris.h	(.../branches/gcc-4_4-branch)
@@ -163,6 +163,11 @@
    library search directories.  */
 #define LINK_ELIMINATE_DUPLICATE_LDIRECTORIES 1
 
+/* The SGI linker doesn't understand constructor priorities.  */
+#ifndef IRIX_USING_GNU_LD
+#define SUPPORTS_INIT_PRIORITY 0
+#endif
+
 /* Add -g to mips.h default to avoid confusing gas with local symbols
    generated from stabs info.  */
 #undef NM_FLAGS
Index: gcc/reload1.c
===================================================================
--- a/src/gcc/reload1.c	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/reload1.c	(.../branches/gcc-4_4-branch)
@@ -6200,18 +6200,7 @@
 	      && (rld[r].nregs == max_group_size
 		  || ! reg_classes_intersect_p (rld[r].rclass, group_class)))
 	    search_equiv = rld[r].in;
-	  /* If this is an output reload from a simple move insn, look
-	     if an equivalence for the input is available.  */
-	  else if (inheritance && rld[r].in == 0 && rld[r].out != 0)
-	    {
-	      rtx set = single_set (insn);
 
-	      if (set
-		  && rtx_equal_p (rld[r].out, SET_DEST (set))
-		  && CONSTANT_P (SET_SRC (set)))
-		search_equiv = SET_SRC (set);
-	    }
-
 	  if (search_equiv)
 	    {
 	      rtx equiv
Index: gcc/gthr-posix95.h
===================================================================
--- a/src/gcc/gthr-posix95.h	(.../tags/gcc_4_4_5_release)
+++ b/src/gcc/gthr-posix95.h	(.../branches/gcc-4_4-branch)
@@ -184,61 +184,34 @@
    calls in shared flavors of the HP-UX C library.  Most of the stubs
    have no functionality.  The details are described in the "libc cumulative
    patch" for each subversion of HP-UX 11.  There are two special interfaces
-   provided for checking whether an application is linked to a pthread
+   provided for checking whether an application is linked to a shared pthread
    library or not.  However, these interfaces aren't available in early
-   libc versions.  We also can't use pthread_once as some libc versions
-   call the init function.  So, we use pthread_create to check whether it
-   is possible to create a thread or not.  The stub implementation returns
-   the error number ENOSYS.  */
+   pthread libraries.  We also need a test that works for archive
+   libraries.  We can't use pthread_once as some libc versions call the
+   init function.  We also can't use pthread_create or pthread_attr_init
+   as these create a thread and thereby prevent changing the default stack
+   size.  The function pthread_default_stacksize_np is available in both
+   the archive and shared versions of libpthread.   It can be used to
+   determine the default pthread stack size.  There is a stub in some
+   shared libc versions which returns a zero size if pthreads are not
+   active.  We provide an equivalent stub to handle cases where libc
+   doesn't provide one.  */
 
 #if defined(__hppa__) && defined(__hpux__)
 
-#include <errno.h>
-
 static volatile int __gthread_active = -1;
 
-static void *
-__gthread_start (void *arg __attribute__((unused)))
-{
-  return NULL;
-}
-
-static void __gthread_active_init (void) __attribute__((noinline));
-static void
-__gthread_active_init (void)
-{
-  static pthread_mutex_t __gthread_active_mutex = PTHREAD_MUTEX_INITIALIZER;
-  pthread_t t;
-  pthread_attr_t a;
-  int result;
-
-  __gthrw_(pthread_mutex_lock) (&__gthread_active_mutex);
-  if (__gthread_active < 0)
-    {
-      __gthrw_(pthread_attr_init) (&a);
-      __gthrw_(pthread_attr_setdetachstate) (&a, PTHREAD_CREATE_DETACHED);
-      result = __gthrw_(pthread_create) (&t, &a, __gthread_start, NULL);
-      if (result != ENOSYS)
-	__gthread_active = 1;
-      else
-	__gthread_active = 0;
-      __gthrw_(pthread_attr_destroy) (&a);
-    }
-  __gthrw_(pthread_mutex_unlock) (&__gthread_active_mutex);
-}
-
 static inline int
 __gthread_active_p (void)
 {
   /* Avoid reading __gthread_active twice on the main code path.  */
   int __gthread_active_latest_value = __gthread_active;
+  size_t __s;
 
-  /* This test is not protected to avoid taking a lock on the main code
-     path so every update of __gthread_active in a threaded program must
-     be atomic with regard to the result of the test.  */
   if (__builtin_expect (__gthread_active_latest_value < 0, 0))
     {
-      __gthread_active_init ();
+      pthread_default_stacksize_np (0, &__s);
+      __gthread_active = __s ? 1 : 0;
       __gthread_active_latest_value = __gthread_active;
     }
 
Index: libstdc++-v3/src/bitmap_allocator.cc
===================================================================
--- a/src/libstdc++-v3/src/bitmap_allocator.cc	(.../tags/gcc_4_4_5_release)
+++ b/src/libstdc++-v3/src/bitmap_allocator.cc	(.../branches/gcc-4_4-branch)
@@ -49,6 +49,7 @@
   {
 #if defined __GTHREADS
     __mutex_type& __bfl_mutex = _M_get_mutex();
+    __bfl_mutex.lock();
 #endif
     const vector_type& __free_list = _M_get_free_list();
     using __gnu_cxx::__detail::__lower_bound;
Index: libstdc++-v3/ChangeLog
===================================================================
--- a/src/libstdc++-v3/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/libstdc++-v3/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,13 @@
+2011-01-19  Graham Reed  <greed@pobox.com>
+
+	PR libstdc++/47354
+	* src/bitmap_allocator.cc (free_list::_M_get): Lock mutex.
+
+2010-12-10  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/lib/libstdc++.exp (v3-build_support): Delete
+	libtestc++.a before creation.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
Index: libstdc++-v3/testsuite/lib/libstdc++.exp
===================================================================
--- a/src/libstdc++-v3/testsuite/lib/libstdc++.exp	(.../tags/gcc_4_4_5_release)
+++ b/src/libstdc++-v3/testsuite/lib/libstdc++.exp	(.../branches/gcc-4_4-branch)
@@ -554,6 +554,15 @@
     }
 
     # Collect into libtestc++.a
+    # Delete libtestc++.a first.  Mixed 32 and 64-bit archives cannot be
+    # linked on IRIX 6.
+    # Use same procedure as gcc-dg.exp (remove-build-file).
+    if [is_remote host] {
+	# Ensure the host knows the file is gone by deleting there
+	# first.
+	remote_file host delete "./libtestc++.a"
+	}
+    remote_file build delete "./libtestc++.a"
     if  [info exists env(AR)] {
 	set ar $env(AR)
     } else {
Index: configure.ac
===================================================================
--- a/src/configure.ac	(.../tags/gcc_4_4_5_release)
+++ b/src/configure.ac	(.../branches/gcc-4_4-branch)
@@ -319,7 +319,7 @@
     # Check for target supported by gold.
     case "${target}" in
       i?86-*-* | x86_64-*-* | sparc*-*-* | powerpc*-*-*)
-        configdirs="`echo " ${configdirs} " | sed -e 's/ ld / gold /'`"
+        configdirs=`echo " ${configdirs} " | sed -e 's/ ld / gold /'`
         ;;
     esac
   fi
Index: intl/configure
===================================================================
--- a/src/intl/configure	(.../tags/gcc_4_4_5_release)
+++ b/src/intl/configure	(.../branches/gcc-4_4-branch)
@@ -8560,7 +8560,7 @@
       case "$ac_file" in */Makefile.in)
         # Adjust a relative srcdir.
         ac_dir=`echo "$ac_file"|sed 's%/[^/][^/]*$%%'`
-        ac_dir_suffix="/`echo "$ac_dir"|sed 's%^\./%%'`"
+        ac_dir_suffix=/`echo "$ac_dir"|sed 's%^\./%%'`
         ac_dots=`echo "$ac_dir_suffix"|sed 's%/[^/]*%../%g'`
         # In autoconf-2.13 it is called $ac_given_srcdir.
         # In autoconf-2.50 it is called $srcdir.
Index: intl/ChangeLog
===================================================================
--- a/src/intl/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/intl/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,8 @@
+2010-10-02  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	PR bootstrap/44621
+	* configure: Regenerate.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
Index: libgfortran/intrinsics/c99_functions.c
===================================================================
--- a/src/libgfortran/intrinsics/c99_functions.c	(.../tags/gcc_4_4_5_release)
+++ b/src/libgfortran/intrinsics/c99_functions.c	(.../branches/gcc-4_4-branch)
@@ -566,16 +566,16 @@
 
    if (x >= 0.0) 
     {
-      t = ceil(x);
-      if (t - x > 0.5)
-	t -= 1.0;
+      t = floor(x);
+      if (t - x <= -0.5)
+	t += 1.0;
       return (t);
     } 
    else 
     {
-      t = ceil(-x);
-      if (t + x > 0.5)
-	t -= 1.0;
+      t = floor(-x);
+      if (t + x <= -0.5)
+	t += 1.0;
       return (-t);
     }
 }
@@ -595,16 +595,16 @@
 
    if (x >= 0.0) 
     {
-      t = ceilf(x);
-      if (t - x > 0.5)
-	t -= 1.0;
+      t = floorf(x);
+      if (t - x <= -0.5)
+	t += 1.0;
       return (t);
     } 
    else 
     {
-      t = ceilf(-x);
-      if (t + x > 0.5)
-	t -= 1.0;
+      t = floorf(-x);
+      if (t + x <= -0.5)
+	t += 1.0;
       return (-t);
     }
 }
Index: libgfortran/ChangeLog
===================================================================
--- a/src/libgfortran/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/libgfortran/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,34 @@
+2010-11-10  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libgfortran/46373
+	Backport from mainline:
+	* io/transfer.c (data_transfer_init): Do not call flush_if_preconnected
+	if this is an internal unit.
+
+2010-11-03  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	PR libgfortran/46010
+	Backport from mainline:
+	* io/list_read.c (nml_parse_qualifier): Add additional conditions for
+	setting the end index for loop specification. Fix some whitespace.
+
+2010-10-16  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	Backport from mainline:
+	2009-03-29  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>
+
+	PR fortran/33595
+	* intrinsics/c99_functions.c (round): Use floor instead of ceil.
+	Revise checks to round up.
+	(roundf): Likewise.
+
+2010-10-06  Jerry DeLisle  <jvdelisle@gcc.gnu.org>
+
+	Backport from mainline:
+	PR libfortran/45710
+	* io/write.c (namelist_write_newline): Pad character array internal
+	unit records with spaces.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
Index: libgfortran/io/list_read.c
===================================================================
--- a/src/libgfortran/io/list_read.c	(.../tags/gcc_4_4_5_release)
+++ b/src/libgfortran/io/list_read.c	(.../branches/gcc-4_4-branch)
@@ -2077,8 +2077,10 @@
 
 		  /*  If -std=f95/2003 or an array section is specified,
 		      do not allow excess data to be processed.  */
-                  if (is_array_section == 1
-		      || compile_options.allow_std < GFC_STD_GNU)
+		  if (is_array_section == 1
+		      || !(compile_options.allow_std & GFC_STD_GNU)
+		      || !dtp->u.p.ionml->touched
+		      || dtp->u.p.ionml->type == GFC_DTYPE_DERIVED)
 		    ls[dim].end = ls[dim].start;
 		  else
 		    dtp->u.p.expanded_read = 1;
@@ -2093,12 +2095,12 @@
 	}
 
       if (is_array_section == 1 && dtp->u.p.expanded_read == 1)
-     	{
+	{
 	  int i;
 	  dtp->u.p.expanded_read = 0;
 	  for (i = 0; i < dim; i++)
 	    ls[i].end = ls[i].start;
-      	}
+	}
 
       /* Check the values of the triplet indices.  */
       if ((ls[dim].start > (ssize_t)ad[dim].ubound)
Index: libgfortran/io/transfer.c
===================================================================
--- a/src/libgfortran/io/transfer.c	(.../tags/gcc_4_4_5_release)
+++ b/src/libgfortran/io/transfer.c	(.../branches/gcc-4_4-branch)
@@ -2450,7 +2450,8 @@
     }
 
   /* Bugware for badly written mixed C-Fortran I/O.  */
-  flush_if_preconnected(dtp->u.p.current_unit->s);
+  if (!is_internal_unit (dtp))
+    flush_if_preconnected(dtp->u.p.current_unit->s);
 
   dtp->u.p.current_unit->mode = dtp->u.p.mode;
 
Index: libgfortran/io/write.c
===================================================================
--- a/src/libgfortran/io/write.c	(.../tags/gcc_4_4_5_release)
+++ b/src/libgfortran/io/write.c	(.../branches/gcc-4_4-branch)
@@ -1194,10 +1194,15 @@
   if (is_array_io (dtp))
     {
       gfc_offset record;
-      int finished, length;
+      int finished;
+      char *p;
+      int length = dtp->u.p.current_unit->bytes_left;
 
-      length = (int) dtp->u.p.current_unit->bytes_left;
-	      
+      p = write_block (dtp, length);
+      if (p == NULL)
+	return;
+      memset (p, ' ', length);
+
       /* Now that the current record has been padded out,
 	 determine where the next record in the array is. */
       record = next_array_record (dtp, dtp->u.p.current_unit->ls,
Index: ChangeLog
===================================================================
--- a/src/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,9 @@
+2010-10-02  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	PR bootstrap/44621
+	* configure.ac: Fix unportable shell quoting.
+	* configure: Regenerate.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
Index: libffi/configure
===================================================================
--- a/src/libffi/configure	(.../tags/gcc_4_4_5_release)
+++ b/src/libffi/configure	(.../branches/gcc-4_4-branch)
@@ -13301,7 +13301,7 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-asm (".ascii \"string\"");
+asm (".ascii \\"string\\"");
 int
 main ()
 {
@@ -13366,7 +13366,7 @@
 cat confdefs.h >>conftest.$ac_ext
 cat >>conftest.$ac_ext <<_ACEOF
 /* end confdefs.h.  */
-asm (".string \"string\"");
+asm (".string \\"string\\"");
 int
 main ()
 {
Index: libffi/ChangeLog
===================================================================
--- a/src/libffi/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/libffi/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,19 @@
+2010-12-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* configure.ac (libffi_cv_as_ascii_pseudo_op): Use double
+	backslashes.
+	(libffi_cv_as_string_pseudo_op): Likewise.
+	* configure: Regenerate.
+
+2010-10-01  Jakub Jelinek  <jakub@redhat.com>
+
+	* testsuite/libffi.call/many2.c: Don't use uint8_t.
+
+	PR libffi/45677
+	* src/x86/ffi64.c (ffi_prep_cif_machdep): Ensure cif->bytes is
+	a multiple of 8.
+	* testsuite/libffi.call/many2.c: New test.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
Index: libffi/src/x86/ffi64.c
===================================================================
--- a/src/libffi/src/x86/ffi64.c	(.../tags/gcc_4_4_5_release)
+++ b/src/libffi/src/x86/ffi64.c	(.../branches/gcc-4_4-branch)
@@ -321,7 +321,7 @@
 	  if (align < 8)
 	    align = 8;
 
-	  bytes = ALIGN(bytes, align);
+	  bytes = ALIGN (bytes, align);
 	  bytes += cif->arg_types[i]->size;
 	}
       else
@@ -333,7 +333,7 @@
   if (ssecount)
     flags |= 1 << 11;
   cif->flags = flags;
-  cif->bytes = bytes;
+  cif->bytes = ALIGN (bytes, 8);
 
   return FFI_OK;
 }
Index: libffi/testsuite/libffi.call/many2.c
===================================================================
--- a/src/libffi/testsuite/libffi.call/many2.c	(.../tags/gcc_4_4_5_release)
+++ b/src/libffi/testsuite/libffi.call/many2.c	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,52 @@
+/* Area:        ffi_call
+   Purpose:     Check unsigned char arguments.
+   Limitations: none.
+   PR:          PR45677.
+   Originator:  Dan Witte <dwitte@gmail.com> 20100916  */
+
+/* { dg-do run } */
+
+#include "ffitest.h"
+
+#define NARGS 7
+
+typedef unsigned char u8;
+
+__attribute__((noinline)) u8
+foo (u8 a, u8 b, u8 c, u8 d, u8 e, u8 f, u8 g)
+{
+  return a + b + c + d + e + f + g;
+}
+
+u8
+bar (u8 a, u8 b, u8 c, u8 d, u8 e, u8 f, u8 g)
+{
+  return foo (a, b, c, d, e, f, g);
+}
+
+int
+main (void)
+{
+  ffi_type *ffitypes[NARGS];
+  int i;
+  ffi_cif cif;
+  ffi_arg result = 0;
+  u8 args[NARGS];
+  void *argptrs[NARGS];
+
+  for (i = 0; i < NARGS; ++i)
+    ffitypes[i] = &ffi_type_uchar;
+
+  CHECK (ffi_prep_cif (&cif, FFI_DEFAULT_ABI, NARGS,
+		       &ffi_type_uint8, ffitypes) == FFI_OK);
+
+  for (i = 0; i < NARGS; ++i)
+    {
+      args[i] = i;
+      argptrs[i] = &args[i];
+    }
+  ffi_call (&cif, FFI_FN (bar), &result, argptrs);
+
+  CHECK (result == 21);
+  return 0;
+}
Index: libffi/configure.ac
===================================================================
--- a/src/libffi/configure.ac	(.../tags/gcc_4_4_5_release)
+++ b/src/libffi/configure.ac	(.../branches/gcc-4_4-branch)
@@ -258,7 +258,7 @@
        libffi_cv_as_ascii_pseudo_op, [
        libffi_cv_as_ascii_pseudo_op=unknown
        # Check if we have .ascii
-       AC_TRY_COMPILE([asm (".ascii \"string\"");],,
+       AC_TRY_COMPILE([asm (".ascii \\"string\\"");],,
 		       [libffi_cv_as_ascii_pseudo_op=yes],
 		       [libffi_cv_as_ascii_pseudo_op=no])
     ])
@@ -271,7 +271,7 @@
        libffi_cv_as_string_pseudo_op, [
        libffi_cv_as_string_pseudo_op=unknown
        # Check if we have .string
-       AC_TRY_COMPILE([asm (".string \"string\"");],,
+       AC_TRY_COMPILE([asm (".string \\"string\\"");],,
 		       [libffi_cv_as_string_pseudo_op=yes],
 		       [libffi_cv_as_string_pseudo_op=no])
     ])
Index: config/ChangeLog
===================================================================
--- a/src/config/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/config/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,7 @@
+2010-10-02  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>
+
+	* po.m4 (AM_PO_SUBDIRS): Fix unportable shell quoting.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
Index: config/po.m4
===================================================================
--- a/src/config/po.m4	(.../tags/gcc_4_4_5_release)
+++ b/src/config/po.m4	(.../branches/gcc-4_4-branch)
@@ -96,7 +96,7 @@
       case "$ac_file" in */Makefile.in)
         # Adjust a relative srcdir.
         ac_dir=`echo "$ac_file"|sed 's%/[^/][^/]*$%%'`
-        ac_dir_suffix="/`echo "$ac_dir"|sed 's%^\./%%'`"
+        ac_dir_suffix=/`echo "$ac_dir"|sed 's%^\./%%'`
         ac_dots=`echo "$ac_dir_suffix"|sed 's%/[^/]*%../%g'`
         # In autoconf-2.13 it is called $ac_given_srcdir.
         # In autoconf-2.50 it is called $srcdir.
Index: libjava/ChangeLog
===================================================================
--- a/src/libjava/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/libjava/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,22 @@
+2011-01-07  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2011-01-06  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/libjava.jni/jni.exp (gcj_jni_get_cxxflags_invocation):
+	Add -shared-libgcc to cxxflags for *-*-solaris*.
+	Remove -lsocket.
+
+2010-12-13  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-11-09  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* testsuite/libjava.jvmti/jvmti.exp (gcj_jvmti_compile_cxx_to_o):
+	Add -pthread on alpha*-dec-osf*.
+	* testsuite/libjava.jvmti/jvmti-interp.exp
+	(gcj_jni_compile_c_to_so): Likewise.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
Index: libjava/testsuite/libjava.jvmti/jvmti-interp.exp
===================================================================
--- a/src/libjava/testsuite/libjava.jvmti/jvmti-interp.exp	(.../tags/gcc_4_4_5_release)
+++ b/src/libjava/testsuite/libjava.jvmti/jvmti-interp.exp	(.../branches/gcc-4_4-branch)
@@ -34,6 +34,10 @@
   if { [istarget "arm*"] } {
       lappend options "additional_flags=-Wno-abi"
   }
+  # Tru64 UNIX requires <pthread.h> to be compiled with -pthread.
+  if { [istarget "alpha*-dec-osf*"] } {
+      lappend options "additional_flags=-pthread"
+  }
 
   set filename [file tail $file]
   set name [file rootname $filename]
Index: libjava/testsuite/libjava.jvmti/jvmti.exp
===================================================================
--- a/src/libjava/testsuite/libjava.jvmti/jvmti.exp	(.../tags/gcc_4_4_5_release)
+++ b/src/libjava/testsuite/libjava.jvmti/jvmti.exp	(.../branches/gcc-4_4-branch)
@@ -20,6 +20,10 @@
   if { [istarget "arm*"] } {
       lappend options "additional_flags=-Wno-abi"
   }
+  # Tru64 UNIX requires <pthread.h> to be compiled with -pthread.
+  if { [istarget "alpha*-dec-osf*"] } {
+      lappend options "additional_flags=-pthread"
+  }
 
   set x [libjava_prune_warnings \
 	   [target_compile $file $oname object $options]]
Index: libjava/testsuite/libjava.jni/jni.exp
===================================================================
--- a/src/libjava/testsuite/libjava.jni/jni.exp	(.../tags/gcc_4_4_5_release)
+++ b/src/libjava/testsuite/libjava.jni/jni.exp	(.../branches/gcc-4_4-branch)
@@ -265,8 +265,10 @@
     lappend cxxflags -shared-libgcc -lgcj -liconv
   }
 
+  # Make sure libgcc unwinder is used on 64-bit Solaris 10+/x86 rather than
+  # the libc one.
   if { [istarget "*-*-solaris*"] } {
-    lappend cxxflags "-lsocket"
+    lappend cxxflags "-shared-libgcc"
   }
 
   return $cxxflags
Index: libcpp/directives.c
===================================================================
--- a/src/libcpp/directives.c	(.../tags/gcc_4_4_5_release)
+++ b/src/libcpp/directives.c	(.../branches/gcc-4_4-branch)
@@ -276,16 +276,17 @@
 static void
 end_directive (cpp_reader *pfile, int skip_line)
 {
-  if (pfile->state.in_deferred_pragma)
-    ;
-  else if (CPP_OPTION (pfile, traditional))
+  if (CPP_OPTION (pfile, traditional))
     {
       /* Revert change of prepare_directive_trad.  */
-      pfile->state.prevent_expansion--;
+      if (!pfile->state.in_deferred_pragma)
+	pfile->state.prevent_expansion--;
 
       if (pfile->directive != &dtable[T_DEFINE])
 	_cpp_remove_overlay (pfile);
     }
+  else if (pfile->state.in_deferred_pragma)
+    ;
   /* We don't skip for an assembler #.  */
   else if (skip_line)
     {
Index: libcpp/ChangeLog
===================================================================
--- a/src/libcpp/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/libcpp/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,10 @@
+2011-11-04  Eric Botcazou  <ebotcazou@adacore.com>
+            Jakub Jelinek  <jakub@redhat.com>
+
+	PR preprocessor/39213
+	* directives.c (end_directive): Call _cpp_remove_overlay for deferred
+	pragmas as well in traditional mode.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
Index: fixincludes/ChangeLog
===================================================================
--- a/src/fixincludes/ChangeLog	(.../tags/gcc_4_4_5_release)
+++ b/src/fixincludes/ChangeLog	(.../branches/gcc-4_4-branch)
@@ -1,3 +1,22 @@
+2010-12-13  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-11-09  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	* inclhack.def (irix_pthread_init): New fix.
+	* fixincl.x: Regenerate.
+	* tests/base/pthread.h [IRIX_PTHREAD_INIT_CHECK]: New test.
+
+2010-10-21  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	Backport from mainline:
+	2010-10-20  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>
+
+	PR c++/46024
+	* inclhack.def (solaris_sys_va_list): New fix.
+	* fixincl.x: Regenerate.
+	* tests/base/sys/va_list.h: New test.
+
 2010-10-01  Release Manager
 
 	* GCC 4.4.5 released.
Index: fixincludes/tests/base/pthread.h
===================================================================
--- a/src/fixincludes/tests/base/pthread.h	(.../tags/gcc_4_4_5_release)
+++ b/src/fixincludes/tests/base/pthread.h	(.../branches/gcc-4_4-branch)
@@ -101,6 +101,13 @@
 #endif  /* PTHREAD_PAGE_SIZE_CHECK */
 
 
+#if defined( IRIX_PTHREAD_INIT_CHECK )
+#define PTHREAD_MUTEX_INITIALIZER	{ { 0 } }
+#define PTHREAD_COND_INITIALIZER	{ { 0 } }
+#define PTHREAD_RWLOCK_INITIALIZER	{ { 0 } }
+#endif  /* IRIX_PTHREAD_INIT_CHECK */
+
+
 #if defined( PTHREAD_INCOMPLETE_STRUCT_ARGUMENT_CHECK )
 extern int __sigsetjmp (struct __jmp_buf_tag *__env, int __savemask);
 #endif  /* PTHREAD_INCOMPLETE_STRUCT_ARGUMENT_CHECK */
Index: fixincludes/tests/base/sys/va_list.h
===================================================================
--- a/src/fixincludes/tests/base/sys/va_list.h	(.../tags/gcc_4_4_5_release)
+++ b/src/fixincludes/tests/base/sys/va_list.h	(.../branches/gcc-4_4-branch)
@@ -0,0 +1,22 @@
+/*  DO NOT EDIT THIS FILE.
+
+    It has been auto-edited by fixincludes from:
+
+	"fixinc/tests/inc/sys/va_list.h"
+
+    This had to be done to correct non-standard usages in the
+    original, manufacturer supplied header file.  */
+
+
+
+#if defined( SOLARIS_SYS_VA_LIST_CHECK )
+#ifdef __GNUC__
+typedef __builtin_va_list __va_list;
+#else
+#if defined(__STDC__) && !defined(__ia64)
+typedef void *__va_list;
+#else
+typedef char *__va_list;
+#endif
+#endif
+#endif  /* SOLARIS_SYS_VA_LIST_CHECK */
Index: fixincludes/fixincl.x
===================================================================
--- a/src/fixincludes/fixincl.x	(.../tags/gcc_4_4_5_release)
+++ b/src/fixincludes/fixincl.x	(.../branches/gcc-4_4-branch)
@@ -2,11 +2,11 @@
  * 
  * DO NOT EDIT THIS FILE   (fixincl.x)
  * 
- * It has been AutoGen-ed  Wednesday July 14, 2010 at 11:12:51 AM MEST
+ * It has been AutoGen-ed  Thursday December  9, 2010 at 04:55:48 PM MET
  * From the definitions    inclhack.def
  * and the template file   fixincl
  */
-/* DO NOT SVN-MERGE THIS FILE, EITHER Wed Jul 14 11:12:52 MEST 2010
+/* DO NOT SVN-MERGE THIS FILE, EITHER Thu Dec  9 16:55:48 MET 2010
  *
  * You must regenerate it.  Use the ./genfixes script.
  *
@@ -15,7 +15,7 @@
  * certain ANSI-incompatible system header files which are fixed to work
  * correctly with ANSI C and placed in a directory that GNU C will search.
  *
- * This file contains 183 fixup descriptions.
+ * This file contains 185 fixup descriptions.
  *
  * See README for more information.
  *
@@ -3862,6 +3862,43 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Irix_Pthread_Init fix
+ */
+tSCC zIrix_Pthread_InitName[] =
+     "irix_pthread_init";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zIrix_Pthread_InitList[] =
+  "pthread.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzIrix_Pthread_InitMachs[] = {
+        "mips-sgi-irix6.5",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zIrix_Pthread_InitSelect0[] =
+       "^(#define[ \t]+PTHREAD_.*_INITIALIZER[ \t]+)(\\{ 0 \\})";
+
+#define    IRIX_PTHREAD_INIT_TEST_CT  1
+static tTestDesc aIrix_Pthread_InitTests[] = {
+  { TT_EGREP,    zIrix_Pthread_InitSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Irix_Pthread_Init
+ */
+static const char* apzIrix_Pthread_InitPatch[] = {
+    "format",
+    "%1{ %2 }",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Irix_Socklen_T fix
  */
 tSCC zIrix_Socklen_TName[] =
@@ -5927,6 +5964,51 @@
 
 /* * * * * * * * * * * * * * * * * * * * * * * * * *
  *
+ *  Description of Solaris_Sys_Va_List fix
+ */
+tSCC zSolaris_Sys_Va_ListName[] =
+     "solaris_sys_va_list";
+
+/*
+ *  File name selection pattern
+ */
+tSCC zSolaris_Sys_Va_ListList[] =
+  "sys/va_list.h\0";
+/*
+ *  Machine/OS name selection pattern
+ */
+tSCC* apzSolaris_Sys_Va_ListMachs[] = {
+        "*-*-solaris2.[89]",
+        (const char*)NULL };
+
+/*
+ *  content selection pattern - do fix if pattern found
+ */
+tSCC zSolaris_Sys_Va_ListSelect0[] =
+       "#if.*__STDC__.*\n\
+typedef void \\*__va_list;\n\
+#else\n\
+typedef char \\*__va_list;\n\
+#endif";
+
+#define    SOLARIS_SYS_VA_LIST_TEST_CT  1
+static tTestDesc aSolaris_Sys_Va_ListTests[] = {
+  { TT_EGREP,    zSolaris_Sys_Va_ListSelect0, (regex_t*)NULL }, };
+
+/*
+ *  Fix Command Arguments for Solaris_Sys_Va_List
+ */
+static const char* apzSolaris_Sys_Va_ListPatch[] = {
+    "format",
+    "#ifdef __GNUC__\n\
+typedef __builtin_va_list __va_list;\n\
+#else\n\
+%0\n\
+#endif",
+    (char*)NULL };
+
+/* * * * * * * * * * * * * * * * * * * * * * * * * *
+ *
  *  Description of Statsswtch fix
  */
 tSCC zStatsswtchName[] =
@@ -7424,9 +7506,9 @@
  *
  *  List of all fixes
  */
-#define REGEX_COUNT          229
+#define REGEX_COUNT          231
 #define MACH_LIST_SIZE_LIMIT 181
-#define FIX_COUNT            183
+#define FIX_COUNT            185
 
 /*
  *  Enumerate the fixes
@@ -7526,6 +7608,7 @@
     IRIX_ASM_APOSTROPHE_FIXIDX,
     IRIX_COMPLEX_FIXIDX,
     IRIX_LIMITS_CONST_FIXIDX,
+    IRIX_PTHREAD_INIT_FIXIDX,
     IRIX_SOCKLEN_T_FIXIDX,
     IRIX_STDINT_C99_FIXIDX,
     IRIX_STDIO_VA_LIST_FIXIDX,
@@ -7578,6 +7661,7 @@
     SOLARIS_ONCE_INIT_1_FIXIDX,
     SOLARIS_ONCE_INIT_2_FIXIDX,
     SOLARIS_STDIO_TAG_FIXIDX,
+    SOLARIS_SYS_VA_LIST_FIXIDX,
     STATSSWTCH_FIXIDX,
     STDIO_STDARG_H_FIXIDX,
     STDIO_VA_LIST_FIXIDX,
@@ -8088,6 +8172,11 @@
      IRIX_LIMITS_CONST_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
      aIrix_Limits_ConstTests,   apzIrix_Limits_ConstPatch, 0 },
 
+  {  zIrix_Pthread_InitName,    zIrix_Pthread_InitList,
+     apzIrix_Pthread_InitMachs,
+     IRIX_PTHREAD_INIT_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aIrix_Pthread_InitTests,   apzIrix_Pthread_InitPatch, 0 },
+
   {  zIrix_Socklen_TName,    zIrix_Socklen_TList,
      apzIrix_Socklen_TMachs,
      IRIX_SOCKLEN_T_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
@@ -8348,6 +8437,11 @@
      SOLARIS_STDIO_TAG_TEST_CT, FD_MACH_ONLY,
      aSolaris_Stdio_TagTests,   apzSolaris_Stdio_TagPatch, 0 },
 
+  {  zSolaris_Sys_Va_ListName,    zSolaris_Sys_Va_ListList,
+     apzSolaris_Sys_Va_ListMachs,
+     SOLARIS_SYS_VA_LIST_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
+     aSolaris_Sys_Va_ListTests,   apzSolaris_Sys_Va_ListPatch, 0 },
+
   {  zStatsswtchName,    zStatsswtchList,
      apzStatsswtchMachs,
      STATSSWTCH_TEST_CT, FD_MACH_ONLY | FD_SUBROUTINE,
Index: fixincludes/inclhack.def
===================================================================
--- a/src/fixincludes/inclhack.def	(.../tags/gcc_4_4_5_release)
+++ b/src/fixincludes/inclhack.def	(.../branches/gcc-4_4-branch)
@@ -2102,6 +2102,24 @@
 
 
 /*
+ *  IRIX 6.5 PTHREAD_*_INITIALIZER need an additional level of braces in
+ *  <pthread.h>.
+ */
+fix = {
+    hackname    = irix_pthread_init;
+    files       = pthread.h;
+    select      = "^(#define[ \t]+PTHREAD_.*_INITIALIZER[ \t]+)(\\{ 0 \\})";
+
+    mach	= "mips-sgi-irix6.5";
+    c_fix       = format;
+    c_fix_arg   = "%1{ %2 }";
+    test_text   = "#define PTHREAD_MUTEX_INITIALIZER	{ 0 }\n"
+		  "#define PTHREAD_COND_INITIALIZER	{ 0 }\n"
+		  "#define PTHREAD_RWLOCK_INITIALIZER	{ 0 }";
+};
+
+
+/*
  *  IRIX 6.5.1[78] <sys/socket.h> has a broken definition of socklen_t.
  *  Various socket function prototypes use different types instead,
  *  depending on the API in use (BSD, XPG4/5), but the socklen_t
@@ -3143,6 +3161,34 @@
 
 
 /*
+ * On Solaris 8 and 9, __va_list needs to become a typedef for
+ * __builtin_va_list to make -Wmissing-format-attribute work.
+ */
+fix = {
+    hackname = solaris_sys_va_list;
+    files    = sys/va_list.h;
+    mach     = '*-*-solaris2.[89]';
+    select   = "#if.*__STDC__.*\n"
+	       "typedef void \\*__va_list;\n"
+	       "#else\n"
+	       "typedef char \\*__va_list;\n"
+	       "#endif";
+
+    c_fix    = format;
+    c_fix_arg = "#ifdef __GNUC__\n"
+		"typedef __builtin_va_list __va_list;\n"
+		"#else\n"
+		"%0\n"
+		"#endif";
+    test_text = "#if defined(__STDC__) && !defined(__ia64)\n"
+    		"typedef void *__va_list;\n"
+	        "#else\n"
+	        "typedef char *__va_list;\n"
+	        "#endif";
+};
+
+
+/*
  *  a missing semi-colon at the end of the statsswtch structure definition.
  */
 fix = {
