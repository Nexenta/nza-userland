diff -urNp gcc-4.4.4.orig/ChangeLog.cell gcc-4.4.4/ChangeLog.cell
--- a/src/ChangeLog.cell	1970-01-01
+++ b/src/ChangeLog.cell	2010-06-30
@@ -0,0 +1,651 @@
+2010-05-17  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Update to gcc-4_4-branch revision 159486.
+
+2010-04-07  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Update to gcc-4_4-branch revision 158036.
+
+2009-12-07  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+gcc/
+	2009-05-19  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	* c-typeck.c (build_binary_op): Allow % on integal vectors.
+	* doc/extend.texi (Vector Extension): Document that % is allowed too.
+
+gcc/cp/
+	2009-05-19  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	* typeck.c (build_binary_op): Allow % on integal vectors.
+
+gcc/testsuite/
+	2009-05-19  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	* gcc.dg/vector-4.c: New testcase.
+	* gcc.dg/simd-1b.c: % is now allowed for integer vectors.
+	* g++.dg/ext/vector16.C: New testcase.
+
+2009-12-07  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+gcc/
+	2009-04-22  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR C/31499
+	* c-typeck.c (process_init_element): Treat VECTOR_TYPE like ARRAY_TYPE
+	and RECORD_TYPE/UNION_TYPE.  When outputing the actual element and the
+	value is a VECTOR_CST, the element type is the element type of the
+	vector.
+
+gcc/testsuite/
+	2009-04-22  Andrew Pinski  <andrew_pinski@playstation.sony.com>
+
+	PR C/31499
+	* gcc.dg/vector-init-1.c: New testcase.
+	* gcc.dg/vector-init-2.c: New testcase.
+
+2009-12-07  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Update to gcc-4_4-branch revision 155038.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+gcc/
+	2009-12-03  Ken Werner  <ken.werner@de.ibm.com>
+
+	* config/spu/spu-elf.h (STARTFILE_SPEC): Add support for gprof
+	startup files.
+	* config/spu/spu-protos.h (spu_function_profiler): Add prototype.
+	* config/spu/spu.c (spu_function_profiler): New function.
+	* config/spu/spu.h (FUNCTION_PROFILER): Invoke
+	spu_function_profiler.
+	(NO_PROFILE_COUNTERS): Define.
+	(PROFILE_BEFORE_PROLOGUE): Likewise.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+gcc/
+	2009-12-02  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	PR middle-end/42224
+	* tree.h (int_or_pointer_precision): Remove.
+	* tree.c (int_or_pointer_precision): Remove.
+	(integer_pow2p): Use TYPE_PRECISION instead.
+	(tree_log2): Likewise.
+	(tree_floor_log2): Likewise.
+	(signed_or_unsigned_type_for): Likewise.
+	* fold-const.c (fit_double_type): Likewise.
+	* varasm.c (initializer_constant_valid_p): Likewise.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+gcc/
+	2009-11-17  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	PR tree-optimization/41857
+	* tree-ssa-address.c (move_hint_to_base): Use void pointer to
+	TYPE's address space instead of pointer to TYPE.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+gcc/
+	2009-11-17  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* reload.c (find_reloads_address): Fix typo.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+gcc/
+	2009-11-02  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	PR tree-optimization/41857
+	* tree-flow.h (rewrite_use_address): Add BASE_HINT argument.
+	* tree-ssa-loop-ivopts.c (rewrite_use_address): Pass base hint
+	to create_mem_ref.
+	* tree-ssa-address.c (move_hint_to_base): New function.
+	(most_expensive_mult_to_index): Add TYPE argument.  Use mode and
+	address space associated with TYPE.
+	(addr_to_parts): Add TYPE and BASE_HINT arguments.  Pass TYPE to
+	most_expensive_mult_to_index.  Call move_hint_to_base.
+	(create_mem_ref): Add BASE_HINT argument.  Pass BASE_HINT and
+	TYPE to addr_to_parts.
+
+gcc/testsuite/
+	2009-11-02  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	PR tree-optimization/41857
+	* gcc.target/spu/ea/pr41857.c: New file.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+gcc/testsuite/
+	2009-10-26  Ben Elliston  <bje@au.ibm.com>
+		    Michael Meissner  <meissner@linux.vnet.ibm.com>
+		    Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* gcc.target/spu/ea/ea.exp: New file.
+	* gcc.target/spu/ea/cache1.c: Likewise.
+	* gcc.target/spu/ea/cast1.c: Likewise.
+	* gcc.target/spu/ea/cast2.c: Likewise.
+	* gcc.target/spu/ea/compile1.c: Likewise.
+	* gcc.target/spu/ea/compile2.c: Likewise.
+	* gcc.target/spu/ea/cppdefine.c: Likewise.
+	* gcc.target/spu/ea/errors1.c: Likewise.
+	* gcc.target/spu/ea/errors2.c: Likewise.
+	* gcc.target/spu/ea/execute1.c: Likewise.
+	* gcc.target/spu/ea/execute2.c: Likewise.
+	* gcc.target/spu/ea/execute3.c: Likewise.
+	* gcc.target/spu/ea/ops1.c: Likewise.
+	* gcc.target/spu/ea/ops2.c: Likewise.
+	* gcc.target/spu/ea/options1.c: Likewise.
+	* gcc.target/spu/ea/test-sizes.c: Likewise.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+gcc/
+	2009-10-26  Ben Elliston  <bje@au.ibm.com>
+		    Michael Meissner  <meissner@linux.vnet.ibm.com>
+		    Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* config.gcc (spu-*-elf*): Add spu_cache.h to extra_headers.
+	* config/spu/spu_cache.h: New file.
+
+	* config/spu/cachemgr.c: New file.
+	* config/spu/cache.S: New file.
+
+	* config/spu/spu.h (ASM_OUTPUT_SYMBOL_REF): Define.
+	(ADDR_SPACE_EA): Define.
+	(TARGET_ADDR_SPACE_KEYWORDS): Define.
+	* config/spu/spu.c (EAmode): New macro.
+	(TARGET_ADDR_SPACE_POINTER_MODE): Define.
+	(TARGET_ADDR_SPACE_ADDRESS_MODE): Likewise.
+	(TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): Likewise.
+	(TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS): Likewise.
+	(TARGET_ADDR_SPACE_SUBSET_P): Likewise.
+	(TARGET_ADDR_SPACE_CONVERT): Likewise.
+	(TARGET_ASM_SELECT_SECTION): Likewise.
+	(TARGET_ASM_UNIQUE_SECTION): Likewise.
+	(TARGET_ASM_UNALIGNED_SI_OP): Likewise.
+	(TARGET_ASM_ALIGNED_DI_OP): Likewise.
+	(ea_symbol_ref): New function.
+	(spu_legitimate_constant_p): Handle __ea qualified addresses.
+	(spu_legitimate_address): Likewise.
+	(spu_addr_space_legitimate_address_p): New function.
+	(spu_addr_space_legitimize_address): Likewise.
+	(cache_fetch): New global.
+	(cache_fetch_dirty): Likewise.
+	(ea_alias_set): Likewise.
+	(ea_load_store): New function.
+	(ea_load_store_inline): Likewise.
+	(expand_ea_mem): Likewise.
+	(spu_expand_mov): Handle __ea qualified memory references.
+	(spu_addr_space_pointer_mode): New function.
+	(spu_addr_space_address_mode): Likewise.
+	(spu_addr_space_subset_p): Likewise.
+	(spu_addr_space_convert): Likewise.
+	(spu_section_type_flags): Handle "._ea" section.
+	(spu_select_section): New function.
+	(spu_unique_section): Likewise.
+	* config/spu/spu-c.c (spu_cpu_cpp_builtins): Support __EA32__
+	and __EA64__ predefined macros.
+	* config/spu/spu-elf.h (LIB_SPEC): Handle -mcache-size= and
+	-matomic-updates switches.
+
+	* config/spu/t-spu-elf (MULTILIB_OPTIONS): Define.
+	(EXTRA_MULTILIB_PARTS): Add libgcc_cachemgr.a,
+	libgcc_cachemgr_nonatomic.a, libgcc_cache8k.a, libgcc_cache16k.a,
+	libgcc_cache32k.a, libgcc_cache64k.a, libgcc_cache128k.a.
+	($(T)cachemgr.o, $(T)cachemgr_nonatomic.o): New target.
+	($(T)cache8k.o, $(T)cache16k.o, $(T)cache32k.o, $(T)cache64k.o,
+	$(T)cache128k.o): Likewise.
+	($(T)libgcc_%.a): Likewise.
+
+	* config/spu/spu.h (TARGET_DEFAULT): Add MASK_ADDRESS_SPACE_CONVERSION.
+	* config/spu/spu.opt (-mea32/-mea64): Add switches.
+	(-maddress-space-conversion): Likewise.
+	(-mcache-size=): Likewise.
+	(-matomic-updates): Likewise.
+	* doc/invoke.texi (-mea32/-mea64): Document.
+	(-maddress-space-conversion): Likewise.
+	(-mcache-size=): Likewise.
+	(-matomic-updates): Likewise.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+gcc/
+	2009-10-26  Ben Elliston  <bje@au.ibm.com>
+		    Michael Meissner  <meissner@linux.vnet.ibm.com>
+		    Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* doc/tm.texi (TARGET_ADDR_SPACE_KEYWORDS): Document.
+
+	* c-common.c (c_common_reswords): If TARGET_ADDR_SPACE_KEYWORDS is
+	defined, add the named address space keywords.
+	(c_addr_space_name): New function.
+	(complete_array_type): Preserve named address space.
+	(handle_mode_attribute): Use targetm.addr_space.valid_pointer_mode
+	instead of targetm.valid_pointer_mode.
+
+	* c-common.h (enum rid): Add RID_ADDR_SPACE_0 .. RID_ADDR_SPACE_15,
+	RID_FIRST_ADDR_SPACE and RID_LAST_ADDR_SPACE.
+	(ADDR_SPACE_KEYWORD): New macro.
+	(c_addr_space_name): Add prototype.
+
+	* c-tree.h (struct c_declspecs): Add address_space member.
+	(declspecs_add_addrspace): Add prototype.
+
+	* c-pretty-print.c (pp_c_type_qualifier_list): Handle address spaces.
+
+	* c-parser.c (c_parse_init): Add assertion.
+	(typedef enum c_id_kind): Add C_ID_ADDRSPACE.
+	(c_lex_one_token): Handle address space keywords.
+	(c_token_starts_typename): Likewise.
+	(c_token_starts_declspecs): Likewise.
+	(c_parser_declspecs): Likewise.
+	(c_parser_postfix_expression_after_paren_type): Diagnose compound
+	literal within function qualified with named address space.
+
+	* c-decl.c (diagnose_mismatched_decls): Diagnose conflicting named
+	address space qualifiers.
+	(shadow_tag_warned): Warn about useless address space qualifiers.
+	(quals_from_declspecs): Handle address space qualifiers.
+	(grokdeclarator): Likewise.
+	(build_null_declspecs): Likewise.
+	(declspecs_add_addrspace): New function.
+
+	* c-typeck.c (addr_space_superset): New function.
+	(qualify_type): Handle named address spaces.
+	(composite_type): Likewise.
+	(common_pointer_type): Likewise.
+	(comp_target_types): Likewise.
+	(build_conditional_expr): Likewise.
+	(build_c_cast): Likewise.
+	(convert_for_assignment): Likewise.
+	(build_binary_op): Likewise.
+	(pointer_diff): Handle named address spaces.  Use intermediate
+	integer type of sufficient size if required.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+gcc/
+	2009-10-26  Ben Elliston  <bje@au.ibm.com>
+		    Michael Meissner  <meissner@linux.vnet.ibm.com>
+		    Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* doc/tm.texi (TARGET_ADDR_SPACE_POINTER_MODE): Document.
+	(TARGET_ADDR_SPACE_ADDRESS_MODE): Likewise.
+	(TARGET_ADDR_SPACE_VALID_POINTER_MODE): Likewise.
+
+	* target.h (struct target_def): Add pointer_mode, address_mode,
+	and valid_pointer_mode to addr_space substructure.
+	* target-def.h (TARGET_ADDR_SPACE_POINTER_MODE): Define.
+	(TARGET_ADDR_SPACE_ADDRESS_MODE): Likewise.
+	(TARGET_ADDR_SPACE_VALID_POINTER_MODE): Likewise.
+	(TARGET_ADDR_SPACE_HOOKS): Add them.
+	* targhooks.c (target_default_pointer_address_modes_p): New function.
+	* target.h (target_default_pointer_address_modes_p): Add prototype.
+	* targhooks.c (default_addr_space_pointer_mode): New function.
+	(default_addr_space_address_mode): Likewise.
+	(default_addr_space_valid_pointer_mode): Likewise.
+	* targhooks.h (default_addr_space_pointer_mode): Add prototype.
+	(default_addr_space_address_mode): Likewise.
+	(default_addr_space_valid_pointer_mode): Likewise.
+	* output.h (default_valid_pointer_mode): Move to ...
+	* targhooks.h (default_valid_pointer_mode): ... here.
+	* varasm.c (default_valid_pointer_mode): Move to ...
+	* targhooks.c (default_valid_pointer_mode): ... here.
+
+	* varasm.c (output_constant): Use targetm.addr_space.valid_pointer_mode
+	instead of targetm.valid_pointer_mode.
+
+	* fold-const.c (fit_double_type): Use int_or_pointer_precision.
+	* tree.c (integer_pow2p): Likewise.
+	(tree_log2): Likewise.
+	(tree_floor_log2): Likewise.
+	(signed_or_unsigned_type_for): Support pointer type of different size.
+	(int_or_pointer_precision): New function.
+	* tree.h (int_or_pointer_precision): Add prototype.
+	* stor-layout.c (layout_type): Set TYPE_PRECISION for offset types.
+	* varasm.c (initializer_constant_valid_p): Use TYPE_PRECISION of
+	incoming pointer type instead of POINTER_SIZE.
+
+	* tree.c (build_pointer_type): Use appropriate pointer mode
+	instead of ptr_mode.
+	(build_reference_type): Likewise.
+	* expr.c (store_expr): Likewise.
+	(expand_expr_addr_expr): Likewise.
+	* cfgexpand.c (expand_debug_expr): Likewise.
+	
+	* auto-inc-dec.c: Include "target.h".
+	(try_merge): Use appropriate address mode instead of Pmode.
+	(find_inc): Likewise.
+	* combine.c (find_split_point): Likewise.
+	* cselib.c (cselib_record_sets): Likewise.
+	* dse.c (replace_inc_dec): Likewise.
+	(canon_address): Likewise.
+	(count_uses): Likewise.
+	(add_uses): Likewise.
+	(add_stores): Likewise.
+	* emit-rtl.c: Include "target.h".
+	(adjust_address_1): Use appropriate address mode instead of Pmode.
+	(offset_address): Likewise.
+	* explow.c (break_out_memory_refs): Likewise.
+	(memory_address_addr_space): Likewise.
+	(promote_mode): Likewise.
+	* expr.c (move_by_pieces): Likewise.
+	(emit_block_move_via_loop): Likewise.
+	(store_by_pieces): Likewise.
+	(store_by_pieces_1): Likewise.
+	(expand_assignment): Likewise.
+	(store_constructor): Likewise.
+	(expand_expr_addr_expr): Likewise.
+	(expand_expr_real_1): Likewise.
+	* cfgexpand.c (expand_debug_expr): Likewise.
+	* ifcvt.c (noce_try_cmove_arith): Likewise.
+	* regrename.c (kill_autoinc_value): Likewise.
+	* regmove.c (try_auto_increment): Likewise.
+	* reload.c (find_reloads): Likewise.
+	(find_reloads_address): Likewise.
+	(find_reloads_address_1): Likewise.
+	* sched-deps.c: Include "target.h".
+	(sched_analyze_1): Use appropriate address mode instead of Pmode.
+	(sched_analyze_2): Likewise.
+	* sel-sched-dump.c: Include "target.h".
+	(debug_mem_addr_value): Use appropriate address mode instead of Pmode.
+	* stor-layout.c (layout_type): Likewise.
+	* tree-ssa-loop-ivopts.c (produce_memory_decl_rtl): Likewise.
+	(multiplier_allowed_in_address_p): Likewise.
+	(get_address_cost): Likewise.
+	* varasm.c (make_decl_rtl): Likewise.
+	
+	* expr.c (expand_assignment): Always convert offsets to appropriate
+	address mode.
+	(store_expr): Likewise.
+	(store_constructor): Likewise.
+	(expand_expr_real_1): Likewise.
+
+	* reload.h (form_sum): Add MODE argument.
+	* reload.c (form_sum): Add MODE argument, use it instead of Pmode.
+	Update recursive calls.
+	(subst_indexed_address): Update calls to form_sum.
+	
+	* tree-flow.h (addr_for_mem_ref): Add ADDRSPACE argument.
+	* tree-ssa-address.c: Include "target.h".
+	(templates): Replace by ...
+	(mem_addr_template_list): ... this new vector.
+	(TEMPL_IDX): Handle address space numbers.
+	(gen_addr_rtx): Add address mode argument, use it instead of Pmode.
+	(addr_for_mem_ref): Add ADDRSPACE argument.  Use per-address-space
+	instead of global cache.  Update call to gen_addr_rtx.
+	(valid_mem_ref_p): Update call to addr_for_mem_ref.
+	* expr.c (expand_expr_real_1): Update call to addr_for_mem_ref.
+	
+	* rtl.h (convert_memory_address_addr_space): Add prototype.
+	(convert_memory_address): Define as macro.
+	* explow.c (convert_memory_address): Rename to ...
+	(convert_memory_address_addr_space): ... this.  Add ADDRSPACE argument.
+	Use appropriate pointer and address modes instead of ptr_mode / Pmode.
+	Update recursive calls.
+	(memory_address_addr_space): Call convert_memory_address_addr_space.
+	* expmed.c (make_tree): Likewise.
+	* expr.c (expand_assignment): Likewise.
+	(expand_expr_addr_expr_1): Likewise.  Also, add ADDRSPACE argument.
+	(expand_expr_addr_expr): Likewise.  Also, update call.
+
+	* alias.c (find_base_value): Guard pointer size optimizations.
+	(find_base_term): Likewise.
+	* rtlanal.c (nonzero_bits1): Likewise.
+	(num_sign_bit_copies1): Likewise.
+	* simplify-rtx.c (simplify_unary_operation_1): Likewise.
+
+	* Makefile.in (tree-ssa-address.o): Add $(TARGET_H) dependency.
+	(emit-rtl.o): Likewise.
+	(auto-inc-dec.o): Likewise.
+	(sched-deps.o): Likewise.
+
+	2009-08-24  Olivier Hainque  <hainque@adacore.com>
+
+	* convert.c (convert_to_integer): Don't assume an input pointer is
+	POINTER_SIZE wide.  Fetch from the type instead.
+
+	2009-07-27  Olivier Hainque  <hainque@adacore.com>
+		    Douglas B Rupp  <rupp@gnat.com>
+
+	* convert.c (convert_to_pointer): Don't assume the target
+	pointer type is POINTER_SIZE long. Fetch its precision instead.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+gcc/
+	2009-10-26  Ben Elliston  <bje@au.ibm.com>
+		    Michael Meissner  <meissner@linux.vnet.ibm.com>
+		    Ulrich Weigand  <uweigand@de.ibm.com>
+
+	* doc/extend.texi (Named Address Spaces): New section.
+	* coretypes.h (addr_space_t): New type.
+	(ADDR_SPACE_GENERIC): New define.
+	(ADDR_SPACE_GENERIC_P): New macro.
+
+	* doc/tm.texi (Named Address Spaces): New section.
+	(TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): Document.
+	(TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS): Document.
+	(TARGET_ADDR_SPACE_SUBSET_P): Document.
+	(TARGET_ADDR_SPACE_CONVERT): Document.
+	* target.h (struct gcc_target): Add addr_space substructure.
+	* target-def.h (TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): Define.
+	(TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS): Likewise.
+	(TARGET_ADDR_SPACE_SUBSET_P): Likewise.
+	(TARGET_ADDR_SPACE_CONVERT): Likewise.
+	(TARGET_ADDR_SPACE_HOOKS): Likewise.
+	(TARGET_INITIALIZER): Initialize addr_space hooks.
+	* targhooks.c (default_addr_space_legitimate_address_p): New function.
+	(default_addr_space_legitimize_address): Likewise.
+	(default_addr_space_subset_p): Likewise.
+	(default_addr_space_convert): Likewise.
+	* targhooks.h (default_addr_space_legitimate_address_p): Add prototype.
+	(default_addr_space_legitimize_address): Likewise.
+	(default_addr_space_subset_p): Likewise.
+	(default_addr_space_convert): Likewise.
+
+	* doc/rtl.texi (MEM_ADDR_SPACE): Document.
+	* rtl.h (mem_attrs): Add ADDRSPACE memory attribute.
+	(MEM_ADDR_SPACE): New macro.
+	* emit-rtl.c (get_mem_attrs): Add ADDRSPACE argument and set
+	address space memory attribute.
+	(mem_attrs_htab_hash): Handle address space memory attribute.
+	(mem_attrs_htab_eq): Likewise.
+	(set_mem_attributes_minus_bitpos): Likewise.
+	(set_mem_attrs_from_reg): Likewise.
+	(set_mem_alias_set): Likewise.
+	(set_mem_align): Likewise.
+	(set_mem_expr): Likewise.
+	(set_mem_offset): Likewise.
+	(set_mem_size): Likewise.
+	(adjust_address_1): Likewise.
+	(offset_address): Likewise.
+	(widen_memoy_address): Likewise.
+	(get_spill_slot_decl): Likewise.
+	(set_mem_attrs_for_spill): Likewise.
+	(set_mem_addr_space): New function.
+	* emit-rtl.h (set_mem_addr_space): Add prototype.
+	* print-rtl.c (print_rtx): Print address space memory attribute.
+	* expr.c (expand_expr_real_1): Set address space memory attribute
+	of generated MEM RTXes as appropriate.
+	* tree-ssa-loop-ivopts.c (produce_memory_decl_rtl): Likewise.
+
+	* tree.h (struct tree_base): Add address_space bitfield.  Reduce
+	size of "spare" bitfield.
+	(TYPE_ADDR_SPACE): New macro.
+	(ENCODE_QUAL_ADDR_SPACE): Likewise.
+	(DECODE_QUAL_ADDR_SPACE): Likewise.
+	(CLEAR_QUAL_ADDR_SPACE): Likewise.
+	(KEEP_QUAL_ADDR_SPACE): Likewise.
+	(TYPE_QUALS): Encode type address space.
+	(TYPE_QUALS_NO_ADDR_SPACE): New macro.
+	* tree.c (set_type_quals): Set type address space.
+	(build_array_type): Inherit array address space from element type.
+	* print-tree.c (print_node_brief): Print type address space.
+	(print_node): Likewise.
+	* tree-pretty-print.c (dump_generic_node): Likewise.
+
+	* explow.c (memory_address): Rename to ...
+	(memory_address_addr_space): ... this.  Add ADDRSPACE argument.
+	Use address-space aware variants of memory address routines.
+	* recog.c (memory_address_p): Rename to ...
+	(memory_address_addr_space_p): ... this.  Add ADDSPACE argument.
+	Use address-space aware variants of memory address routines.
+	(offsettable_address_p): Rename to ...
+	(offsettable_address_addr_space_p): ... this.  Add ADDRSPACE argument.
+	Use address-space aware variants of memory address routines.
+	* reload.c (strict_memory_address_p): Rename to ...
+	(strict_memory_address_addr_space_p): ... this.  Add ADDSPACE argument.
+	Use address-space aware variants of memory address routines.
+	(maybe_memory_address_p): Rename to ...
+	(maybe_memory_address_addr_space_p): ... this.  Add ADDSPACE argument.
+	Use address-space aware variants of memory address routines.
+	* expr.h (memory_address_addr_space): Add prototype.
+	(memory_address): Define as macro.
+	* recog.h (memory_address_addr_space_p): Add prototype.
+	(memory_address_p): Define as macro.
+	(offsettable_address_addr_space_p): Add prototype.
+	(offsettable_address_p): Define as macro.
+	(strict_memory_address_addr_space_p): Add prototype.
+	(strict_memory_address_p): Define as macro.
+
+	* combine.c (find_split_point): Use address-space aware variants
+	of memory address routines.
+	* emit-rtl.c (operand_subword): Likewise.
+	(change_address_1): Likewise.
+	(adjust_address_1): Likewise.
+	(offset_address): Likewise.
+	* expr.c (emit_move_insn): Likewise.
+	(expand_expr_real_1): Likewise.
+	* recog.c (verify_changes): Likewise.
+	(general_operand): Likewise.
+	(offsettable_memref_p): Likewise.
+	(offsettable_nonstrict_memref_p): Likewise.
+	(constrain_operands): Likewise.
+	* reload.c (get_secondary_mem): Likewise.
+	(find_reloads_toplev): Likewise.
+	(find_reloads_address): Likewise.
+	(find_reloads_subreg_address): Likewise.
+	* reload1.c (reload): Likewise.
+	* rtlhooks.c (gen_lowpart_if_possible): Likewise.
+	* rtl.h (address_cost): Add ADDRSPACE argument.
+	* rtlanal.c (address_cost): Add ADDRSPACE argument.  Use address-space
+	aware variant of memory address routines.
+	* tree-ssa-loop-ivopts.c (computation_cost): Update address_cost call.
+	* fwprop.c (should_replace_address): Add ADDRSPACE argument.
+	Use address-space aware variant of memory address routines.
+	(propagate_rtx_1): Update call to should_replace_address.
+	* tree-flow.h (multiplier_allowed_in_address_p): Add ADDRSPACE
+	argument.
+	* tree-ssa-loop-ivopts.c (multiplier_allowed_in_address_p): Add
+	ADDRSPACE argument.  Use per-address-space instead of global cache.
+	Use address-space aware variant of memory address routines.
+	(get_address_cost): Likewise.
+	(get_computation_cost_at): Update calls.
+	* tree-ssa-address.c (valid_mem_ref_p): Add ADDRSPACE argument.
+	Use address-space aware variant of memory address routines.
+	(create_mem_ref_raw): Update call to valid_mem_ref_p.
+	(most_expensive_mult_to_index): Update call to
+	multiplier_allowed_in_address_p.
+
+	* dwarf2out.c (modified_type_die): Output DW_AT_address_class
+	attribute to indicate named address spaces.
+
+	* varasm.c (get_variable_section): DECLs in named address spaces
+	cannot be "common".
+
+	* reload.c (find_reloads_address): Do not use LEGITIMIZE_RELOAD_ADDRESS
+	for addresses in a non-generic address space.
+
+	* expr.c (emit_block_move_hints): Do not use libcalls for
+	memory in non-generic address spaces.
+	(clear_storage_hints): Likewise.
+	(expand_assignment): Likewise.
+
+	* fold-const.c (operand_equal_p): Expressions refering to different
+	address spaces are not equivalent.
+
+	* rtl.c (rtx_equal_p_cb): MEMs refering to different address
+	spaces are not equivalent.
+	(rtx_equal_p): Likewise.
+	* cse.c (exp_equiv_p): Likewise.
+	* jump.c (rtx_renumbered_equal_p): Likewise.
+	* reload.c (operands_match_p): Likewise.
+
+	* alias.c (nonoverlapping_memrefs_p): MEMs refering to different
+	address spaces may alias.
+	(true_dependence): Likewise.
+	(canon_true_dependence): Likewise.
+	(write_dependence_p): Likewise.
+
+	* dse.c (canon_address): Handle named address spaces.
+	* ifcvt.c (noce_try_cmove_arith): Likewise.
+
+	* tree.def (ADDR_SPACE_CONVERT_EXPR): New tree code.
+	* expr.c (expand_expr_real_1): Expand ADDR_SPACE_CONVERT_EXPR.
+	* convert.c (convert_to_pointer): Generate ADDR_SPACE_CONVERT_EXPR
+	to handle conversions between different address spaces.
+	* fold-const.c (fold_convert_loc): Likewise.
+	(fold_unary_loc): Handle ADDR_SPACE_CONVERT_EXPR.
+	* tree-pretty-print.c (dump_generic_node): Likewise.
+	* gimple-pretty-print.c (dump_unary_rhs): Likewise.
+	* tree-cfg.c (verify_gimple_assign_unary): Likewise.
+	* tree-inline.c (estimate_operator_cost): Likewise.
+	* tree-ssa.c (useless_type_conversion_p): Conversions between pointers
+	to different address spaces are not useless.
+	(useless_type_conversion_p_1): Likewise.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+gcc/
+	2009-08-14  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* c-lex.c (c_lex_with_flags): Increase size of local variable
+	to avoid memory clobber.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	Backport from mainline:
+
+libgfortran/
+	2009-04-17  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* configure.ac: Test for -ffunction-sections -fdata-sections and
+	set SECTION_FLAGS accordingly.
+	* configure: Regenerate.
+
+	* Makefile.am: Add SECTION_FLAGS to AM_CFLAGS.
+	* Makefile.in: Regenerate.
+
+2009-12-04  Ulrich Weigand  <Ulrich.Weigand@de.ibm.com>
+
+	* Created "cell-4_4-branch".
diff -urNp gcc-4.4.4.orig/gcc/alias.c gcc-4.4.4/gcc/alias.c
--- a/src/gcc/alias.c	2010-06-30
+++ b/src/gcc/alias.c	2010-06-30
@@ -1000,6 +1000,11 @@ find_base_value (rtx src)
       return 0;
 
     case TRUNCATE:
+      /* As we do not know which address space the pointer is refering to, we can
+	 handle this only if the target does not support different pointer or
+	 address modes depending on the address space.  */
+      if (!target_default_pointer_address_modes_p ())
+	break;
       if (GET_MODE_SIZE (GET_MODE (src)) < GET_MODE_SIZE (Pmode))
 	break;
       /* Fall through.  */
@@ -1014,6 +1019,12 @@ find_base_value (rtx src)
 
     case ZERO_EXTEND:
     case SIGN_EXTEND:	/* used for NT/Alpha pointers */
+      /* As we do not know which address space the pointer is refering to, we can
+	 handle this only if the target does not support different pointer or
+	 address modes depending on the address space.  */
+      if (!target_default_pointer_address_modes_p ())
+	break;
+
       {
 	rtx temp = find_base_value (XEXP (src, 0));
 
@@ -1406,6 +1417,11 @@ find_base_term (rtx x)
       return REG_BASE_VALUE (x);
 
     case TRUNCATE:
+      /* As we do not know which address space the pointer is refering to, we can
+	 handle this only if the target does not support different pointer or
+	 address modes depending on the address space.  */
+      if (!target_default_pointer_address_modes_p ())
+	return 0;
       if (GET_MODE_SIZE (GET_MODE (x)) < GET_MODE_SIZE (Pmode))
 	return 0;
       /* Fall through.  */
@@ -1420,6 +1436,12 @@ find_base_term (rtx x)
 
     case ZERO_EXTEND:
     case SIGN_EXTEND:	/* Used for Alpha/NT pointers */
+      /* As we do not know which address space the pointer is refering to, we can
+	 handle this only if the target does not support different pointer or
+	 address modes depending on the address space.  */
+      if (!target_default_pointer_address_modes_p ())
+	return 0;
+
       {
 	rtx temp = find_base_term (XEXP (x, 0));
 
@@ -2120,6 +2142,13 @@ nonoverlapping_memrefs_p (const_rtx x, c
       && ! rtx_equal_p (rtlx, rtly))
     return 1;
 
+  /* If we have MEMs refering to different address spaces (which can
+     potentially overlap), we cannot easily tell from the addresses
+     whether the references overlap.  */
+  if (MEM_P (rtlx) && MEM_P (rtly)
+      && MEM_ADDR_SPACE (rtlx) != MEM_ADDR_SPACE (rtly))
+    return 0;
+
   /* Get the base and offsets of both decls.  If either is a register, we
      know both are and are the same, so use that as the base.  The only
      we can avoid overlap is if we can deduce that they are nonoverlapping
@@ -2211,6 +2240,12 @@ true_dependence (const_rtx mem, enum mac
   if (nonoverlapping_memrefs_p (mem, x))
     return 0;
 
+  /* If we have MEMs refering to different address spaces (which can
+     potentially overlap), we cannot easily tell from the addresses
+     whether the references overlap.  */
+  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))
+    return 1;
+
   if (mem_mode == VOIDmode)
     mem_mode = GET_MODE (mem);
 
@@ -2296,6 +2331,12 @@ canon_true_dependence (const_rtx mem, en
   if (nonoverlapping_memrefs_p (x, mem))
     return 0;
 
+  /* If we have MEMs refering to different address spaces (which can
+     potentially overlap), we cannot easily tell from the addresses
+     whether the references overlap.  */
+  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))
+    return 1;
+
   if (! x_addr)
     {
       x_addr = XEXP (x, 0);
@@ -2366,6 +2407,12 @@ write_dependence_p (const_rtx mem, const
   if (nonoverlapping_memrefs_p (x, mem))
     return 0;
 
+  /* If we have MEMs refering to different address spaces (which can
+     potentially overlap), we cannot easily tell from the addresses
+     whether the references overlap.  */
+  if (MEM_ADDR_SPACE (mem) != MEM_ADDR_SPACE (x))
+    return 1;
+
   x_addr = XEXP (x, 0);
   mem_addr = XEXP (mem, 0);
   if (!((GET_CODE (x_addr) == VALUE
diff -urNp gcc-4.4.4.orig/gcc/auto-inc-dec.c gcc-4.4.4/gcc/auto-inc-dec.c
--- a/src/gcc/auto-inc-dec.c	2009-02-20
+++ b/src/gcc/auto-inc-dec.c	2010-06-30
@@ -40,6 +40,7 @@ along with GCC; see the file COPYING3.  
 #include "tree-pass.h"
 #include "df.h"
 #include "dbgcnt.h"
+#include "target.h"
 
 /* This pass was originally removed from flow.c. However there is
    almost nothing that remains of that code.
@@ -651,6 +652,7 @@ try_merge (void)
   /* The width of the mem being accessed.  */
   int size = GET_MODE_SIZE (GET_MODE (mem));
   rtx last_insn = NULL;
+  enum machine_mode reg_mode = GET_MODE (inc_reg);
 
   switch (inc_insn.form)
     {
@@ -705,33 +707,33 @@ try_merge (void)
     case SIMPLE_PRE_INC:     /* ++size  */
       if (dump_file)
 	fprintf (dump_file, "trying SIMPLE_PRE_INC\n");
-      return attempt_change (gen_rtx_PRE_INC (Pmode, inc_reg), inc_reg);
+      return attempt_change (gen_rtx_PRE_INC (reg_mode, inc_reg), inc_reg);
       break;
       
     case SIMPLE_POST_INC:    /* size++  */
       if (dump_file)
 	fprintf (dump_file, "trying SIMPLE_POST_INC\n");
-      return attempt_change (gen_rtx_POST_INC (Pmode, inc_reg), inc_reg);
+      return attempt_change (gen_rtx_POST_INC (reg_mode, inc_reg), inc_reg);
       break;
       
     case SIMPLE_PRE_DEC:     /* --size  */
       if (dump_file)
 	fprintf (dump_file, "trying SIMPLE_PRE_DEC\n");
-      return attempt_change (gen_rtx_PRE_DEC (Pmode, inc_reg), inc_reg);
+      return attempt_change (gen_rtx_PRE_DEC (reg_mode, inc_reg), inc_reg);
       break;
       
     case SIMPLE_POST_DEC:    /* size--  */
       if (dump_file)
 	fprintf (dump_file, "trying SIMPLE_POST_DEC\n");
-      return attempt_change (gen_rtx_POST_DEC (Pmode, inc_reg), inc_reg);
+      return attempt_change (gen_rtx_POST_DEC (reg_mode, inc_reg), inc_reg);
       break;
       
     case DISP_PRE:           /* ++con   */
       if (dump_file)
 	fprintf (dump_file, "trying DISP_PRE\n");
-      return attempt_change (gen_rtx_PRE_MODIFY (Pmode, 
+      return attempt_change (gen_rtx_PRE_MODIFY (reg_mode,
 						 inc_reg,
-						 gen_rtx_PLUS (Pmode,
+						 gen_rtx_PLUS (reg_mode,
 							       inc_reg,
 							       inc_insn.reg1)),
 			     inc_reg);
@@ -740,9 +742,9 @@ try_merge (void)
     case DISP_POST:          /* con++   */
       if (dump_file)
 	fprintf (dump_file, "trying POST_DISP\n");
-      return attempt_change (gen_rtx_POST_MODIFY (Pmode,
+      return attempt_change (gen_rtx_POST_MODIFY (reg_mode,
 						  inc_reg,
-						  gen_rtx_PLUS (Pmode,
+						  gen_rtx_PLUS (reg_mode,
 								inc_reg,
 								inc_insn.reg1)),
 			     inc_reg);
@@ -751,9 +753,9 @@ try_merge (void)
     case REG_PRE:            /* ++reg   */
       if (dump_file)
 	fprintf (dump_file, "trying PRE_REG\n");
-      return attempt_change (gen_rtx_PRE_MODIFY (Pmode, 
+      return attempt_change (gen_rtx_PRE_MODIFY (reg_mode,
 						 inc_reg,
-						 gen_rtx_PLUS (Pmode,
+						 gen_rtx_PLUS (reg_mode,
 							       inc_reg,
 							       inc_insn.reg1)),
 			     inc_reg);
@@ -762,9 +764,9 @@ try_merge (void)
     case REG_POST:            /* reg++   */
       if (dump_file)
 	fprintf (dump_file, "trying POST_REG\n");
-      return attempt_change (gen_rtx_POST_MODIFY (Pmode, 
+      return attempt_change (gen_rtx_POST_MODIFY (reg_mode,
 						  inc_reg,
-						  gen_rtx_PLUS (Pmode,
+						  gen_rtx_PLUS (reg_mode,
 								inc_reg,
 								inc_insn.reg1)),
 			     inc_reg);
@@ -1127,7 +1129,9 @@ find_inc (bool first_try)
 		     we are going to increment the result of the add insn.
 		     For this trick to be correct, the result reg of
 		     the inc must be a valid addressing reg.  */
-		  if (GET_MODE (inc_insn.reg_res) != Pmode)
+		  addr_space_t as = MEM_ADDR_SPACE (*mem_insn.mem_loc);
+		  if (GET_MODE (inc_insn.reg_res)
+		      != targetm.addr_space.address_mode (as))
 		    {
 		      if (dump_file)
 			fprintf (dump_file, "base reg mode failure.\n");
@@ -1176,7 +1180,9 @@ find_inc (bool first_try)
 	{
 	  /* For this trick to be correct, the result reg of the inc
 	     must be a valid addressing reg.  */
-	  if (GET_MODE (inc_insn.reg_res) != Pmode)
+	  addr_space_t as = MEM_ADDR_SPACE (*mem_insn.mem_loc);
+	  if (GET_MODE (inc_insn.reg_res)
+	      != targetm.addr_space.address_mode (as))
 	    {
 	      if (dump_file)
 		fprintf (dump_file, "base reg mode failure.\n");
diff -urNp gcc-4.4.4.orig/gcc/c-common.c gcc-4.4.4/gcc/c-common.c
--- a/src/gcc/c-common.c	2010-06-30
+++ b/src/gcc/c-common.c	2010-06-30
@@ -754,6 +754,11 @@ const struct c_common_resword c_common_r
   { "inout",		RID_INOUT,		D_OBJC },
   { "oneway",		RID_ONEWAY,		D_OBJC },
   { "out",		RID_OUT,		D_OBJC },
+
+#ifdef TARGET_ADDR_SPACE_KEYWORDS
+  /* Any address space keywords recognized by the target.  */
+  TARGET_ADDR_SPACE_KEYWORDS,
+#endif
 };
 
 const unsigned int num_c_common_reswords =
@@ -882,6 +887,19 @@ const struct attribute_spec c_common_for
   { NULL,                     0, 0, false, false, false, NULL }
 };
 
+/* Return identifier for address space AS.  */
+const char *
+c_addr_space_name (addr_space_t as)
+{
+  unsigned int i;
+
+  for (i = 0; i < num_c_common_reswords; i++)
+    if (c_common_reswords[i].rid == RID_FIRST_ADDR_SPACE + as)
+      return c_common_reswords[i].word;
+
+  gcc_unreachable ();
+}
+
 /* Push current bindings for the function name VAR_DECLS.  */
 
 void
@@ -5781,9 +5799,10 @@ handle_mode_attribute (tree *node, tree 
 
       if (POINTER_TYPE_P (type))
 	{
+	  addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (type));
 	  tree (*fn)(tree, enum machine_mode, bool);
 
-	  if (!targetm.valid_pointer_mode (mode))
+	  if (!targetm.addr_space.valid_pointer_mode (mode, as))
 	    {
 	      error ("invalid pointer mode %qs", p);
 	      return NULL_TREE;
@@ -7874,7 +7893,7 @@ complete_array_type (tree *ptype, tree i
   if (quals == 0)
     unqual_elt = elt;
   else
-    unqual_elt = c_build_qualified_type (elt, TYPE_UNQUALIFIED);
+    unqual_elt = c_build_qualified_type (elt, KEEP_QUAL_ADDR_SPACE (quals));
 
   /* Using build_distinct_type_copy and modifying things afterward instead
      of using build_array_type to create a new type preserves all of the
diff -urNp gcc-4.4.4.orig/gcc/c-common.h gcc-4.4.4/gcc/c-common.h
--- a/src/gcc/c-common.h	2010-06-30
+++ b/src/gcc/c-common.h	2010-06-30
@@ -119,6 +119,30 @@ enum rid
   RID_AT_INTERFACE,
   RID_AT_IMPLEMENTATION,
 
+  /* Named address support, mapping the keyword to a particular named address
+     number.  Named address space 0 is reserved for the generic address.  If
+     there are more than 254 named addresses, the addr_space_t type will need
+     to be grown from an unsigned char to unsigned short.  */
+  RID_ADDR_SPACE_0,		/* generic address */
+  RID_ADDR_SPACE_1,
+  RID_ADDR_SPACE_2,
+  RID_ADDR_SPACE_3,
+  RID_ADDR_SPACE_4,
+  RID_ADDR_SPACE_5,
+  RID_ADDR_SPACE_6,
+  RID_ADDR_SPACE_7,
+  RID_ADDR_SPACE_8,
+  RID_ADDR_SPACE_9,
+  RID_ADDR_SPACE_10,
+  RID_ADDR_SPACE_11,
+  RID_ADDR_SPACE_12,
+  RID_ADDR_SPACE_13,
+  RID_ADDR_SPACE_14,
+  RID_ADDR_SPACE_15,
+
+  RID_FIRST_ADDR_SPACE = RID_ADDR_SPACE_0,
+  RID_LAST_ADDR_SPACE = RID_ADDR_SPACE_15,
+
   RID_MAX,
 
   RID_FIRST_MODIFIER = RID_STATIC,
@@ -228,6 +252,10 @@ struct c_common_resword
 #define D_CXX_OBJC	0x100	/* In Objective C, and C++, but not C.  */
 #define D_CXXWARN	0x200	/* In C warn with -Wcxx-compat.  */
 
+/* Macro for backends to define named address keywords.  */
+#define ADDR_SPACE_KEYWORD(STRING, VALUE) \
+  { STRING, RID_FIRST_ADDR_SPACE + (VALUE), D_CONLY | D_EXT }
+
 /* The reserved keyword table.  */
 extern const struct c_common_resword c_common_reswords[];
 
@@ -690,6 +718,7 @@ extern const struct attribute_spec c_com
 
 extern tree (*make_fname_decl) (tree, int);
 
+extern const char *c_addr_space_name (addr_space_t as);
 extern tree identifier_global_value (tree);
 extern void record_builtin_type (enum rid, const char *, tree);
 extern tree build_void_list_node (void);
diff -urNp gcc-4.4.4.orig/gcc/c-decl.c gcc-4.4.4/gcc/c-decl.c
--- a/src/gcc/c-decl.c	2010-06-30
+++ b/src/gcc/c-decl.c	2010-06-30
@@ -1249,8 +1249,35 @@ diagnose_mismatched_decls (tree newdecl,
 	}
       else
 	{
-	  if (TYPE_QUALS (newtype) != TYPE_QUALS (oldtype))
-	    error ("conflicting type qualifiers for %q+D", newdecl);
+	  int new_quals = TYPE_QUALS (newtype);
+	  int old_quals = TYPE_QUALS (oldtype);
+
+	  if (new_quals != old_quals)
+	    {
+	      addr_space_t new_addr = DECODE_QUAL_ADDR_SPACE (new_quals);
+	      addr_space_t old_addr = DECODE_QUAL_ADDR_SPACE (old_quals);
+	      if (new_addr != old_addr)
+		{
+		  if (ADDR_SPACE_GENERIC_P (new_addr))
+		    error ("conflicting named address spaces (generic vs %s) "
+			   "for %q+D",
+			   c_addr_space_name (old_addr), newdecl);
+		  else if (ADDR_SPACE_GENERIC_P (old_addr))
+		    error ("conflicting named address spaces (%s vs generic) "
+			   "for %q+D",
+			   c_addr_space_name (new_addr), newdecl);
+		  else
+		    error ("conflicting named address spaces (%s vs %s) "
+			   "for %q+D",
+			   c_addr_space_name (new_addr),
+			   c_addr_space_name (old_addr),
+			   newdecl);
+		}
+
+	      if (CLEAR_QUAL_ADDR_SPACE (new_quals)
+		  != CLEAR_QUAL_ADDR_SPACE (old_quals))
+		error ("conflicting type qualifiers for %q+D", newdecl);
+	    }
 	  else
 	    error ("conflicting types for %q+D", newdecl);
 	  diagnose_arglist_conflict (newdecl, olddecl, newtype, oldtype);
@@ -2922,7 +2949,8 @@ shadow_tag_warned (const struct c_declsp
 	  else if (!declspecs->tag_defined_p
 		   && (declspecs->const_p
 		       || declspecs->volatile_p
-		       || declspecs->restrict_p))
+		       || declspecs->restrict_p
+		       || declspecs->address_space))
 	    {
 	      if (warned != 1)
 		pedwarn (input_location, 0,
@@ -2993,7 +3021,8 @@ shadow_tag_warned (const struct c_declsp
 
   if (!warned && !in_system_header && (declspecs->const_p
 				       || declspecs->volatile_p
-				       || declspecs->restrict_p))
+				       || declspecs->restrict_p
+				       || declspecs->address_space))
     {
       warning (0, "useless type qualifier in empty declaration");
       warned = 2;
@@ -3016,7 +3045,8 @@ quals_from_declspecs (const struct c_dec
 {
   int quals = ((specs->const_p ? TYPE_QUAL_CONST : 0)
 	       | (specs->volatile_p ? TYPE_QUAL_VOLATILE : 0)
-	       | (specs->restrict_p ? TYPE_QUAL_RESTRICT : 0));
+	       | (specs->restrict_p ? TYPE_QUAL_RESTRICT : 0)
+	       | (ENCODE_QUAL_ADDR_SPACE (specs->address_space)));
   gcc_assert (!specs->type
 	      && !specs->decl_attr
 	      && specs->typespec_word == cts_none
@@ -4002,6 +4032,7 @@ grokdeclarator (const struct c_declarato
   bool bitfield = width != NULL;
   tree element_type;
   struct c_arg_info *arg_info = 0;
+  addr_space_t as1, as2, address_space;
   const char *errmsg;
 
   if (decl_context == FUNCDEF)
@@ -4103,6 +4134,10 @@ grokdeclarator (const struct c_declarato
   constp = declspecs->const_p + TYPE_READONLY (element_type);
   restrictp = declspecs->restrict_p + TYPE_RESTRICT (element_type);
   volatilep = declspecs->volatile_p + TYPE_VOLATILE (element_type);
+  as1 = declspecs->address_space;
+  as2 = TYPE_ADDR_SPACE (element_type);
+  address_space = ADDR_SPACE_GENERIC_P (as1)? as2 : as1;
+
   if (pedantic && !flag_isoc99)
     {
       if (constp > 1)
@@ -4112,11 +4147,17 @@ grokdeclarator (const struct c_declarato
       if (volatilep > 1)
 	pedwarn (input_location, OPT_pedantic, "duplicate %<volatile%>");
     }
+
+  if (!ADDR_SPACE_GENERIC_P (as1) && !ADDR_SPACE_GENERIC_P (as2) && as1 != as2)
+    error ("conflicting named address spaces (%s vs %s)",
+	   c_addr_space_name (as1), c_addr_space_name (as2));
+
   if (!flag_gen_aux_info && (TYPE_QUALS (element_type)))
     type = TYPE_MAIN_VARIANT (type);
   type_quals = ((constp ? TYPE_QUAL_CONST : 0)
 		| (restrictp ? TYPE_QUAL_RESTRICT : 0)
-		| (volatilep ? TYPE_QUAL_VOLATILE : 0));
+		| (volatilep ? TYPE_QUAL_VOLATILE : 0)
+		| ENCODE_QUAL_ADDR_SPACE (address_space));
 
   /* Warn about storage classes that are invalid for certain
      kinds of declarations (parameters, typenames, etc.).  */
@@ -4460,7 +4501,14 @@ grokdeclarator (const struct c_declarato
 	       it, but here we want to make sure we don't ever
 	       modify the shared type, so we gcc_assert (itype)
 	       below.  */
-	      type = build_array_type (type, itype);
+	      {
+		addr_space_t as = DECODE_QUAL_ADDR_SPACE (type_quals);
+		if (!ADDR_SPACE_GENERIC_P (as) && as != TYPE_ADDR_SPACE (type))
+		  type = build_qualified_type (type,
+					       ENCODE_QUAL_ADDR_SPACE (as));
+
+		type = build_array_type (type, itype);
+	      }
 
 	    if (type != error_mark_node)
 	      {
@@ -4656,6 +4704,59 @@ grokdeclarator (const struct c_declarato
   /* Now TYPE has the actual type, apart from any qualifiers in
      TYPE_QUALS.  */
 
+  /* Warn about address space used for things other than static memory or
+     pointers.  */
+  address_space = DECODE_QUAL_ADDR_SPACE (type_quals);
+  if (!ADDR_SPACE_GENERIC_P (address_space))
+    {
+      if (decl_context == NORMAL)
+	{
+	  switch (storage_class)
+	    {
+	    case csc_auto:
+	      error ("%qs combined with %<auto%> qualifier for %qs",
+		     c_addr_space_name (address_space), name);
+	      break;
+	    case csc_register:
+	      error ("%qs combined with %<register%> qualifier for %qs",
+		     c_addr_space_name (address_space), name);
+	      break;
+	    case csc_none:
+	      if (current_function_scope)
+		{
+		  error ("%qs specified for auto variable %qs",
+			 c_addr_space_name (address_space), name);
+		  break;
+		}
+	      break;
+	    case csc_static:
+	    case csc_extern:
+	    case csc_typedef:
+	      break;
+	    default:
+	      gcc_unreachable ();
+	    }
+	}
+      else if (decl_context == PARM && TREE_CODE (type) != ARRAY_TYPE)
+	{
+	  if (orig_name)
+	    error ("%qs specified for parameter %qs",
+		   c_addr_space_name (address_space), name);
+	  else
+	    error ("%qs specified for unnamed parameter",
+		   c_addr_space_name (address_space));
+	}
+      else if (decl_context == FIELD)
+	{
+	  if (orig_name)
+	    error ("%qs specified for structure field %qs",
+		   c_addr_space_name (address_space), name);
+	  else
+	    error ("%qs specified for structure field",
+		   c_addr_space_name (address_space));
+	}
+    }
+
   /* Check the type and width of a bit-field.  */
   if (bitfield)
     check_bitfield_type_and_width (&type, width, orig_name);
@@ -7188,9 +7289,29 @@ build_null_declspecs (void)
   ret->volatile_p = false;
   ret->restrict_p = false;
   ret->saturating_p = false;
+  ret->address_space = ADDR_SPACE_GENERIC;
   return ret;
 }
 
+/* Add the address space ADDRSPACE to the declaration specifiers
+   SPECS, returning SPECS.  */
+
+struct c_declspecs *
+declspecs_add_addrspace (struct c_declspecs *specs, addr_space_t as)
+{
+  specs->non_sc_seen_p = true;
+  specs->declspecs_seen_p = true;
+
+  if (!ADDR_SPACE_GENERIC_P (specs->address_space)
+      && specs->address_space != as)
+    error ("incompatible address space qualifiers %qs and %qs",
+	   c_addr_space_name (as),
+	   c_addr_space_name (specs->address_space));
+  else
+    specs->address_space = as;
+  return specs;
+}
+
 /* Add the type qualifier QUAL to the declaration specifiers SPECS,
    returning SPECS.  */
 
diff -urNp gcc-4.4.4.orig/gcc/c-lex.c gcc-4.4.4/gcc/c-lex.c
--- a/src/gcc/c-lex.c	2008-08-21
+++ b/src/gcc/c-lex.c	2010-06-30
@@ -390,7 +390,7 @@ c_lex_with_flags (tree *value, location_
     case CPP_HASH:
     case CPP_PASTE:
       {
-	unsigned char name[4];
+	unsigned char name[8];
 
 	*cpp_spell_token (parse_in, tok, name, true) = 0;
 
diff -urNp gcc-4.4.4.orig/gcc/combine.c gcc-4.4.4/gcc/combine.c
--- a/src/gcc/combine.c	2010-03-22
+++ b/src/gcc/combine.c	2010-06-30
@@ -3890,9 +3890,12 @@ find_split_point (rtx *loc, rtx insn)
       if (GET_CODE (XEXP (x, 0)) == CONST
 	  || GET_CODE (XEXP (x, 0)) == SYMBOL_REF)
 	{
+	  enum machine_mode address_mode
+	    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (x));
+
 	  SUBST (XEXP (x, 0),
-		 gen_rtx_LO_SUM (Pmode,
-				 gen_rtx_HIGH (Pmode, XEXP (x, 0)),
+		 gen_rtx_LO_SUM (address_mode,
+				 gen_rtx_HIGH (address_mode, XEXP (x, 0)),
 				 XEXP (x, 0)));
 	  return &XEXP (XEXP (x, 0), 0);
 	}
@@ -3905,7 +3908,8 @@ find_split_point (rtx *loc, rtx insn)
 	 it will not remain in the result.  */
       if (GET_CODE (XEXP (x, 0)) == PLUS
 	  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT
-	  && ! memory_address_p (GET_MODE (x), XEXP (x, 0)))
+	  && ! memory_address_addr_space_p (GET_MODE (x), XEXP (x, 0),
+					    MEM_ADDR_SPACE (x)))
 	{
 	  rtx reg = regno_reg_rtx[FIRST_PSEUDO_REGISTER];
 	  rtx seq = combine_split_insns (gen_rtx_SET (VOIDmode, reg,
@@ -3928,8 +3932,9 @@ find_split_point (rtx *loc, rtx insn)
 	      && NONJUMP_INSN_P (NEXT_INSN (seq))
 	      && GET_CODE (PATTERN (NEXT_INSN (seq))) == SET
 	      && SET_DEST (PATTERN (NEXT_INSN (seq))) == reg
-	      && memory_address_p (GET_MODE (x),
-				   SET_SRC (PATTERN (NEXT_INSN (seq)))))
+	      && memory_address_addr_space_p
+		   (GET_MODE (x), SET_SRC (PATTERN (NEXT_INSN (seq))),
+		    MEM_ADDR_SPACE (x)))
 	    {
 	      rtx src1 = SET_SRC (PATTERN (seq));
 	      rtx src2 = SET_SRC (PATTERN (NEXT_INSN (seq)));
@@ -3968,7 +3973,8 @@ find_split_point (rtx *loc, rtx insn)
       /* If we have a PLUS whose first operand is complex, try computing it
          separately by making a split there.  */
       if (GET_CODE (XEXP (x, 0)) == PLUS
-          && ! memory_address_p (GET_MODE (x), XEXP (x, 0))
+          && ! memory_address_addr_space_p (GET_MODE (x), XEXP (x, 0),
+					    MEM_ADDR_SPACE (x))
           && ! OBJECT_P (XEXP (XEXP (x, 0), 0))
           && ! (GET_CODE (XEXP (XEXP (x, 0), 0)) == SUBREG
                 && OBJECT_P (SUBREG_REG (XEXP (XEXP (x, 0), 0)))))
diff -urNp gcc-4.4.4.orig/gcc/config/spu/cachemgr.c gcc-4.4.4/gcc/config/spu/cachemgr.c
--- a/src/gcc/config/spu/cachemgr.c	1970-01-01
+++ b/src/gcc/config/spu/cachemgr.c	2010-06-30
@@ -0,0 +1,438 @@
+/* Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+#include <spu_mfcio.h>
+#include <spu_internals.h>
+#include <spu_intrinsics.h>
+#include <spu_cache.h>
+
+extern unsigned long long __ea_local_store;
+extern char __cache_tag_array_size;
+
+#define LINE_SIZE 128
+#define TAG_MASK (LINE_SIZE - 1)
+
+#define WAYS 4
+#define SET_MASK ((int) &__cache_tag_array_size - LINE_SIZE)
+
+#define CACHE_LINES ((int) &__cache_tag_array_size /		\
+		     sizeof (struct __cache_tag_array) * WAYS)
+
+struct __cache_tag_array
+{
+  unsigned int tag_lo[WAYS];
+  unsigned int tag_hi[WAYS];
+  void *base[WAYS];
+  int reserved[WAYS];
+  vector unsigned short dirty_bits[WAYS];
+};
+
+extern struct __cache_tag_array __cache_tag_array[];
+extern char __cache[];
+
+/* In order to make the code seem a little cleaner, and to avoid having
+   64/32 bit ifdefs all over the place, we use macros.  */
+
+#ifdef __EA64__
+typedef unsigned long long addr;
+
+#define CHECK_TAG(_entry, _way, _tag)			\
+  ((_entry)->tag_lo[(_way)] == ((_tag) & 0xFFFFFFFF)	\
+   && (_entry)->tag_hi[(_way)] == ((_tag) >> 32))
+
+#define GET_TAG(_entry, _way) \
+  ((unsigned long long)(_entry)->tag_hi[(_way)] << 32	\
+   | (unsigned long long)(_entry)->tag_lo[(_way)])
+
+#define SET_TAG(_entry, _way, _tag)			\
+  (_entry)->tag_lo[(_way)] = (_tag) & 0xFFFFFFFF;	\
+  (_entry)->tag_hi[(_way)] = (_tag) >> 32
+
+#else /*__EA32__*/
+typedef unsigned long addr;
+
+#define CHECK_TAG(_entry, _way, _tag)			\
+  ((_entry)->tag_lo[(_way)] == (_tag))
+
+#define GET_TAG(_entry, _way)				\
+  ((_entry)->tag_lo[(_way)])
+
+#define SET_TAG(_entry, _way, _tag)			\
+  (_entry)->tag_lo[(_way)] = (_tag)
+
+#endif
+
+/* In GET_ENTRY, we cast away the high 32 bits,
+   as the tag is only in the low 32.  */
+
+#define GET_ENTRY(_addr)						   \
+  ((struct __cache_tag_array *)						   \
+   si_to_uint (si_a (si_and (si_from_uint ((unsigned int) (addr) (_addr)), \
+			     si_from_uint (SET_MASK)),			   \
+	       si_from_uint ((unsigned int) __cache_tag_array))))
+
+#define GET_CACHE_LINE(_addr, _way) \
+  ((void *) (__cache + ((_addr) & SET_MASK) * WAYS) + ((_way) * LINE_SIZE));
+
+#define CHECK_DIRTY(_vec) (si_to_uint (si_orx ((qword) (_vec))))
+#define SET_EMPTY(_entry, _way) ((_entry)->tag_lo[(_way)] = 1)
+#define CHECK_EMPTY(_entry, _way) ((_entry)->tag_lo[(_way)] == 1)
+
+#define LS_FLAG 0x80000000
+#define SET_IS_LS(_entry, _way) ((_entry)->reserved[(_way)] |= LS_FLAG)
+#define CHECK_IS_LS(_entry, _way) ((_entry)->reserved[(_way)] & LS_FLAG)
+#define GET_LRU(_entry, _way) ((_entry)->reserved[(_way)] & ~LS_FLAG)
+
+static int dma_tag = 32;
+
+static void
+__cache_evict_entry (struct __cache_tag_array *entry, int way)
+{
+  addr tag = GET_TAG (entry, way);
+
+  if (CHECK_DIRTY (entry->dirty_bits[way]) && !CHECK_IS_LS (entry, way))
+    {
+#ifdef NONATOMIC
+      /* Non-atomic writes.  */
+      unsigned int oldmask, mach_stat;
+      char *line = ((void *) 0);
+
+      /* Enter critical section.  */
+      mach_stat = spu_readch (SPU_RdMachStat);
+      spu_idisable ();
+
+      /* Issue DMA request.  */
+      line = GET_CACHE_LINE (entry->tag_lo[way], way);
+      mfc_put (line, tag, LINE_SIZE, dma_tag, 0, 0);
+
+      /* Wait for DMA completion.  */
+      oldmask = mfc_read_tag_mask ();
+      mfc_write_tag_mask (1 << dma_tag);
+      mfc_read_tag_status_all ();
+      mfc_write_tag_mask (oldmask);
+
+      /* Leave critical section.  */
+      if (__builtin_expect (mach_stat & 1, 0))
+	spu_ienable ();
+#else
+      /* Allocate a buffer large enough that we know it has 128 bytes
+         that are 128 byte aligned (for DMA). */
+
+      char buffer[LINE_SIZE + 127];
+      qword *buf_ptr = (qword *) (((unsigned int) (buffer) + 127) & ~127);
+      qword *line = GET_CACHE_LINE (entry->tag_lo[way], way);
+      qword bits;
+      unsigned int mach_stat;
+
+      /* Enter critical section.  */
+      mach_stat = spu_readch (SPU_RdMachStat);
+      spu_idisable ();
+
+      do
+	{
+	  /* We atomically read the current memory into a buffer
+	     modify the dirty bytes in the buffer, and write it
+	     back. If writeback fails, loop and try again.  */
+
+	  mfc_getllar (buf_ptr, tag, 0, 0);
+	  mfc_read_atomic_status ();
+
+	  /* The method we're using to write 16 dirty bytes into
+	     the buffer at a time uses fsmb which in turn uses
+	     the least significant 16 bits of word 0, so we
+	     load the bits and rotate so that the first bit of
+	     the bitmap is in the first bit that fsmb will use.  */
+
+	  bits = (qword) entry->dirty_bits[way];
+	  bits = si_rotqbyi (bits, -2);
+
+	  /* Si_fsmb creates the mask of dirty bytes.
+	     Use selb to nab the appropriate bits.  */
+	  buf_ptr[0] = si_selb (buf_ptr[0], line[0], si_fsmb (bits));
+
+	  /* Rotate to next 16 byte section of cache.  */
+	  bits = si_rotqbyi (bits, 2);
+
+	  buf_ptr[1] = si_selb (buf_ptr[1], line[1], si_fsmb (bits));
+	  bits = si_rotqbyi (bits, 2);
+	  buf_ptr[2] = si_selb (buf_ptr[2], line[2], si_fsmb (bits));
+	  bits = si_rotqbyi (bits, 2);
+	  buf_ptr[3] = si_selb (buf_ptr[3], line[3], si_fsmb (bits));
+	  bits = si_rotqbyi (bits, 2);
+	  buf_ptr[4] = si_selb (buf_ptr[4], line[4], si_fsmb (bits));
+	  bits = si_rotqbyi (bits, 2);
+	  buf_ptr[5] = si_selb (buf_ptr[5], line[5], si_fsmb (bits));
+	  bits = si_rotqbyi (bits, 2);
+	  buf_ptr[6] = si_selb (buf_ptr[6], line[6], si_fsmb (bits));
+	  bits = si_rotqbyi (bits, 2);
+	  buf_ptr[7] = si_selb (buf_ptr[7], line[7], si_fsmb (bits));
+	  bits = si_rotqbyi (bits, 2);
+
+	  mfc_putllc (buf_ptr, tag, 0, 0);
+	}
+      while (mfc_read_atomic_status ());
+
+      /* Leave critical section.  */
+      if (__builtin_expect (mach_stat & 1, 0))
+	spu_ienable ();
+#endif
+    }
+
+  /* In any case, marking the lo tag with 1 which denotes empty.  */
+  SET_EMPTY (entry, way);
+  entry->dirty_bits[way] = (vector unsigned short) si_from_uint (0);
+}
+
+void
+__cache_evict (__ea void *ea)
+{
+  addr tag = (addr) ea & ~TAG_MASK;
+  struct __cache_tag_array *entry = GET_ENTRY (ea);
+  int i = 0;
+
+  /* Cycles through all the possible ways an address could be at
+     and evicts the way if found.  */
+
+  for (i = 0; i < WAYS; i++)
+    if (CHECK_TAG (entry, i, tag))
+      __cache_evict_entry (entry, i);
+}
+
+static void *
+__cache_fill (int way, addr tag)
+{
+  unsigned int oldmask, mach_stat;
+  char *line = ((void *) 0);
+
+  /* Reserve our DMA tag.  */
+  if (dma_tag == 32)
+    dma_tag = mfc_tag_reserve ();
+
+  /* Enter critical section.  */
+  mach_stat = spu_readch (SPU_RdMachStat);
+  spu_idisable ();
+
+  /* Issue DMA request.  */
+  line = GET_CACHE_LINE (tag, way);
+  mfc_get (line, tag, LINE_SIZE, dma_tag, 0, 0);
+
+  /* Wait for DMA completion.  */
+  oldmask = mfc_read_tag_mask ();
+  mfc_write_tag_mask (1 << dma_tag);
+  mfc_read_tag_status_all ();
+  mfc_write_tag_mask (oldmask);
+
+  /* Leave critical section.  */
+  if (__builtin_expect (mach_stat & 1, 0))
+    spu_ienable ();
+
+  return (void *) line;
+}
+
+static void
+__cache_miss (__ea void *ea, struct __cache_tag_array *entry, int way)
+{
+
+  addr tag = (addr) ea & ~TAG_MASK;
+  unsigned int lru = 0;
+  int i = 0;
+  int idx = 0;
+
+  /* If way > 4, then there are no empty slots, so we must evict
+     the least recently used entry. */
+  if (way >= 4)
+    {
+      for (i = 0; i < WAYS; i++)
+	{
+	  if (GET_LRU (entry, i) > lru)
+	    {
+	      lru = GET_LRU (entry, i);
+	      idx = i;
+	    }
+	}
+      __cache_evict_entry (entry, idx);
+      way = idx;
+    }
+
+  /* Set the empty entry's tag and fill it's cache line. */
+
+  SET_TAG (entry, way, tag);
+  entry->reserved[way] = 0;
+
+  /* Check if the address is just an effective address within the
+     SPU's local store. */
+
+  /* Because the LS is not 256k aligned, we can't do a nice and mask
+     here to compare, so we must check the whole range.  */
+
+  if ((addr) ea >= (addr) __ea_local_store
+      && (addr) ea < (addr) (__ea_local_store + 0x40000))
+    {
+      SET_IS_LS (entry, way);
+      entry->base[way] =
+	(void *) ((unsigned int) ((addr) ea -
+				  (addr) __ea_local_store) & ~0x7f);
+    }
+  else
+    {
+      entry->base[way] = __cache_fill (way, tag);
+    }
+}
+
+void *
+__cache_fetch_dirty (__ea void *ea, int n_bytes_dirty)
+{
+#ifdef __EA64__
+  unsigned int tag_hi;
+  qword etag_hi;
+#endif
+  unsigned int tag_lo;
+  struct __cache_tag_array *entry;
+
+  qword etag_lo;
+  qword equal;
+  qword bit_mask;
+  qword way;
+
+  /* This first chunk, we merely fill the pointer and tag.  */
+
+  entry = GET_ENTRY (ea);
+
+#ifndef __EA64__
+  tag_lo =
+    si_to_uint (si_andc
+		(si_shufb
+		 (si_from_uint ((addr) ea), si_from_uint (0),
+		  si_from_uint (0x00010203)), si_from_uint (TAG_MASK)));
+#else
+  tag_lo =
+    si_to_uint (si_andc
+		(si_shufb
+		 (si_from_ullong ((addr) ea), si_from_uint (0),
+		  si_from_uint (0x04050607)), si_from_uint (TAG_MASK)));
+
+  tag_hi =
+    si_to_uint (si_shufb
+		(si_from_ullong ((addr) ea), si_from_uint (0),
+		 si_from_uint (0x00010203)));
+#endif
+
+  /* Increment LRU in reserved bytes.  */
+  si_stqd (si_ai (si_lqd (si_from_ptr (entry), 48), 1),
+	   si_from_ptr (entry), 48);
+
+missreturn:
+  /* Check if the entry's lo_tag is equal to the address' lo_tag.  */
+  etag_lo = si_lqd (si_from_ptr (entry), 0);
+  equal = si_ceq (etag_lo, si_from_uint (tag_lo));
+#ifdef __EA64__
+  /* And the high tag too.  */
+  etag_hi = si_lqd (si_from_ptr (entry), 16);
+  equal = si_and (equal, (si_ceq (etag_hi, si_from_uint (tag_hi))));
+#endif
+
+  if ((si_to_uint (si_orx (equal)) == 0))
+    goto misshandler;
+
+  if (n_bytes_dirty)
+    {
+      /* way = 0x40,0x50,0x60,0x70 for each way, which is also the
+         offset of the appropriate dirty bits.  */
+      way = si_shli (si_clz (si_gbb (equal)), 2);
+
+      /* To create the bit_mask, we set it to all 1s (uint -1), then we
+         shift it over (128 - n_bytes_dirty) times.  */
+
+      bit_mask = si_from_uint (-1);
+
+      bit_mask =
+	si_shlqby (bit_mask, si_from_uint ((LINE_SIZE - n_bytes_dirty) / 8));
+
+      bit_mask =
+	si_shlqbi (bit_mask, si_from_uint ((LINE_SIZE - n_bytes_dirty) % 8));
+
+      /* Rotate it around to the correct offset.  */
+      bit_mask =
+	si_rotqby (bit_mask,
+		   si_from_uint (-1 * ((addr) ea & TAG_MASK) / 8));
+
+      bit_mask =
+	si_rotqbi (bit_mask,
+		   si_from_uint (-1 * ((addr) ea & TAG_MASK) % 8));
+
+      /* Update the dirty bits.  */
+      si_stqx (si_or (si_lqx (si_from_ptr (entry), way), bit_mask),
+	       si_from_ptr (entry), way);
+    };
+
+  /* We've definitely found the right entry, set LRU (reserved) to 0
+     maintaining the LS flag (MSB).  */
+
+  si_stqd (si_andc
+	   (si_lqd (si_from_ptr (entry), 48),
+	    si_and (equal, si_from_uint (~(LS_FLAG)))),
+	   si_from_ptr (entry), 48);
+
+  return (void *)
+    si_to_uint (si_a
+		(si_orx
+		 (si_and (si_lqd (si_from_ptr (entry), 32), equal)),
+		 si_from_uint (((unsigned int) (addr) ea) & TAG_MASK)));
+
+misshandler:
+  equal = si_ceqi (etag_lo, 1);
+  __cache_miss (ea, entry, (si_to_uint (si_clz (si_gbb (equal))) - 16) >> 2);
+  goto missreturn;
+}
+
+void *
+__cache_fetch (__ea void *ea)
+{
+  return __cache_fetch_dirty (ea, 0);
+}
+
+void
+__cache_touch (__ea void *ea __attribute__ ((unused)))
+{
+  /* NO-OP for now.  */
+}
+
+void __cache_flush (void) __attribute__ ((destructor));
+void
+__cache_flush (void)
+{
+  struct __cache_tag_array *entry = __cache_tag_array;
+  unsigned int i;
+  int j;
+
+  /* Cycle through each cache entry and evict all used ways.  */
+
+  for (i = 0; i < CACHE_LINES / WAYS; i++)
+    {
+      for (j = 0; j < WAYS; j++)
+	if (!CHECK_EMPTY (entry, j))
+	  __cache_evict_entry (entry, j);
+
+      entry++;
+    }
+}
diff -urNp gcc-4.4.4.orig/gcc/config/spu/cache.S gcc-4.4.4/gcc/config/spu/cache.S
--- a/src/gcc/config/spu/cache.S	1970-01-01
+++ b/src/gcc/config/spu/cache.S	2010-06-30
@@ -0,0 +1,43 @@
+/* Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+
+This file is part of GCC.
+
+GCC is free software; you can redistribute it and/or modify it under
+the terms of the GNU General Public License as published by the Free
+Software Foundation; either version 3, or (at your option) any later
+version.
+
+GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+Under Section 7 of GPL version 3, you are granted additional
+permissions described in the GCC Runtime Library Exception, version
+3.1, as published by the Free Software Foundation.
+
+You should have received a copy of the GNU General Public License and
+a copy of the GCC Runtime Library Exception along with this program;
+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+<http://www.gnu.org/licenses/>.  */
+
+	.data
+	.p2align 7
+	.global __cache
+__cache:
+	.rept __CACHE_SIZE__ * 8
+	.fill 128
+	.endr
+
+	.p2align 7
+	.global __cache_tag_array
+__cache_tag_array:
+	.rept __CACHE_SIZE__ * 2
+	.long 1, 1, 1, 1
+	.fill 128-16
+	.endr
+__end_cache_tag_array:
+
+	.globl __cache_tag_array_size
+	.set __cache_tag_array_size, __end_cache_tag_array-__cache_tag_array
+
diff -urNp gcc-4.4.4.orig/gcc/config/spu/spu.c gcc-4.4.4/gcc/config/spu/spu.c
--- a/src/gcc/config/spu/spu.c	2009-12-04
+++ b/src/gcc/config/spu/spu.c	2010-06-30
@@ -153,6 +153,8 @@ char regs_ever_allocated[FIRST_PSEUDO_RE
 static void spu_init_builtins (void);
 static unsigned char spu_scalar_mode_supported_p (enum machine_mode mode);
 static unsigned char spu_vector_mode_supported_p (enum machine_mode mode);
+static bool spu_addr_space_legitimate_address_p (enum machine_mode, rtx,
+						 bool, addr_space_t);
 static rtx adjust_operand (rtx op, HOST_WIDE_INT * start);
 static rtx get_pic_reg (void);
 static int need_to_save_reg (int regno, int saving);
@@ -201,15 +203,23 @@ static void spu_init_libfuncs (void);
 static bool spu_return_in_memory (const_tree type, const_tree fntype);
 static void fix_range (const char *);
 static void spu_encode_section_info (tree, rtx, int);
+static rtx spu_addr_space_legitimize_address (rtx, rtx, enum machine_mode,
+					      addr_space_t);
 static tree spu_builtin_mul_widen_even (tree);
 static tree spu_builtin_mul_widen_odd (tree);
 static tree spu_builtin_mask_for_load (void);
 static int spu_builtin_vectorization_cost (bool);
 static bool spu_vector_alignment_reachable (const_tree, bool);
 static tree spu_builtin_vec_perm (tree, tree *);
+static enum machine_mode spu_addr_space_pointer_mode (addr_space_t);
+static enum machine_mode spu_addr_space_address_mode (addr_space_t);
+static bool spu_addr_space_subset_p (addr_space_t, addr_space_t);
+static rtx spu_addr_space_convert (rtx, tree, tree);
 static int spu_sms_res_mii (struct ddg *g);
 static void asm_file_start (void);
 static unsigned int spu_section_type_flags (tree, const char *, int);
+static section *spu_select_section (tree, int, unsigned HOST_WIDE_INT);
+static void spu_unique_section (tree, int);
 static rtx spu_expand_load (rtx, rtx, rtx, int);
 
 extern const char *reg_names[];
@@ -269,9 +279,31 @@ spu_libgcc_cmp_return_mode (void);
 static enum machine_mode
 spu_libgcc_shift_count_mode (void);
 
+/* Pointer mode for __ea references.  */
+#define EAmode (spu_ea_model != 32 ? DImode : SImode)
+
 
 /*  TARGET overrides.  */
 
+#undef TARGET_ADDR_SPACE_POINTER_MODE
+#define TARGET_ADDR_SPACE_POINTER_MODE spu_addr_space_pointer_mode
+
+#undef TARGET_ADDR_SPACE_ADDRESS_MODE
+#define TARGET_ADDR_SPACE_ADDRESS_MODE spu_addr_space_address_mode
+
+#undef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P
+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P \
+  spu_addr_space_legitimate_address_p
+
+#undef TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS
+#define TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS spu_addr_space_legitimize_address
+
+#undef TARGET_ADDR_SPACE_SUBSET_P
+#define TARGET_ADDR_SPACE_SUBSET_P spu_addr_space_subset_p
+
+#undef TARGET_ADDR_SPACE_CONVERT
+#define TARGET_ADDR_SPACE_CONVERT spu_addr_space_convert
+
 #undef TARGET_INIT_BUILTINS
 #define TARGET_INIT_BUILTINS spu_init_builtins
 
@@ -281,6 +313,15 @@ spu_libgcc_shift_count_mode (void);
 #undef TARGET_UNWIND_WORD_MODE
 #define TARGET_UNWIND_WORD_MODE spu_unwind_word_mode
 
+/* The current assembler doesn't like .4byte foo@ppu, so use the normal .long
+   and .quad for the debugger.  When it is known that the assembler is fixed,
+   these can be removed.  */
+#undef TARGET_ASM_UNALIGNED_SI_OP
+#define TARGET_ASM_UNALIGNED_SI_OP	"\t.long\t"
+
+#undef TARGET_ASM_ALIGNED_DI_OP
+#define TARGET_ASM_ALIGNED_DI_OP	"\t.quad\t"
+
 /* The .8byte directive doesn't seem to work well for a 32 bit
    architecture. */
 #undef TARGET_ASM_UNALIGNED_DI_OP
@@ -398,6 +439,12 @@ const struct attribute_spec spu_attribut
 #undef TARGET_SECTION_TYPE_FLAGS
 #define TARGET_SECTION_TYPE_FLAGS spu_section_type_flags
 
+#undef TARGET_ASM_SELECT_SECTION
+#define TARGET_ASM_SELECT_SECTION  spu_select_section
+
+#undef TARGET_ASM_UNIQUE_SECTION
+#define TARGET_ASM_UNIQUE_SECTION  spu_unique_section
+
 struct gcc_target targetm = TARGET_INITIALIZER;
 
 void
@@ -3606,6 +3653,29 @@ exp2_immediate_p (rtx op, enum machine_m
   return FALSE;
 }
 
+/* Return true if X is a SYMBOL_REF to an __ea qualified variable.  */
+
+static int
+ea_symbol_ref (rtx *px, void *data ATTRIBUTE_UNUSED)
+{
+  rtx x = *px;
+  tree decl;
+
+  if (GET_CODE (x) == CONST && GET_CODE (XEXP (x, 0)) == PLUS)
+    {
+      rtx plus = XEXP (x, 0);
+      rtx op0 = XEXP (plus, 0);
+      rtx op1 = XEXP (plus, 1);
+      if (GET_CODE (op1) == CONST_INT)
+	x = op0;
+    }
+
+  return (GET_CODE (x) == SYMBOL_REF
+ 	  && (decl = SYMBOL_REF_DECL (x)) != 0
+ 	  && TREE_CODE (decl) == VAR_DECL
+ 	  && TYPE_ADDR_SPACE (TREE_TYPE (decl)));
+}
+
 /* We accept:
    - any 32-bit constant (SImode, SFmode)
    - any constant that can be generated with fsmbi (any mode)
@@ -3617,6 +3687,12 @@ spu_legitimate_constant_p (rtx x)
 {
   if (GET_CODE (x) == HIGH)
     x = XEXP (x, 0);
+
+  /* Reject any __ea qualified reference.  These can't appear in
+     instructions but must be forced to the constant pool.  */
+  if (for_each_rtx (&x, ea_symbol_ref, 0))
+    return 0;
+
   /* V4SI with all identical symbols is valid. */
   if (!flag_pic
       && GET_MODE (x) == V4SImode
@@ -3655,8 +3731,14 @@ spu_legitimate_address (enum machine_mod
   switch (GET_CODE (x))
     {
     case LABEL_REF:
+      return !TARGET_LARGE_MEM;
+
     case SYMBOL_REF:
     case CONST:
+      /* Keep __ea references until reload so that spu_expand_mov can see them
+	 in MEMs.  */
+      if (ea_symbol_ref (&x, 0))
+	return !reload_in_progress && !reload_completed;
       return !TARGET_LARGE_MEM;
 
     case CONST_INT:
@@ -3700,6 +3782,20 @@ spu_legitimate_address (enum machine_mod
   return FALSE;
 }
 
+/* Like spu_legitimate_address, except with named addresses.  */
+static bool
+spu_addr_space_legitimate_address_p (enum machine_mode mode, rtx x,
+				     bool reg_ok_strict, addr_space_t as)
+{
+  if (as == ADDR_SPACE_EA)
+    return (REG_P (x) && (GET_MODE (x) == EAmode));
+
+  else if (as != ADDR_SPACE_GENERIC)
+    gcc_unreachable ();
+
+  return spu_legitimate_address (mode, x, reg_ok_strict);
+}
+
 /* When the address is reg + const_int, force the const_int into a
    register.  */
 rtx
@@ -3733,6 +3829,23 @@ spu_legitimize_address (rtx x, rtx oldx 
   return NULL_RTX;
 }
 
+/* Like spu_legitimate_address, except with named address support.  */
+static rtx
+spu_addr_space_legitimize_address (rtx x, rtx oldx, enum machine_mode mode,
+				   addr_space_t as)
+{
+  rtx result;
+
+  if (as != ADDR_SPACE_GENERIC)
+    return x;
+
+  result = spu_legitimize_address (x, oldx, mode);
+  if (result)
+    return result;
+
+  return x;
+}
+
 /* Handle an attribute requiring a FUNCTION_DECL; arguments as in
    struct attribute_spec.handler.  */
 static tree
@@ -4233,6 +4346,233 @@ address_needs_split (rtx mem)
   return 0;
 }
 
+static GTY(()) rtx cache_fetch;		  /* __cache_fetch function */
+static GTY(()) rtx cache_fetch_dirty;	  /* __cache_fetch_dirty function */
+static alias_set_type ea_alias_set = -1;  /* alias set for __ea memory */
+
+/* MEM is known to be an __ea qualified memory access.  Emit a call to
+   fetch the ppu memory to local store, and return its address in local
+   store.  */
+
+static void
+ea_load_store (rtx mem, bool is_store, rtx ea_addr, rtx data_addr)
+{
+  if (is_store)
+    {
+      rtx ndirty = GEN_INT (GET_MODE_SIZE (GET_MODE (mem)));
+      if (!cache_fetch_dirty)
+	cache_fetch_dirty = init_one_libfunc ("__cache_fetch_dirty");
+      emit_library_call_value (cache_fetch_dirty, data_addr, LCT_NORMAL, Pmode,
+			       2, ea_addr, EAmode, ndirty, SImode);
+    }
+  else
+    {
+      if (!cache_fetch)
+	cache_fetch = init_one_libfunc ("__cache_fetch");
+      emit_library_call_value (cache_fetch, data_addr, LCT_NORMAL, Pmode,
+			       1, ea_addr, EAmode);
+    }
+}
+
+/* Like ea_load_store, but do the cache tag comparison and, for stores,
+   dirty bit marking, inline.
+
+   The cache control data structure is an array of
+
+   struct __cache_tag_array
+     {
+        unsigned int tag_lo[4];
+        unsigned int tag_hi[4];
+        void *data_pointer[4];
+        int reserved[4];
+        vector unsigned short dirty_bits[4];
+     }  */
+
+static void
+ea_load_store_inline (rtx mem, bool is_store, rtx ea_addr, rtx data_addr)
+{
+  rtx ea_addr_si;
+  HOST_WIDE_INT v;
+  rtx tag_size_sym = gen_rtx_SYMBOL_REF (Pmode, "__cache_tag_array_size");
+  rtx tag_arr_sym = gen_rtx_SYMBOL_REF (Pmode, "__cache_tag_array");
+  rtx index_mask = gen_reg_rtx (SImode);
+  rtx tag_arr = gen_reg_rtx (Pmode);
+  rtx splat_mask = gen_reg_rtx (TImode);
+  rtx splat = gen_reg_rtx (V4SImode);
+  rtx splat_hi = NULL_RTX;
+  rtx tag_index = gen_reg_rtx (Pmode);
+  rtx block_off = gen_reg_rtx (SImode);
+  rtx tag_addr = gen_reg_rtx (Pmode);
+  rtx tag = gen_reg_rtx (V4SImode);
+  rtx cache_tag = gen_reg_rtx (V4SImode);
+  rtx cache_tag_hi = NULL_RTX;
+  rtx cache_ptrs = gen_reg_rtx (TImode);
+  rtx cache_ptrs_si = gen_reg_rtx (SImode);
+  rtx tag_equal = gen_reg_rtx (V4SImode);
+  rtx tag_equal_hi = NULL_RTX;
+  rtx tag_eq_pack = gen_reg_rtx (V4SImode);
+  rtx tag_eq_pack_si = gen_reg_rtx (SImode);
+  rtx eq_index = gen_reg_rtx (SImode);
+  rtx bcomp, hit_label, hit_ref, cont_label, insn;
+
+  if (spu_ea_model != 32)
+    {
+      splat_hi = gen_reg_rtx (V4SImode);
+      cache_tag_hi = gen_reg_rtx (V4SImode);
+      tag_equal_hi = gen_reg_rtx (V4SImode);
+    }
+
+  emit_move_insn (index_mask, plus_constant (tag_size_sym, -128));
+  emit_move_insn (tag_arr, tag_arr_sym);
+  v = 0x0001020300010203LL;
+  emit_move_insn (splat_mask, immed_double_const (v, v, TImode));
+  ea_addr_si = ea_addr;
+  if (spu_ea_model != 32)
+    ea_addr_si = convert_to_mode (SImode, ea_addr, 1);
+
+  /* tag_index = ea_addr & (tag_array_size - 128)  */
+  emit_insn (gen_andsi3 (tag_index, ea_addr_si, index_mask));
+
+  /* splat ea_addr to all 4 slots.  */
+  emit_insn (gen_shufb (splat, ea_addr_si, ea_addr_si, splat_mask));
+  /* Similarly for high 32 bits of ea_addr.  */
+  if (spu_ea_model != 32)
+    emit_insn (gen_shufb (splat_hi, ea_addr, ea_addr, splat_mask));
+
+  /* block_off = ea_addr & 127  */
+  emit_insn (gen_andsi3 (block_off, ea_addr_si, spu_const (SImode, 127)));
+
+  /* tag_addr = tag_arr + tag_index  */
+  emit_insn (gen_addsi3 (tag_addr, tag_arr, tag_index));
+
+  /* Read cache tags.  */
+  emit_move_insn (cache_tag, gen_rtx_MEM (V4SImode, tag_addr));
+  if (spu_ea_model != 32)
+    emit_move_insn (cache_tag_hi, gen_rtx_MEM (V4SImode,
+					       plus_constant (tag_addr, 16)));
+
+  /* tag = ea_addr & -128  */
+  emit_insn (gen_andv4si3 (tag, splat, spu_const (V4SImode, -128)));
+
+  /* Read all four cache data pointers.  */
+  emit_move_insn (cache_ptrs, gen_rtx_MEM (TImode,
+					   plus_constant (tag_addr, 32)));
+
+  /* Compare tags.  */
+  emit_insn (gen_ceq_v4si (tag_equal, tag, cache_tag));
+  if (spu_ea_model != 32)
+    {
+      emit_insn (gen_ceq_v4si (tag_equal_hi, splat_hi, cache_tag_hi));
+      emit_insn (gen_andv4si3 (tag_equal, tag_equal, tag_equal_hi));
+    }
+
+  /* At most one of the tags compare equal, so tag_equal has one
+     32-bit slot set to all 1's, with the other slots all zero.
+     gbb picks off low bit from each byte in the 128-bit registers,
+     so tag_eq_pack is one of 0xf000, 0x0f00, 0x00f0, 0x000f, assuming
+     we have a hit.  */
+  emit_insn (gen_spu_gbb (tag_eq_pack, spu_gen_subreg (V16QImode, tag_equal)));
+  emit_insn (gen_spu_convert (tag_eq_pack_si, tag_eq_pack));
+
+  /* So counting leading zeros will set eq_index to 16, 20, 24 or 28.  */
+  emit_insn (gen_clzsi2 (eq_index, tag_eq_pack_si));
+
+  /* Allowing us to rotate the corresponding cache data pointer to slot0.
+     (rotating eq_index mod 16 bytes).  */
+  emit_insn (gen_rotqby_ti (cache_ptrs, cache_ptrs, eq_index));
+  emit_insn (gen_spu_convert (cache_ptrs_si, cache_ptrs));
+
+  /* Add block offset to form final data address.  */
+  emit_insn (gen_addsi3 (data_addr, cache_ptrs_si, block_off));
+
+  /* Check that we did hit.  */
+  hit_label = gen_label_rtx ();
+  hit_ref = gen_rtx_LABEL_REF (VOIDmode, hit_label);
+  bcomp = gen_rtx_NE (SImode, tag_eq_pack_si, const0_rtx);
+  insn = emit_jump_insn (gen_rtx_SET (VOIDmode, pc_rtx,
+				      gen_rtx_IF_THEN_ELSE (VOIDmode, bcomp,
+							    hit_ref, pc_rtx)));
+  /* Say that this branch is very likely to happen.  */
+  v = REG_BR_PROB_BASE - REG_BR_PROB_BASE / 100 - 1;
+  REG_NOTES (insn)
+    = gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (v), REG_NOTES (insn));
+
+  ea_load_store (mem, is_store, ea_addr, data_addr);
+  cont_label = gen_label_rtx ();
+  emit_jump_insn (gen_jump (cont_label));
+  emit_barrier ();
+
+  emit_label (hit_label);
+
+  if (is_store)
+    {
+      HOST_WIDE_INT v_hi;
+      rtx dirty_bits = gen_reg_rtx (TImode);
+      rtx dirty_off = gen_reg_rtx (SImode);
+      rtx dirty_128 = gen_reg_rtx (TImode);
+      rtx neg_block_off = gen_reg_rtx (SImode);
+
+      /* Set up mask with one dirty bit per byte of the mem we are
+	 writing, starting from top bit.  */
+      v_hi = v = -1;
+      v <<= (128 - GET_MODE_SIZE (GET_MODE (mem))) & 63;
+      if ((128 - GET_MODE_SIZE (GET_MODE (mem))) >= 64)
+	{
+	  v_hi = v;
+	  v = 0;
+	}
+      emit_move_insn (dirty_bits, immed_double_const (v, v_hi, TImode));
+
+      /* Form index into cache dirty_bits.  eq_index is one of
+	 0x10, 0x14, 0x18 or 0x1c.  Multiplying by 4 gives us
+	 0x40, 0x50, 0x60 or 0x70 which just happens to be the
+	 offset to each of the four dirty_bits elements.  */
+      emit_insn (gen_ashlsi3 (dirty_off, eq_index, spu_const (SImode, 2)));
+
+      emit_insn (gen_spu_lqx (dirty_128, tag_addr, dirty_off));
+
+      /* Rotate bit mask to proper bit.  */
+      emit_insn (gen_negsi2 (neg_block_off, block_off));
+      emit_insn (gen_rotqbybi_ti (dirty_bits, dirty_bits, neg_block_off));
+      emit_insn (gen_rotqbi_ti (dirty_bits, dirty_bits, neg_block_off));
+
+      /* Or in the new dirty bits.  */
+      emit_insn (gen_iorti3 (dirty_128, dirty_bits, dirty_128));
+
+      /* Store.  */
+      emit_insn (gen_spu_stqx (dirty_128, tag_addr, dirty_off));
+    }
+
+  emit_label (cont_label);
+}
+
+static rtx
+expand_ea_mem (rtx mem, bool is_store)
+{
+  rtx ea_addr;
+  rtx data_addr = gen_reg_rtx (Pmode);
+  rtx new_mem;
+
+  ea_addr = force_reg (EAmode, XEXP (mem, 0));
+  if (optimize_size || optimize == 0)
+    ea_load_store (mem, is_store, ea_addr, data_addr);
+  else
+    ea_load_store_inline (mem, is_store, ea_addr, data_addr);
+
+  if (ea_alias_set == -1)
+    ea_alias_set = new_alias_set ();
+
+  /* We generate a new MEM RTX to refer to the copy of the data
+     in the cache.  We do not copy memory attributes (except the
+     alignment) from the original MEM, as they may no longer apply
+     to the cache copy.  */
+  new_mem = gen_rtx_MEM (GET_MODE (mem), data_addr);
+  set_mem_alias_set (new_mem, ea_alias_set);
+  set_mem_align (new_mem, MIN (MEM_ALIGN (mem), 128 * 8));
+
+  return new_mem;
+}
+
 int
 spu_expand_mov (rtx * ops, enum machine_mode mode)
 {
@@ -4290,9 +4630,17 @@ spu_expand_mov (rtx * ops, enum machine_
 	}
     }
   if (MEM_P (ops[0]))
-    return spu_split_store (ops);
+    {
+      if (MEM_ADDR_SPACE (ops[0]))
+	ops[0] = expand_ea_mem (ops[0], true);
+      return spu_split_store (ops);
+    }
   if (MEM_P (ops[1]))
-    return spu_split_load (ops);
+    {
+      if (MEM_ADDR_SPACE (ops[1]))
+	ops[1] = expand_ea_mem (ops[1], false);
+      return spu_split_load (ops);
+    }
 
   return 0;
 }
@@ -6415,6 +6763,113 @@ spu_builtin_vec_perm (tree type, tree *m
   return d->fndecl;
 }
 
+/* Return the appropriate mode for a named address pointer.  */
+static enum machine_mode
+spu_addr_space_pointer_mode (addr_space_t addrspace)
+{
+  switch (addrspace)
+    {
+    case ADDR_SPACE_GENERIC:
+      return ptr_mode;
+    case ADDR_SPACE_EA:
+      return EAmode;
+    default:
+      gcc_unreachable ();
+    }
+}
+
+/* Return the appropriate mode for a named address address.  */
+static enum machine_mode
+spu_addr_space_address_mode (addr_space_t addrspace)
+{
+  switch (addrspace)
+    {
+    case ADDR_SPACE_GENERIC:
+      return Pmode;
+    case ADDR_SPACE_EA:
+      return EAmode;
+    default:
+      gcc_unreachable ();
+    }
+}
+
+/* Determine if one named address space is a subset of another.  */
+
+static bool
+spu_addr_space_subset_p (addr_space_t subset, addr_space_t superset)
+{
+  gcc_assert (subset == ADDR_SPACE_GENERIC || subset == ADDR_SPACE_EA);
+  gcc_assert (superset == ADDR_SPACE_GENERIC || superset == ADDR_SPACE_EA);
+
+  if (subset == superset)
+    return true;
+
+  /* If we have -mno-address-space-conversion, treat __ea and generic as not
+     being subsets but instead as disjoint address spaces.  */
+  else if (!TARGET_ADDRESS_SPACE_CONVERSION)
+    return false;
+
+  else
+    return (subset == ADDR_SPACE_GENERIC && superset == ADDR_SPACE_EA);
+}
+
+/* Convert from one address space to another.  */
+static rtx
+spu_addr_space_convert (rtx op, tree from_type, tree to_type)
+{
+  addr_space_t from_as = TYPE_ADDR_SPACE (TREE_TYPE (from_type));
+  addr_space_t to_as = TYPE_ADDR_SPACE (TREE_TYPE (to_type));
+
+  gcc_assert (from_as == ADDR_SPACE_GENERIC || from_as == ADDR_SPACE_EA);
+  gcc_assert (to_as == ADDR_SPACE_GENERIC || to_as == ADDR_SPACE_EA);
+
+  if (to_as == ADDR_SPACE_GENERIC && from_as == ADDR_SPACE_EA)
+    {
+      rtx result, ls;
+
+      ls = gen_const_mem (DImode,
+			  gen_rtx_SYMBOL_REF (Pmode, "__ea_local_store"));
+      set_mem_align (ls, 128);
+
+      result = gen_reg_rtx (Pmode);
+      ls = force_reg (Pmode, convert_modes (Pmode, DImode, ls, 1));
+      op = force_reg (Pmode, convert_modes (Pmode, EAmode, op, 1));
+      ls = emit_conditional_move (ls, NE, op, const0_rtx, Pmode,
+					  ls, const0_rtx, Pmode, 1);
+
+      emit_insn (gen_subsi3 (result, op, ls));
+
+      return result;
+    }
+
+  else if (to_as == ADDR_SPACE_EA && from_as == ADDR_SPACE_GENERIC)
+    {
+      rtx result, ls;
+
+      ls = gen_const_mem (DImode,
+			  gen_rtx_SYMBOL_REF (Pmode, "__ea_local_store"));
+      set_mem_align (ls, 128);
+
+      result = gen_reg_rtx (EAmode);
+      ls = force_reg (EAmode, convert_modes (EAmode, DImode, ls, 1));
+      op = force_reg (Pmode, op);
+      ls = emit_conditional_move (ls, NE, op, const0_rtx, Pmode,
+					  ls, const0_rtx, EAmode, 1);
+      op = force_reg (EAmode, convert_modes (EAmode, Pmode, op, 1));
+
+      if (EAmode == SImode)
+	emit_insn (gen_addsi3 (result, op, ls));
+      else
+	emit_insn (gen_adddi3 (result, op, ls));
+
+      return result;
+    }
+
+  else
+    gcc_unreachable ();
+}
+
+
 /* Count the total number of instructions in each pipe and return the
    maximum, which is used as the Minimum Iteration Interval (MII)
    in the modulo scheduler.  get_pipe() will return -2, -1, 0, or 1.
@@ -6507,9 +6962,46 @@ spu_section_type_flags (tree decl, const
   /* .toe needs to have type @nobits.  */
   if (strcmp (name, ".toe") == 0)
     return SECTION_BSS;
+  /* Don't load _ea into the current address space.  */
+  if (strcmp (name, "._ea") == 0)
+    return SECTION_WRITE | SECTION_DEBUG;
   return default_section_type_flags (decl, name, reloc);
 }
 
+/* Implement targetm.select_section.  */
+static section *
+spu_select_section (tree decl, int reloc, unsigned HOST_WIDE_INT align)
+{
+  /* Variables and constants defined in the __ea address space
+     go into a special section named "._ea".  */
+  if (TREE_TYPE (decl) != error_mark_node
+      && TYPE_ADDR_SPACE (TREE_TYPE (decl)) == ADDR_SPACE_EA)
+    {
+      /* We might get called with string constants, but get_named_section
+	 doesn't like them as they are not DECLs.  Also, we need to set
+	 flags in that case.  */
+      if (!DECL_P (decl))
+	return get_section ("._ea", SECTION_WRITE | SECTION_DEBUG, NULL);
+
+      return get_named_section (decl, "._ea", reloc);
+    }
+
+  return default_elf_select_section (decl, reloc, align);
+}
+
+/* Implement targetm.unique_section.  */
+static void
+spu_unique_section (tree decl, int reloc)
+{
+  /* We don't support unique section names in the __ea address
+     space for now.  */
+  if (TREE_TYPE (decl) != error_mark_node
+      && TYPE_ADDR_SPACE (TREE_TYPE (decl)) != 0)
+    return;
+
+  default_unique_section (decl, reloc);
+}
+
 /* Generate a constant or register which contains 2^SCALE.  We assume
    the result is valid for MODE.  Currently, MODE must be V4SFmode and
    SCALE must be SImode. */
@@ -6558,5 +7050,12 @@ spu_split_convert (rtx ops[])
     }
 }
 
+void
+spu_function_profiler (FILE * file, int labelno)
+{
+  fprintf (file, "# profile\n");
+  fprintf (file, "brsl $75,  _mcount\n");
+}
+
 #include "gt-spu.h"
 
diff -urNp gcc-4.4.4.orig/gcc/config/spu/spu_cache.h gcc-4.4.4/gcc/config/spu/spu_cache.h
--- a/src/gcc/config/spu/spu_cache.h	1970-01-01
+++ b/src/gcc/config/spu/spu_cache.h	2010-06-30
@@ -0,0 +1,39 @@
+/* Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   Under Section 7 of GPL version 3, you are granted additional
+   permissions described in the GCC Runtime Library Exception, version
+   3.1, as published by the Free Software Foundation.
+
+   You should have received a copy of the GNU General Public License and
+   a copy of the GCC Runtime Library Exception along with this program;
+   see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SPU_CACHE_H
+#define _SPU_CACHE_H
+
+void *__cache_fetch_dirty (__ea void *ea, int n_bytes_dirty);
+void *__cache_fetch (__ea void *ea);
+void __cache_evict (__ea void *ea);
+void __cache_flush (void);
+void __cache_touch (__ea void *ea);
+
+#define cache_fetch_dirty(_ea, _n_bytes_dirty) \
+     __cache_fetch_dirty(_ea, _n_bytes_dirty)
+
+#define cache_fetch(_ea) __cache_fetch(_ea)
+#define cache_touch(_ea) __cache_touch(_ea)
+#define cache_evict(_ea) __cache_evict(_ea)
+#define cache_flush() __cache_flush()
+
+#endif
diff -urNp gcc-4.4.4.orig/gcc/config/spu/spu-c.c gcc-4.4.4/gcc/config/spu/spu-c.c
--- a/src/gcc/config/spu/spu-c.c	2010-02-19
+++ b/src/gcc/config/spu/spu-c.c	2010-06-30
@@ -199,6 +199,17 @@ spu_cpu_cpp_builtins (struct cpp_reader 
   if (spu_arch == PROCESSOR_CELLEDP)
     builtin_define_std ("__SPU_EDP__");
   builtin_define_std ("__vector=__attribute__((__spu_vector__))");
+  switch (spu_ea_model)
+    {
+    case 32:
+      builtin_define_std ("__EA32__");
+      break;
+    case 64:
+      builtin_define_std ("__EA64__");
+      break;
+    default:
+       gcc_unreachable ();
+    }
 
   if (!flag_iso)
     {
diff -urNp gcc-4.4.4.orig/gcc/config/spu/spu-elf.h gcc-4.4.4/gcc/config/spu/spu-elf.h
--- a/src/gcc/config/spu/spu-elf.h	2009-02-20
+++ b/src/gcc/config/spu/spu-elf.h	2010-06-30
@@ -48,8 +48,9 @@
    object constructed before entering `main'.  */
 
 #undef  STARTFILE_SPEC 
-#define STARTFILE_SPEC "%{mstdmain: crt2.o%s} %{!mstdmain: crt1.o%s} \
-			crti.o%s crtbegin.o%s"
+#define STARTFILE_SPEC "%{mstdmain: %{pg|p:gcrt2.o%s;:crt2.o%s}}\
+                        %{!mstdmain: %{pg|p:gcrt1.o%s;:crt1.o%s}}\
+                        crti.o%s crtbegin.o%s"
 
 #undef  ENDFILE_SPEC
 #define ENDFILE_SPEC   "crtend.o%s crtn.o%s"
@@ -68,8 +69,14 @@
 
 #define LINK_SPEC "%{mlarge-mem: --defsym __stack=0xfffffff0 }"
 
-#define LIB_SPEC \
-	"-( %{!shared:%{g*:-lg}} -lc -lgloss -)"
+#define LIB_SPEC "-( %{!shared:%{g*:-lg}} -lc -lgloss -) \
+    %{mno-atomic-updates:-lgcc_cachemgr_nonatomic; :-lgcc_cachemgr} \
+    %{mcache-size=128:-lgcc_cache128k; \
+      mcache-size=64 :-lgcc_cache64k; \
+      mcache-size=32 :-lgcc_cache32k; \
+      mcache-size=16 :-lgcc_cache16k; \
+      mcache-size=8  :-lgcc_cache8k; \
+                     :-lgcc_cache64k}"
 
 /* Turn off warnings in the assembler too. */
 #undef ASM_SPEC
diff -urNp gcc-4.4.4.orig/gcc/config/spu/spu.h gcc-4.4.4/gcc/config/spu/spu.h
--- a/src/gcc/config/spu/spu.h	2010-06-30
+++ b/src/gcc/config/spu/spu.h	2010-06-30
@@ -51,7 +51,7 @@ extern GTY(()) int spu_tune;
 /* Default target_flags if no switches specified.  */
 #ifndef TARGET_DEFAULT
 #define TARGET_DEFAULT (MASK_ERROR_RELOC | MASK_SAFE_DMA | MASK_BRANCH_HINTS \
-			| MASK_SAFE_HINTS)
+			| MASK_SAFE_HINTS | MASK_ADDRESS_SPACE_CONVERSION)
 #endif
 
 
@@ -396,9 +396,12 @@ targetm.resolve_overloaded_builtin = spu
 
 /* Profiling */
 
-/* Nothing, for now. */
 #define FUNCTION_PROFILER(FILE, LABELNO)  \
-   fprintf (FILE, "\t\n")
+  spu_function_profiler ((FILE), (LABELNO));
+
+#define NO_PROFILE_COUNTERS 1
+
+#define PROFILE_BEFORE_PROLOGUE 1
 
 
 /* Trampolines */
@@ -498,6 +501,17 @@ targetm.resolve_overloaded_builtin = spu
 #define ASM_OUTPUT_LABELREF(FILE, NAME) \
   asm_fprintf (FILE, "%U%s", default_strip_name_encoding (NAME))
 
+#define ASM_OUTPUT_SYMBOL_REF(FILE, X) \
+  do							\
+    {							\
+      tree decl;					\
+      assemble_name (FILE, XSTR ((X), 0));		\
+      if ((decl = SYMBOL_REF_DECL ((X))) != 0		\
+	  && TREE_CODE (decl) == VAR_DECL		\
+	  && TYPE_ADDR_SPACE (TREE_TYPE (decl)))	\
+	fputs ("@ppu", FILE);				\
+    } while (0)
+
 
 /* Instruction Output */
 #define REGISTER_NAMES \
@@ -624,6 +638,13 @@ extern GTY(()) rtx spu_compare_op0;
 extern GTY(()) rtx spu_compare_op1;
 
 
+/* Address spaces.  */
+#define ADDR_SPACE_EA	1
+
+/* Named address space keywords.  */
+#define TARGET_ADDR_SPACE_KEYWORDS ADDR_SPACE_KEYWORD ("__ea", ADDR_SPACE_EA)
+
+
 /* Builtins.  */
 
 enum spu_builtin_type
diff -urNp gcc-4.4.4.orig/gcc/config/spu/spu.opt gcc-4.4.4/gcc/config/spu/spu.opt
--- a/src/gcc/config/spu/spu.opt	2009-02-20
+++ b/src/gcc/config/spu/spu.opt	2010-06-30
@@ -82,3 +82,24 @@ Generate code for given CPU
 mtune=
 Target RejectNegative Joined Var(spu_tune_string)
 Schedule code for given CPU
+
+mea32
+Target Report RejectNegative Var(spu_ea_model,32) Init(32)
+Access variables in 32-bit PPU objects (default)
+
+mea64
+Target Report RejectNegative Var(spu_ea_model,64) VarExists
+Access variables in 64-bit PPU objects
+
+maddress-space-conversion
+Target Report Mask(ADDRESS_SPACE_CONVERSION)
+Allow conversions between __ea and generic pointers (default)
+
+mcache-size=
+Target Report RejectNegative Joined UInteger
+Size (in KB) of software data cache
+
+matomic-updates
+Target Report
+Atomically write back software data cache lines (default)
+
diff -urNp gcc-4.4.4.orig/gcc/config/spu/spu-protos.h gcc-4.4.4/gcc/config/spu/spu-protos.h
--- a/src/gcc/config/spu/spu-protos.h	2009-12-04
+++ b/src/gcc/config/spu/spu-protos.h	2010-06-30
@@ -90,6 +90,7 @@ extern void spu_expand_sign_extend (rtx 
 extern void spu_expand_vector_init (rtx target, rtx vals);
 extern void spu_init_expanders (void);
 extern void spu_split_convert (rtx *);
+extern void spu_function_profiler (FILE *, int);
 
 /* spu-c.c */
 extern tree spu_resolve_overloaded_builtin (tree fndecl, tree fnargs);
diff -urNp gcc-4.4.4.orig/gcc/config/spu/t-spu-elf gcc-4.4.4/gcc/config/spu/t-spu-elf
--- a/src/gcc/config/spu/t-spu-elf	2009-04-24
+++ b/src/gcc/config/spu/t-spu-elf	2010-06-30
@@ -66,14 +66,39 @@ fp-bit.c: $(srcdir)/config/fp-bit.c $(sr
 # Don't let CTOR_LIST end up in sdata section.
 CRTSTUFF_T_CFLAGS =
 
-#MULTILIB_OPTIONS=mlarge-mem/mtest-abi
-#MULTILIB_DIRNAMES=large-mem test-abi
-#MULTILIB_MATCHES=
+# Multi-lib support.
+MULTILIB_OPTIONS=mea64
 
 # Neither gcc or newlib seem to have a standard way to generate multiple
 # crt*.o files.  So we don't use the standard crt0.o name anymore.
 
-EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o
+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o libgcc_cachemgr.a libgcc_cachemgr_nonatomic.a \
+	libgcc_cache8k.a libgcc_cache16k.a libgcc_cache32k.a libgcc_cache64k.a libgcc_cache128k.a
+
+$(T)cachemgr.o: $(srcdir)/config/spu/cachemgr.c
+	$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(MULTILIB_CFLAGS) -c $< -o $@
+
+# Specialised rule to add a -D flag.
+$(T)cachemgr_nonatomic.o: $(srcdir)/config/spu/cachemgr.c
+	$(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(MULTILIB_CFLAGS) -DNONATOMIC -c $< -o $@
+
+$(T)libgcc_%.a: $(T)%.o
+	$(AR_FOR_TARGET) -rcs $@ $<
+
+$(T)cache8k.o: $(srcdir)/config/spu/cache.S
+	$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -D__CACHE_SIZE__=8 -o $@ -c $<
+
+$(T)cache16k.o: $(srcdir)/config/spu/cache.S
+	$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -D__CACHE_SIZE__=16 -o $@ -c $<
+
+$(T)cache32k.o: $(srcdir)/config/spu/cache.S
+	$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -D__CACHE_SIZE__=32 -o $@ -c $<
+
+$(T)cache64k.o: $(srcdir)/config/spu/cache.S
+	$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -D__CACHE_SIZE__=64 -o $@ -c $<
+
+$(T)cache128k.o: $(srcdir)/config/spu/cache.S
+	$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -D__CACHE_SIZE__=128 -o $@ -c $<
 
 LIBGCC = stmp-multilib
 INSTALL_LIBGCC = install-multilib
diff -urNp gcc-4.4.4.orig/gcc/config.gcc gcc-4.4.4/gcc/config.gcc
--- a/src/gcc/config.gcc	2010-06-30
+++ b/src/gcc/config.gcc	2010-06-30
@@ -2515,7 +2515,7 @@ sparc64-*-netbsd*)
 spu-*-elf*)
 	tm_file="dbxelf.h elfos.h spu/spu-elf.h spu/spu.h"
 	tmake_file="spu/t-spu-elf"
-	extra_headers="spu_intrinsics.h spu_internals.h vmx2spu.h spu_mfcio.h vec_types.h"
+	extra_headers="spu_intrinsics.h spu_internals.h vmx2spu.h spu_mfcio.h vec_types.h spu_cache.h"
 	extra_modes=spu/spu-modes.def
 	c_target_objs="${c_target_objs} spu-c.o"
 	cxx_target_objs="${cxx_target_objs} spu-c.o"
diff -urNp gcc-4.4.4.orig/gcc/convert.c gcc-4.4.4/gcc/convert.c
--- a/src/gcc/convert.c	2009-07-01
+++ b/src/gcc/convert.c	2010-06-30
@@ -53,15 +53,35 @@ convert_to_pointer (tree type, tree expr
     {
     case POINTER_TYPE:
     case REFERENCE_TYPE:
-      return fold_build1 (NOP_EXPR, type, expr);
+      {
+	/* If the pointers point to different address spaces, conversion needs
+	   to be done via a ADDR_SPACE_CONVERT_EXPR instead of a NOP_EXPR.  */
+	addr_space_t to_as = TYPE_ADDR_SPACE (TREE_TYPE (type));
+	addr_space_t from_as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (expr)));
+
+	if (to_as == from_as)
+	  return fold_build1 (NOP_EXPR, type, expr);
+	else
+	  return fold_build1 (ADDR_SPACE_CONVERT_EXPR, type, expr);
+      }
 
     case INTEGER_TYPE:
     case ENUMERAL_TYPE:
     case BOOLEAN_TYPE:
-      if (TYPE_PRECISION (TREE_TYPE (expr)) != POINTER_SIZE)
-	expr = fold_build1 (NOP_EXPR,
-                            lang_hooks.types.type_for_size (POINTER_SIZE, 0),
-			    expr);
+      {
+	/* If the input precision differs from the target pointer type
+	   precision, first convert the input expression to an integer type of
+	   the target precision.  Some targets, e.g. VMS, need several pointer
+	   sizes to coexist so the latter isn't necessarily POINTER_SIZE.  */
+	unsigned int pprec = TYPE_PRECISION (type);
+	unsigned int eprec = TYPE_PRECISION (TREE_TYPE (expr));
+
+	if (eprec != pprec)
+	  expr = fold_build1 (NOP_EXPR,
+			      lang_hooks.types.type_for_size (pprec, 0),
+			      expr);
+      }
+
       return fold_build1 (CONVERT_EXPR, type, expr);
 
 
@@ -488,10 +508,13 @@ convert_to_integer (tree type, tree expr
       if (integer_zerop (expr))
 	return build_int_cst (type, 0);
 
-      /* Convert to an unsigned integer of the correct width first,
-	 and from there widen/truncate to the required type.  */
+      /* Convert to an unsigned integer of the correct width first, and from
+	 there widen/truncate to the required type.  Some targets support the
+	 coexistence of multiple valid pointer sizes, so fetch the one we need
+	 from the type.  */
       expr = fold_build1 (CONVERT_EXPR,
-			  lang_hooks.types.type_for_size (POINTER_SIZE, 0),
+			  lang_hooks.types.type_for_size
+			    (TYPE_PRECISION (intype), 0),
 			  expr);
       return fold_convert (type, expr);
 
diff -urNp gcc-4.4.4.orig/gcc/coretypes.h gcc-4.4.4/gcc/coretypes.h
--- a/src/gcc/coretypes.h	2009-04-10
+++ b/src/gcc/coretypes.h	2010-06-30
@@ -67,6 +67,13 @@ struct gimple_seq_node_d;
 typedef struct gimple_seq_node_d *gimple_seq_node;
 typedef const struct gimple_seq_node_d *const_gimple_seq_node;
 
+/* Address space number for named address space support.  */
+typedef unsigned char addr_space_t;
+
+/* The value of addr_space_t that represents the generic address space.  */
+#define ADDR_SPACE_GENERIC 0
+#define ADDR_SPACE_GENERIC_P(AS) ((AS) == ADDR_SPACE_GENERIC)
+
 /* The major intermediate representations of GCC.  */
 enum ir_type {
   IR_GIMPLE,
diff -urNp gcc-4.4.4.orig/gcc/cp/typeck.c gcc-4.4.4/gcc/cp/typeck.c
--- a/src/gcc/cp/typeck.c	2010-06-30
+++ b/src/gcc/cp/typeck.c	2010-06-30
@@ -3503,7 +3503,11 @@ cp_build_binary_op (location_t location,
     case FLOOR_MOD_EXPR:
       warn_for_div_by_zero (location, op1);
 
-      if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)
+      if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE
+	  && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE
+	  && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE)
+	common = 1;
+      else if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)
 	{
 	  /* Although it would be tempting to shorten always here, that loses
 	     on some targets, since the modulo instruction is undefined if the
diff -urNp gcc-4.4.4.orig/gcc/c-parser.c gcc-4.4.4/gcc/c-parser.c
--- a/src/gcc/c-parser.c	2009-06-23
+++ b/src/gcc/c-parser.c	2010-06-30
@@ -70,6 +70,10 @@ c_parse_init (void)
   tree id;
   int mask = 0;
 
+  /* Make sure RID_MAX hasn't grown past the 8 bits used to hold the keyword in
+     the c_token structure.  */
+  gcc_assert (RID_MAX <= 255);
+
   mask |= D_CXXONLY;
   if (!flag_isoc99)
     mask |= D_C99;
@@ -130,6 +134,8 @@ typedef enum c_id_kind {
   C_ID_TYPENAME,
   /* An identifier declared as an Objective-C class name.  */
   C_ID_CLASSNAME,
+  /* An address space identifier.  */
+  C_ID_ADDRSPACE,
   /* Not an identifier.  */
   C_ID_NONE
 } c_id_kind;
@@ -226,6 +232,13 @@ c_lex_one_token (c_parser *parser, c_tok
 			    "identifier %qs conflicts with C++ keyword",
 			    IDENTIFIER_POINTER (token->value));
 	      }
+	    else if (rid_code >= RID_FIRST_ADDR_SPACE
+		     && rid_code <= RID_LAST_ADDR_SPACE)
+	      {
+		token->id_kind = C_ID_ADDRSPACE;
+		token->keyword = rid_code;
+		break;
+	      }
 	    else if (c_dialect_objc ())
 	      {
 		if (!objc_is_reserved_word (token->value)
@@ -352,6 +365,8 @@ c_token_starts_typename (c_token *token)
 	{
 	case C_ID_ID:
 	  return false;
+	case C_ID_ADDRSPACE:
+	  return true;
 	case C_ID_TYPENAME:
 	  return true;
 	case C_ID_CLASSNAME:
@@ -422,6 +437,8 @@ c_token_starts_declspecs (c_token *token
 	{
 	case C_ID_ID:
 	  return false;
+	case C_ID_ADDRSPACE:
+	  return true;
 	case C_ID_TYPENAME:
 	  return true;
 	case C_ID_CLASSNAME:
@@ -1391,6 +1408,7 @@ c_parser_asm_definition (c_parser *parse
      const
      restrict
      volatile
+     address-space-qualifier
 
    (restrict is new in C99.)
 
@@ -1399,6 +1417,12 @@ c_parser_asm_definition (c_parser *parse
    declaration-specifiers:
      attributes declaration-specifiers[opt]
 
+   type-qualifier:
+     address-space
+
+   address-space:
+     identifier recognized by the target
+
    storage-class-specifier:
      __thread
 
@@ -1438,6 +1462,17 @@ c_parser_declspecs (c_parser *parser, st
 	{
 	  tree value = c_parser_peek_token (parser)->value;
 	  c_id_kind kind = c_parser_peek_token (parser)->id_kind;
+
+	  if (kind == C_ID_ADDRSPACE)
+	    {
+	      addr_space_t as
+		= c_parser_peek_token (parser)->keyword - RID_FIRST_ADDR_SPACE;
+	      declspecs_add_addrspace (specs, as);
+	      c_parser_consume_token (parser);
+	      attrs_ok = true;
+	      continue;
+	    }
+
 	  /* This finishes the specifiers unless a type name is OK, it
 	     is declared as a type name and a type name hasn't yet
 	     been seen.  */
@@ -5549,6 +5584,14 @@ c_parser_postfix_expression_after_paren_
   finish_init ();
   maybe_warn_string_init (type, init);
 
+  if (type != error_mark_node
+      && !ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (type))
+      && current_function_decl)
+    {
+      error ("compound literal qualified by address-space qualifier");
+      type = error_mark_node;
+    }
+
   if (!flag_isoc99)
     pedwarn (start_loc, OPT_pedantic, "ISO C90 forbids compound literals");
   expr.value = build_compound_literal (type, init.value);
diff -urNp gcc-4.4.4.orig/gcc/c-pretty-print.c gcc-4.4.4/gcc/c-pretty-print.c
--- a/src/gcc/c-pretty-print.c	2009-01-09
+++ b/src/gcc/c-pretty-print.c	2010-06-30
@@ -220,7 +220,11 @@ pp_c_space_for_pointer_operator (c_prett
        const
        restrict                              -- C99
        __restrict__                          -- GNU C
-       volatile    */
+       address-space-qualifier		     -- GNU C
+       volatile
+
+   address-space-qualifier:
+       identifier			     -- GNU C  */
 
 void
 pp_c_type_qualifier_list (c_pretty_printer *pp, tree t)
@@ -240,6 +244,12 @@ pp_c_type_qualifier_list (c_pretty_print
     pp_c_cv_qualifier (pp, "volatile");
   if (qualifiers & TYPE_QUAL_RESTRICT)
     pp_c_cv_qualifier (pp, flag_isoc99 ? "restrict" : "__restrict__");
+
+  if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (t)))
+    {
+      const char *as = c_addr_space_name (TYPE_ADDR_SPACE (t));
+      pp_c_identifier (pp, as);
+    }
 }
 
 /* pointer:
diff -urNp gcc-4.4.4.orig/gcc/cse.c gcc-4.4.4/gcc/cse.c
--- a/src/gcc/cse.c	2010-06-30
+++ b/src/gcc/cse.c	2010-06-30
@@ -2435,6 +2435,10 @@ exp_equiv_p (const_rtx x, const_rtx y, i
   if (GET_MODE (x) != GET_MODE (y))
     return 0;
 
+  /* MEMs refering to different address space are not equivalent.  */
+  if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))
+    return 0;
+
   switch (code)
     {
     case PC:
diff -urNp gcc-4.4.4.orig/gcc/cselib.c gcc-4.4.4/gcc/cselib.c
--- a/src/gcc/cselib.c	2009-04-27
+++ b/src/gcc/cselib.c	2010-06-30
@@ -1689,7 +1689,13 @@ cselib_record_sets (rtx insn)
 	    src = gen_rtx_IF_THEN_ELSE (GET_MODE (dest), cond, src, dest);
 	  sets[i].src_elt = cselib_lookup (src, GET_MODE (dest), 1);
 	  if (MEM_P (dest))
-	    sets[i].dest_addr_elt = cselib_lookup (XEXP (dest, 0), Pmode, 1);
+	    {
+	      enum machine_mode address_mode
+		= targetm.addr_space.address_mode (MEM_ADDR_SPACE (dest));
+
+	      sets[i].dest_addr_elt = cselib_lookup (XEXP (dest, 0),
+						     address_mode, 1);
+	    }
 	  else
 	    sets[i].dest_addr_elt = 0;
 	}
diff -urNp gcc-4.4.4.orig/gcc/c-tree.h gcc-4.4.4/gcc/c-tree.h
--- a/src/gcc/c-tree.h	2010-06-30
+++ b/src/gcc/c-tree.h	2010-06-30
@@ -287,6 +287,8 @@ struct c_declspecs {
   BOOL_BITFIELD restrict_p : 1;
   /* Whether "_Sat" was specified.  */
   BOOL_BITFIELD saturating_p : 1;
+  /* The address space that the declaration belongs to.  */
+  addr_space_t address_space;
 };
 
 /* The various kinds of declarators in C.  */
@@ -517,6 +519,8 @@ extern struct c_declspecs *declspecs_add
 					       struct c_typespec);
 extern struct c_declspecs *declspecs_add_scspec (struct c_declspecs *, tree);
 extern struct c_declspecs *declspecs_add_attrs (struct c_declspecs *, tree);
+extern struct c_declspecs *declspecs_add_addrspace (struct c_declspecs *,
+						    addr_space_t);
 extern struct c_declspecs *finish_declspecs (struct c_declspecs *);
 
 /* in c-objc-common.c */
diff -urNp gcc-4.4.4.orig/gcc/c-typeck.c gcc-4.4.4/gcc/c-typeck.c
--- a/src/gcc/c-typeck.c	2010-06-30
+++ b/src/gcc/c-typeck.c	2010-06-30
@@ -242,14 +242,55 @@ c_type_promotes_to (tree type)
   return type;
 }
 
+/* Return true if between two named address spaces, whether there is a superset
+   named address space that encompasses both address spaces.  If there is a
+   superset, return which address space is the superset.  */
+
+static bool
+addr_space_superset (addr_space_t as1, addr_space_t as2, addr_space_t *common)
+{
+  if (as1 == as2)
+    {
+      *common = as1;
+      return true;
+    }
+  else if (targetm.addr_space.subset_p (as1, as2))
+    {
+      *common = as2;
+      return true;
+    }
+  else if (targetm.addr_space.subset_p (as2, as1))
+    {
+      *common = as1;
+      return true;
+    }
+  else
+    return false;
+}
+
 /* Return a variant of TYPE which has all the type qualifiers of LIKE
    as well as those of TYPE.  */
 
 static tree
 qualify_type (tree type, tree like)
 {
+  addr_space_t as_type = TYPE_ADDR_SPACE (type);
+  addr_space_t as_like = TYPE_ADDR_SPACE (like);
+  addr_space_t as_common;
+
+  /* If the two named address spaces are different, determine the common
+     superset address space.  If there isn't one, raise an error.  */
+  if (!addr_space_superset (as_type, as_like, &as_common))
+    {
+      as_common = as_type;
+      error ("%qT and %qT are in disjoint named address spaces",
+	     type, like);
+    }
+
   return c_build_qualified_type (type,
-				 TYPE_QUALS (type) | TYPE_QUALS (like));
+				 TYPE_QUALS_NO_ADDR_SPACE (type)
+				 | TYPE_QUALS_NO_ADDR_SPACE (like)
+				 | ENCODE_QUAL_ADDR_SPACE (as_common));
 }
 
 /* Return true iff the given tree T is a variable length array.  */
@@ -329,7 +370,8 @@ composite_type (tree t1, tree t2)
 	bool t1_complete, t2_complete;
 
 	/* We should not have any type quals on arrays at all.  */
-	gcc_assert (!TYPE_QUALS (t1) && !TYPE_QUALS (t2));
+	gcc_assert (!TYPE_QUALS_NO_ADDR_SPACE (t1)
+		    && !TYPE_QUALS_NO_ADDR_SPACE (t2));
 
 	t1_complete = COMPLETE_TYPE_P (t1);
 	t2_complete = COMPLETE_TYPE_P (t2);
@@ -543,6 +585,8 @@ common_pointer_type (tree t1, tree t2)
   tree pointed_to_2, mv2;
   tree target;
   unsigned target_quals;
+  addr_space_t as1, as2, as_common;
+  int quals1, quals2;
 
   /* Save time if the two types are the same.  */
 
@@ -574,10 +618,24 @@ common_pointer_type (tree t1, tree t2)
   /* For function types do not merge const qualifiers, but drop them
      if used inconsistently.  The middle-end uses these to mark const
      and noreturn functions.  */
+  quals1 = TYPE_QUALS_NO_ADDR_SPACE (pointed_to_1);
+  quals2 = TYPE_QUALS_NO_ADDR_SPACE (pointed_to_2);
+
   if (TREE_CODE (pointed_to_1) == FUNCTION_TYPE)
-    target_quals = TYPE_QUALS (pointed_to_1) & TYPE_QUALS (pointed_to_2);
+    target_quals = (quals1 & quals2);
   else
-    target_quals = TYPE_QUALS (pointed_to_1) | TYPE_QUALS (pointed_to_2);
+    target_quals = (quals1 | quals2);
+
+  /* If the two named address spaces are different, determine the common
+     superset address space.  This is guaranteed to exist due to the
+     assumption that comp_target_type returned non-zero.  */
+  as1 = TYPE_ADDR_SPACE (pointed_to_1);
+  as2 = TYPE_ADDR_SPACE (pointed_to_2);
+  if (!addr_space_superset (as1, as2, &as_common))
+    gcc_unreachable ();
+
+  target_quals |= ENCODE_QUAL_ADDR_SPACE (as_common);
+
   t1 = build_pointer_type (c_build_qualified_type (target, target_quals));
   return build_type_attribute_variant (t1, attributes);
 }
@@ -1032,14 +1090,24 @@ comptypes_internal (const_tree type1, co
   return attrval == 2 && val == 1 ? 2 : val;
 }
 
-/* Return 1 if TTL and TTR are pointers to types that are equivalent,
-   ignoring their qualifiers.  */
+/* Return 1 if TTL and TTR are pointers to types that are equivalent, ignoring
+   their qualifiers, except for named address spaces.  If the pointers point to
+   different named addresses, then we must determine if one address space is a
+   subset of the other.  */
 
 static int
 comp_target_types (tree ttl, tree ttr)
 {
   int val;
-  tree mvl, mvr;
+  tree mvl = TREE_TYPE (ttl);
+  tree mvr = TREE_TYPE (ttr);
+  addr_space_t asl = TYPE_ADDR_SPACE (mvl);
+  addr_space_t asr = TYPE_ADDR_SPACE (mvr);
+  addr_space_t as_common;
+
+  /* Fail if pointers point to incompatible address spaces.  */
+  if (!addr_space_superset (asl, asr, &as_common))
+    return 0;
 
   /* Do not lose qualifiers on element types of array types that are
      pointer targets by taking their TYPE_MAIN_VARIANT.  */
@@ -2845,11 +2913,43 @@ static tree
 pointer_diff (tree op0, tree op1)
 {
   tree restype = ptrdiff_type_node;
+  tree result, inttype;
 
+  addr_space_t as0 = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (op0)));
+  addr_space_t as1 = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (op1)));
   tree target_type = TREE_TYPE (TREE_TYPE (op0));
   tree con0, con1, lit0, lit1;
   tree orig_op1 = op1;
 
+  /* If the operands point into different address spaces, we need to
+     explicitly convert them to pointers into the common address space
+     before we can subtract the numerical address values.  */
+  if (as0 != as1)
+    {
+      addr_space_t as_common;
+      tree common_type;
+
+      /* Determine the common superset address space.  This is guaranteed
+	 to exist because the caller verified that comp_target_types
+	 returned non-zero.  */
+      if (!addr_space_superset (as0, as1, &as_common))
+	gcc_unreachable ();
+
+      common_type = common_pointer_type (TREE_TYPE (op0), TREE_TYPE (op1));
+      op0 = convert (common_type, op0);
+      op1 = convert (common_type, op1);
+    }
+
+  /* Determine integer type to perform computations in.  This will usually
+     be the same as the result type (ptrdiff_t), but may need to be a wider
+     type if pointers for the address space are wider than ptrdiff_t.  */
+  if (TYPE_PRECISION (restype) < TYPE_PRECISION (TREE_TYPE (op0)))
+    inttype = lang_hooks.types.type_for_size
+		(TYPE_PRECISION (TREE_TYPE (op0)), 0);
+  else
+    inttype = restype;
+
+
   if (TREE_CODE (target_type) == VOID_TYPE)
     pedwarn (input_location, pedantic ? OPT_pedantic : OPT_Wpointer_arith, 
 	     "pointer of type %<void *%> used in subtraction");
@@ -2907,8 +3007,8 @@ pointer_diff (tree op0, tree op1)
      in case restype is a short type.  */
 
   op0 = build_binary_op (input_location,
-			 MINUS_EXPR, convert (restype, op0),
-			 convert (restype, op1), 0);
+			 MINUS_EXPR, convert (inttype, op0),
+			 convert (inttype, op1), 0);
   /* This generates an error if op1 is pointer to incomplete type.  */
   if (!COMPLETE_OR_VOID_TYPE_P (TREE_TYPE (TREE_TYPE (orig_op1))))
     error ("arithmetic on pointer to an incomplete type");
@@ -2917,7 +3017,10 @@ pointer_diff (tree op0, tree op1)
   op1 = c_size_in_bytes (target_type);
 
   /* Divide by the size, in easiest possible way.  */
-  return fold_build2 (EXACT_DIV_EXPR, restype, op0, convert (restype, op1));
+  result = fold_build2 (EXACT_DIV_EXPR, inttype, op0, convert (inttype, op1));
+
+  /* Convert to final result type if necessary.  */
+  return convert (restype, result);
 }
 
 /* Construct and perhaps optimize a tree representation
@@ -3532,12 +3635,22 @@ build_conditional_expr (tree ifexp, tree
     }
   else if (code1 == POINTER_TYPE && code2 == POINTER_TYPE)
     {
+      addr_space_t as1 = TYPE_ADDR_SPACE (TREE_TYPE (type1));
+      addr_space_t as2 = TYPE_ADDR_SPACE (TREE_TYPE (type2));
+      addr_space_t as_common;
+
       if (comp_target_types (type1, type2))
 	result_type = common_pointer_type (type1, type2);
       else if (null_pointer_constant_p (orig_op1))
-	result_type = qualify_type (type2, type1);
+	result_type = type2;
       else if (null_pointer_constant_p (orig_op2))
-	result_type = qualify_type (type1, type2);
+	result_type = type1;
+      else if (!addr_space_superset (as1, as2, &as_common))
+	{
+	  error ("pointers to disjoint address spaces "
+		 "used in conditional expression");
+	  return error_mark_node;
+	}
       else if (VOID_TYPE_P (TREE_TYPE (type1)))
 	{
 	  if (TREE_CODE (TREE_TYPE (type2)) == FUNCTION_TYPE)
@@ -3558,10 +3671,13 @@ build_conditional_expr (tree ifexp, tree
 	}
       else
 	{
+	  int qual = ENCODE_QUAL_ADDR_SPACE (as_common);
+
 	  if (!objc_ok)
 	    pedwarn (input_location, 0, 
 		     "pointer type mismatch in conditional expression");
-	  result_type = build_pointer_type (void_type_node);
+	  result_type = build_pointer_type
+			  (build_qualified_type (void_type_node, qual));
 	}
     }
   else if (code1 == POINTER_TYPE && code2 == INTEGER_TYPE)
@@ -3729,7 +3845,9 @@ build_c_cast (tree type, tree expr)
 
       otype = TREE_TYPE (value);
 
-      /* Optionally warn about potentially worrisome casts.  */
+      /* Optionally warn about potentially worrisome casts.
+	 Named address space qualifiers are handled below,
+	 because they result in different warnings.  */
 
       if (warn_cast_qual
 	  && TREE_CODE (type) == POINTER_TYPE
@@ -3755,9 +3873,11 @@ build_c_cast (tree type, tree expr)
 		 are added, not when they're taken away.  */
 	      if (TREE_CODE (in_otype) == FUNCTION_TYPE
 		  && TREE_CODE (in_type) == FUNCTION_TYPE)
-		added |= (TYPE_QUALS (in_type) & ~TYPE_QUALS (in_otype));
+		added |= (TYPE_QUALS_NO_ADDR_SPACE (in_type)
+			  & ~TYPE_QUALS_NO_ADDR_SPACE (in_otype));
 	      else
-		discarded |= (TYPE_QUALS (in_otype) & ~TYPE_QUALS (in_type));
+		discarded |= (TYPE_QUALS_NO_ADDR_SPACE (in_otype)
+			      & ~TYPE_QUALS_NO_ADDR_SPACE (in_type));
 	    }
 	  while (TREE_CODE (in_type) == POINTER_TYPE
 		 && TREE_CODE (in_otype) == POINTER_TYPE);
@@ -3771,6 +3891,36 @@ build_c_cast (tree type, tree expr)
 	    warning (OPT_Wcast_qual, "cast discards qualifiers from pointer target type");
 	}
 
+      /* Warn about conversions between pointers to disjoint
+	 address spaces.  */
+      if (TREE_CODE (type) == POINTER_TYPE
+	  && TREE_CODE (otype) == POINTER_TYPE
+	  && !null_pointer_constant_p (value))
+	{
+	  addr_space_t as_to = TYPE_ADDR_SPACE (TREE_TYPE (type));
+	  addr_space_t as_from = TYPE_ADDR_SPACE (TREE_TYPE (otype));
+	  addr_space_t as_common;
+
+	  if (!addr_space_superset (as_to, as_from, &as_common))
+	    {
+	      if (ADDR_SPACE_GENERIC_P (as_from))
+		warning (0, "cast to %s address space pointer "
+			 "from disjoint generic address space pointer",
+			 c_addr_space_name (as_to));
+
+	      else if (ADDR_SPACE_GENERIC_P (as_to))
+		warning (0, "cast to generic address space pointer "
+			 "from disjoint %s address space pointer",
+			 c_addr_space_name (as_from));
+
+	      else
+		warning (0, "cast to %s address space pointer "
+			 "from disjoint %s address space pointer",
+			 c_addr_space_name (as_to),
+			 c_addr_space_name (as_from));
+	    }
+	}
+
       /* Warn about possible alignment problems.  */
       if (STRICT_ALIGNMENT
 	  && TREE_CODE (type) == POINTER_TYPE
@@ -4232,7 +4382,8 @@ convert_for_assignment (tree type, tree 
 		     certain things, it is okay to use a const or volatile
 		     function where an ordinary one is wanted, but not
 		     vice-versa.  */
-		  if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))
+		  if (TYPE_QUALS_NO_ADDR_SPACE (ttl)
+		      & ~TYPE_QUALS_NO_ADDR_SPACE (ttr))
 		    WARN_FOR_ASSIGNMENT (input_location, 0,
 					 G_("passing argument %d of %qE "
 					    "makes qualified function "
@@ -4246,7 +4397,8 @@ convert_for_assignment (tree type, tree 
 					 G_("return makes qualified function "
 					    "pointer from unqualified"));
 		}
-	      else if (TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl))
+	      else if (TYPE_QUALS_NO_ADDR_SPACE (ttr)
+		       & ~TYPE_QUALS_NO_ADDR_SPACE (ttl))
 		WARN_FOR_ASSIGNMENT (input_location, 0,
 				     G_("passing argument %d of %qE discards "
 					"qualifiers from pointer target type"),
@@ -4279,6 +4431,8 @@ convert_for_assignment (tree type, tree 
       tree mvr = ttr;
       bool is_opaque_pointer;
       int target_cmp = 0;   /* Cache comp_target_types () result.  */
+      addr_space_t asl;
+      addr_space_t asr;
 
       if (TREE_CODE (mvl) != ARRAY_TYPE)
 	mvl = TYPE_MAIN_VARIANT (mvl);
@@ -4298,6 +4452,36 @@ convert_for_assignment (tree type, tree 
 	warning (OPT_Wc___compat, "request for implicit conversion from "
 		 "%qT to %qT not permitted in C++", rhstype, type);
 
+      /* See if the pointers point to incompatible address spaces.  */
+      asl = TYPE_ADDR_SPACE (ttl);
+      asr = TYPE_ADDR_SPACE (ttr);
+      if (!null_pointer_constant_p (rhs)
+	  && asr != asl && !targetm.addr_space.subset_p (asr, asl))
+	{
+	  switch (errtype)
+	    {
+	    case ic_argpass:
+	      error ("passing argument %d of %qE from pointer to "
+		     "non-enclosed address space", parmnum, rname);
+	      break;
+	    case ic_assign:
+	      error ("assignment from pointer to "
+		     "non-enclosed address space");
+	      break;
+	    case ic_init:
+	      error ("initialization from pointer to "
+		     "non-enclosed address space");
+	      break;
+	    case ic_return:
+	      error ("return from pointer to "
+		     "non-enclosed address space");
+	      break;
+	    default:
+	      gcc_unreachable ();
+	    }
+	  return error_mark_node;
+	}
+
       /* Check if the right-hand side has a format attribute but the
 	 left-hand side doesn't.  */
       if (warn_missing_format_attribute
@@ -4361,7 +4545,8 @@ convert_for_assignment (tree type, tree 
 	  else if (TREE_CODE (ttr) != FUNCTION_TYPE
 		   && TREE_CODE (ttl) != FUNCTION_TYPE)
 	    {
-	      if (TYPE_QUALS (ttr) & ~TYPE_QUALS (ttl))
+	      if (TYPE_QUALS_NO_ADDR_SPACE (ttr)
+		  & ~TYPE_QUALS_NO_ADDR_SPACE (ttl))
 		{
 		  /* Types differing only by the presence of the 'volatile'
 		     qualifier are acceptable if the 'volatile' has been added
@@ -4401,7 +4586,8 @@ convert_for_assignment (tree type, tree 
 		 that say the function will not do certain things,
 		 it is okay to use a const or volatile function
 		 where an ordinary one is wanted, but not vice-versa.  */
-	      if (TYPE_QUALS (ttl) & ~TYPE_QUALS (ttr))
+	      if (TYPE_QUALS_NO_ADDR_SPACE (ttl)
+		  & ~TYPE_QUALS_NO_ADDR_SPACE (ttr))
 		WARN_FOR_ASSIGNMENT (input_location, 0,
 				     G_("passing argument %d of %qE makes "
 					"qualified function pointer "
@@ -6710,7 +6896,8 @@ process_init_element (struct c_expr valu
 	   || TREE_CODE (constructor_type) == UNION_TYPE)
 	  && constructor_fields == 0)
 	process_init_element (pop_init_level (1), true);
-      else if (TREE_CODE (constructor_type) == ARRAY_TYPE
+      else if ((TREE_CODE (constructor_type) == ARRAY_TYPE
+	        || TREE_CODE (constructor_type) == VECTOR_TYPE)
 	       && (constructor_max_index == 0
 		   || tree_int_cst_lt (constructor_max_index,
 				       constructor_index)))
@@ -6771,7 +6958,7 @@ process_init_element (struct c_expr valu
 		   && value.value != error_mark_node
 		   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != fieldtype
 		   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE
-		       || fieldcode == UNION_TYPE))
+		       || fieldcode == UNION_TYPE || fieldcode == VECTOR_TYPE))
 	    {
 	      push_init_level (1);
 	      continue;
@@ -6861,7 +7048,7 @@ process_init_element (struct c_expr valu
 		   && value.value != error_mark_node
 		   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != fieldtype
 		   && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE
-		       || fieldcode == UNION_TYPE))
+		       || fieldcode == UNION_TYPE || fieldcode == VECTOR_TYPE))
 	    {
 	      push_init_level (1);
 	      continue;
@@ -6901,7 +7088,7 @@ process_init_element (struct c_expr valu
 		   && value.value != error_mark_node
 		   && TYPE_MAIN_VARIANT (TREE_TYPE (value.value)) != elttype
 		   && (eltcode == RECORD_TYPE || eltcode == ARRAY_TYPE
-		       || eltcode == UNION_TYPE))
+		       || eltcode == UNION_TYPE || eltcode == VECTOR_TYPE))
 	    {
 	      push_init_level (1);
 	      continue;
@@ -6949,8 +7136,12 @@ process_init_element (struct c_expr valu
 
 	  /* Now output the actual element.  */
 	  if (value.value)
-	    output_init_element (value.value, strict_string,
-				 elttype, constructor_index, 1, implicit);
+	    {
+	      if (TREE_CODE (value.value) == VECTOR_CST)
+		elttype = TYPE_MAIN_VARIANT (constructor_type);
+	      output_init_element (value.value, strict_string,
+				   elttype, constructor_index, 1, implicit);
+	    }
 
 	  constructor_index
 	    = size_binop (PLUS_EXPR, constructor_index, bitsize_one_node);
@@ -8209,7 +8400,11 @@ build_binary_op (location_t location, en
     case FLOOR_MOD_EXPR:
       warn_for_div_by_zero (location, op1);
 
-      if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)
+      if (code0 == VECTOR_TYPE && code1 == VECTOR_TYPE
+	  && TREE_CODE (TREE_TYPE (type0)) == INTEGER_TYPE
+	  && TREE_CODE (TREE_TYPE (type1)) == INTEGER_TYPE)
+	common = 1;
+      else if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)
 	{
 	  /* Although it would be tempting to shorten always here, that loses
 	     on some targets, since the modulo instruction is undefined if the
@@ -8319,24 +8514,34 @@ build_binary_op (location_t location, en
 	{
 	  tree tt0 = TREE_TYPE (type0);
 	  tree tt1 = TREE_TYPE (type1);
+	  addr_space_t as0 = TYPE_ADDR_SPACE (tt0);
+	  addr_space_t as1 = TYPE_ADDR_SPACE (tt1);
+	  addr_space_t as_common = ADDR_SPACE_GENERIC;
+
 	  /* Anything compares with void *.  void * compares with anything.
 	     Otherwise, the targets must be compatible
 	     and both must be object or both incomplete.  */
 	  if (comp_target_types (type0, type1))
 	    result_type = common_pointer_type (type0, type1);
+	  else if (null_pointer_constant_p (orig_op0))
+	    result_type = type1;
+	  else if (null_pointer_constant_p (orig_op1))
+	    result_type = type0;
+	  else if (!addr_space_superset (as0, as1, &as_common))
+	    {
+	      error_at (location, "comparison of pointers to "
+			"disjoint address spaces");
+	      return error_mark_node;
+	    }
 	  else if (VOID_TYPE_P (tt0))
 	    {
-	      /* op0 != orig_op0 detects the case of something
-		 whose value is 0 but which isn't a valid null ptr const.  */
-	      if (pedantic && !null_pointer_constant_p (orig_op0)
-		  && TREE_CODE (tt1) == FUNCTION_TYPE)
+	      if (pedantic && TREE_CODE (tt1) == FUNCTION_TYPE)
 		pedwarn (location, OPT_pedantic, "ISO C forbids "
 			 "comparison of %<void *%> with function pointer");
 	    }
 	  else if (VOID_TYPE_P (tt1))
 	    {
-	      if (pedantic && !null_pointer_constant_p (orig_op1)
-		  && TREE_CODE (tt0) == FUNCTION_TYPE)
+	      if (pedantic && TREE_CODE (tt0) == FUNCTION_TYPE)
 		pedwarn (location, OPT_pedantic, "ISO C forbids "
 			 "comparison of %<void *%> with function pointer");
 	    }
@@ -8347,7 +8552,11 @@ build_binary_op (location_t location, en
 		       "comparison of distinct pointer types lacks a cast");
 
 	  if (result_type == NULL_TREE)
-	    result_type = ptr_type_node;
+	    {
+	      int qual = ENCODE_QUAL_ADDR_SPACE (as_common);
+	      result_type = build_pointer_type
+			      (build_qualified_type (void_type_node, qual));
+	    }
 	}
       else if (code0 == POINTER_TYPE && null_pointer_constant_p (orig_op1))
 	{
@@ -8391,6 +8600,10 @@ build_binary_op (location_t location, en
 	short_compare = 1;
       else if (code0 == POINTER_TYPE && code1 == POINTER_TYPE)
 	{
+	  addr_space_t as0 = TYPE_ADDR_SPACE (TREE_TYPE (type0));
+	  addr_space_t as1 = TYPE_ADDR_SPACE (TREE_TYPE (type1));
+	  addr_space_t as_common;
+
 	  if (comp_target_types (type0, type1))
 	    {
 	      result_type = common_pointer_type (type0, type1);
@@ -8402,9 +8615,17 @@ build_binary_op (location_t location, en
 		pedwarn (location, OPT_pedantic, "ISO C forbids "
 			 "ordered comparisons of pointers to functions");
 	    }
+	  else if (!addr_space_superset (as0, as1, &as_common))
+	    {
+	      error_at (location, "comparison of pointers to "
+			"disjoint address spaces");
+	      return error_mark_node;
+	    }
 	  else
 	    {
-	      result_type = ptr_type_node;
+	      int qual = ENCODE_QUAL_ADDR_SPACE (as_common);
+	      result_type = build_pointer_type
+			      (build_qualified_type (void_type_node, qual));
 	      pedwarn (location, 0,
 		       "comparison of distinct pointer types lacks a cast");
 	    }
diff -urNp gcc-4.4.4.orig/gcc/dse.c gcc-4.4.4/gcc/dse.c
--- a/src/gcc/dse.c	2010-02-04
+++ b/src/gcc/dse.c	2010-06-30
@@ -826,9 +826,9 @@ replace_inc_dec (rtx *r, void *d)
     case POST_INC:
       {
 	rtx r1 = XEXP (x, 0);
-	rtx c = gen_int_mode (data->size, Pmode);
-	emit_insn_before (gen_rtx_SET (Pmode, r1, 
-				       gen_rtx_PLUS (Pmode, r1, c)),
+	rtx c = gen_int_mode (data->size, GET_MODE (r1));
+	emit_insn_before (gen_rtx_SET (VOIDmode, r1,
+				       gen_rtx_PLUS (GET_MODE (r1), r1, c)),
 			  data->insn);
 	return -1;
       }
@@ -837,9 +837,9 @@ replace_inc_dec (rtx *r, void *d)
     case POST_DEC:
       {
 	rtx r1 = XEXP (x, 0);
-	rtx c = gen_int_mode (-data->size, Pmode);
-	emit_insn_before (gen_rtx_SET (Pmode, r1, 
-				       gen_rtx_PLUS (Pmode, r1, c)),
+	rtx c = gen_int_mode (-data->size, GET_MODE (r1));
+	emit_insn_before (gen_rtx_SET (VOIDmode, r1,
+				       gen_rtx_PLUS (GET_MODE (r1), r1, c)),
 			  data->insn);
 	return -1;
       }
@@ -851,7 +851,7 @@ replace_inc_dec (rtx *r, void *d)
 	   insn that contained it.  */
 	rtx add = XEXP (x, 0);
 	rtx r1 = XEXP (add, 0);
-	emit_insn_before (gen_rtx_SET (Pmode, r1, add), data->insn);
+	emit_insn_before (gen_rtx_SET (VOIDmode, r1, add), data->insn);
 	return -1;
       }
 
@@ -1065,6 +1065,8 @@ canon_address (rtx mem,
 	       HOST_WIDE_INT *offset, 
 	       cselib_val **base)
 {
+  enum machine_mode address_mode
+    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (mem));
   rtx mem_address = XEXP (mem, 0);
   rtx expanded_address, address;
   int expanded;
@@ -1104,7 +1106,7 @@ canon_address (rtx mem,
 
   *alias_set_out = 0;
 
-  cselib_lookup (mem_address, Pmode, 1);
+  cselib_lookup (mem_address, address_mode, 1);
 
   if (dump_file)
     {
@@ -1170,7 +1172,8 @@ canon_address (rtx mem,
 	  address = XEXP (address, 0);
 	}
 
-      if (const_or_frame_p (address))
+      if (ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (mem))
+	  && const_or_frame_p (address))
 	{
 	  group_info_t group = get_group_info (address);
 
@@ -1183,7 +1186,7 @@ canon_address (rtx mem,
 	}
     }
 
-  *base = cselib_lookup (address, Pmode, true);
+  *base = cselib_lookup (address, address_mode, true);
   *group_id = -1;
 
   if (*base == NULL)
diff -urNp gcc-4.4.4.orig/gcc/dwarf2out.c gcc-4.4.4/gcc/dwarf2out.c
--- a/src/gcc/dwarf2out.c	2010-06-30
+++ b/src/gcc/dwarf2out.c	2010-06-30
@@ -9610,6 +9610,9 @@ modified_type_die (tree type, int is_con
       add_AT_unsigned (mod_type_die, DW_AT_byte_size,
 		       simple_type_size_in_bits (type) / BITS_PER_UNIT);
       item_type = TREE_TYPE (type);
+      if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (item_type)))
+	add_AT_unsigned (mod_type_die, DW_AT_address_class,
+			 TYPE_ADDR_SPACE (item_type));
     }
   else if (code == REFERENCE_TYPE)
     {
@@ -9617,6 +9620,9 @@ modified_type_die (tree type, int is_con
       add_AT_unsigned (mod_type_die, DW_AT_byte_size,
 		       simple_type_size_in_bits (type) / BITS_PER_UNIT);
       item_type = TREE_TYPE (type);
+      if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (item_type)))
+	add_AT_unsigned (mod_type_die, DW_AT_address_class,
+			 TYPE_ADDR_SPACE (item_type));
     }
   else if (is_subrange_type (type))
     {
diff -urNp gcc-4.4.4.orig/gcc/emit-rtl.c gcc-4.4.4/gcc/emit-rtl.c
--- a/src/gcc/emit-rtl.c	2009-07-11
+++ b/src/gcc/emit-rtl.c	2010-06-30
@@ -58,6 +58,7 @@ along with GCC; see the file COPYING3.  
 #include "langhooks.h"
 #include "tree-pass.h"
 #include "df.h"
+#include "target.h"
 
 /* Commonly used modes.  */
 
@@ -193,7 +194,7 @@ static rtx lookup_const_fixed (rtx);
 static hashval_t mem_attrs_htab_hash (const void *);
 static int mem_attrs_htab_eq (const void *, const void *);
 static mem_attrs *get_mem_attrs (alias_set_type, tree, rtx, rtx, unsigned int,
-				 enum machine_mode);
+				 addr_space_t, enum machine_mode);
 static hashval_t reg_attrs_htab_hash (const void *);
 static int reg_attrs_htab_eq (const void *, const void *);
 static reg_attrs *get_reg_attrs (tree, int);
@@ -293,6 +294,7 @@ mem_attrs_htab_hash (const void *x)
   const mem_attrs *const p = (const mem_attrs *) x;
 
   return (p->alias ^ (p->align * 1000)
+	  ^ (p->addrspace * 4000)
 	  ^ ((p->offset ? INTVAL (p->offset) : 0) * 50000)
 	  ^ ((p->size ? INTVAL (p->size) : 0) * 2500000)
 	  ^ (size_t) iterative_hash_expr (p->expr, 0));
@@ -310,6 +312,7 @@ mem_attrs_htab_eq (const void *x, const 
 
   return (p->alias == q->alias && p->offset == q->offset
 	  && p->size == q->size && p->align == q->align
+	  && p->addrspace == q->addrspace
 	  && (p->expr == q->expr
 	      || (p->expr != NULL_TREE && q->expr != NULL_TREE
 		  && operand_equal_p (p->expr, q->expr, 0))));
@@ -321,7 +324,7 @@ mem_attrs_htab_eq (const void *x, const 
 
 static mem_attrs *
 get_mem_attrs (alias_set_type alias, tree expr, rtx offset, rtx size,
-	       unsigned int align, enum machine_mode mode)
+	       unsigned int align, addr_space_t addrspace, enum machine_mode mode)
 {
   mem_attrs attrs;
   void **slot;
@@ -329,7 +332,7 @@ get_mem_attrs (alias_set_type alias, tre
   /* If everything is the default, we can just return zero.
      This must match what the corresponding MEM_* macros return when the
      field is not present.  */
-  if (alias == 0 && expr == 0 && offset == 0
+  if (alias == 0 && expr == 0 && offset == 0 && addrspace == 0
       && (size == 0
 	  || (mode != BLKmode && GET_MODE_SIZE (mode) == INTVAL (size)))
       && (STRICT_ALIGNMENT && mode != BLKmode
@@ -341,6 +344,7 @@ get_mem_attrs (alias_set_type alias, tre
   attrs.offset = offset;
   attrs.size = size;
   attrs.align = align;
+  attrs.addrspace = addrspace;
 
   slot = htab_find_slot (mem_attrs_htab, &attrs, INSERT);
   if (*slot == 0)
@@ -1387,7 +1391,9 @@ operand_subword (rtx op, unsigned int of
 
       else if (reload_completed)
 	{
-	  if (! strict_memory_address_p (word_mode, XEXP (new_rtx, 0)))
+	  if (! strict_memory_address_addr_space_p (word_mode,
+						    XEXP (new_rtx, 0),
+						    MEM_ADDR_SPACE (op)))
 	    return 0;
 	}
       else
@@ -1842,7 +1848,8 @@ set_mem_attributes_minus_bitpos (rtx ref
 
   /* Now set the attributes we computed above.  */
   MEM_ATTRS (ref)
-    = get_mem_attrs (alias, expr, offset, size, align, GET_MODE (ref));
+    = get_mem_attrs (alias, expr, offset, size, align,
+		     TYPE_ADDR_SPACE (type), GET_MODE (ref));
 
   /* If this is already known to be a scalar or aggregate, we are done.  */
   if (MEM_IN_STRUCT_P (ref) || MEM_SCALAR_P (ref))
@@ -1870,7 +1877,8 @@ set_mem_attrs_from_reg (rtx mem, rtx reg
   MEM_ATTRS (mem)
     = get_mem_attrs (MEM_ALIAS_SET (mem), REG_EXPR (reg),
 		     GEN_INT (REG_OFFSET (reg)),
-		     MEM_SIZE (mem), MEM_ALIGN (mem), GET_MODE (mem));
+		     MEM_SIZE (mem), MEM_ALIGN (mem),
+		     MEM_ADDR_SPACE (mem), GET_MODE (mem));
 }
 
 /* Set the alias set of MEM to SET.  */
@@ -1885,7 +1893,17 @@ set_mem_alias_set (rtx mem, alias_set_ty
 
   MEM_ATTRS (mem) = get_mem_attrs (set, MEM_EXPR (mem), MEM_OFFSET (mem),
 				   MEM_SIZE (mem), MEM_ALIGN (mem),
-				   GET_MODE (mem));
+				   MEM_ADDR_SPACE (mem), GET_MODE (mem));
+}
+
+/* Set the address space of MEM to ADDRSPACE (target-defined).  */
+
+void
+set_mem_addr_space (rtx mem, addr_space_t addrspace)
+{
+  MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),
+				   MEM_OFFSET (mem), MEM_SIZE (mem),
+				   MEM_ALIGN (mem), addrspace, GET_MODE (mem));
 }
 
 /* Set the alignment of MEM to ALIGN bits.  */
@@ -1895,7 +1913,7 @@ set_mem_align (rtx mem, unsigned int ali
 {
   MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),
 				   MEM_OFFSET (mem), MEM_SIZE (mem), align,
-				   GET_MODE (mem));
+				   MEM_ADDR_SPACE (mem), GET_MODE (mem));
 }
 
 /* Set the expr for MEM to EXPR.  */
@@ -1905,7 +1923,8 @@ set_mem_expr (rtx mem, tree expr)
 {
   MEM_ATTRS (mem)
     = get_mem_attrs (MEM_ALIAS_SET (mem), expr, MEM_OFFSET (mem),
-		     MEM_SIZE (mem), MEM_ALIGN (mem), GET_MODE (mem));
+		     MEM_SIZE (mem), MEM_ALIGN (mem),
+		     MEM_ADDR_SPACE (mem), GET_MODE (mem));
 }
 
 /* Set the offset of MEM to OFFSET.  */
@@ -1915,7 +1934,7 @@ set_mem_offset (rtx mem, rtx offset)
 {
   MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),
 				   offset, MEM_SIZE (mem), MEM_ALIGN (mem),
-				   GET_MODE (mem));
+				   MEM_ADDR_SPACE (mem), GET_MODE (mem));
 }
 
 /* Set the size of MEM to SIZE.  */
@@ -1925,7 +1944,7 @@ set_mem_size (rtx mem, rtx size)
 {
   MEM_ATTRS (mem) = get_mem_attrs (MEM_ALIAS_SET (mem), MEM_EXPR (mem),
 				   MEM_OFFSET (mem), size, MEM_ALIGN (mem),
-				   GET_MODE (mem));
+				   MEM_ADDR_SPACE (mem), GET_MODE (mem));
 }
 
 /* Return a memory reference like MEMREF, but with its mode changed to MODE
@@ -1937,23 +1956,25 @@ set_mem_size (rtx mem, rtx size)
 static rtx
 change_address_1 (rtx memref, enum machine_mode mode, rtx addr, int validate)
 {
+  addr_space_t as;
   rtx new_rtx;
 
   gcc_assert (MEM_P (memref));
+  as = MEM_ADDR_SPACE (memref);
   if (mode == VOIDmode)
     mode = GET_MODE (memref);
   if (addr == 0)
     addr = XEXP (memref, 0);
   if (mode == GET_MODE (memref) && addr == XEXP (memref, 0)
-      && (!validate || memory_address_p (mode, addr)))
+      && (!validate || memory_address_addr_space_p (mode, addr, as)))
     return memref;
 
   if (validate)
     {
       if (reload_in_progress || reload_completed)
-	gcc_assert (memory_address_p (mode, addr));
+	gcc_assert (memory_address_addr_space_p (mode, addr, as));
       else
-	addr = memory_address (mode, addr);
+	addr = memory_address_addr_space (mode, addr, as);
     }
 
   if (rtx_equal_p (addr, XEXP (memref, 0)) && mode == GET_MODE (memref))
@@ -1992,7 +2013,8 @@ change_address (rtx memref, enum machine
     }
 
   MEM_ATTRS (new_rtx)
-    = get_mem_attrs (MEM_ALIAS_SET (memref), 0, 0, size, align, mmode);
+    = get_mem_attrs (MEM_ALIAS_SET (memref), 0, 0, size, align,
+		     MEM_ADDR_SPACE (memref), mmode);
 
   return new_rtx;
 }
@@ -2012,11 +2034,13 @@ adjust_address_1 (rtx memref, enum machi
   rtx memoffset = MEM_OFFSET (memref);
   rtx size = 0;
   unsigned int memalign = MEM_ALIGN (memref);
+  addr_space_t as = MEM_ADDR_SPACE (memref);
+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);
   int pbits;
 
   /* If there are no changes, just return the original memory reference.  */
   if (mode == GET_MODE (memref) && !offset
-      && (!validate || memory_address_p (mode, addr)))
+      && (!validate || memory_address_addr_space_p (mode, addr, as)))
     return memref;
 
   /* ??? Prefer to create garbage instead of creating shared rtl.
@@ -2026,7 +2050,7 @@ adjust_address_1 (rtx memref, enum machi
 
   /* Convert a possibly large offset to a signed value within the
      range of the target address space.  */
-  pbits = GET_MODE_BITSIZE (Pmode);
+  pbits = GET_MODE_BITSIZE (address_mode);
   if (HOST_BITS_PER_WIDE_INT > pbits)
     {
       int shift = HOST_BITS_PER_WIDE_INT - pbits;
@@ -2042,7 +2066,7 @@ adjust_address_1 (rtx memref, enum machi
 	  && offset >= 0
 	  && (unsigned HOST_WIDE_INT) offset
 	      < GET_MODE_ALIGNMENT (GET_MODE (memref)) / BITS_PER_UNIT)
-	addr = gen_rtx_LO_SUM (Pmode, XEXP (addr, 0),
+	addr = gen_rtx_LO_SUM (address_mode, XEXP (addr, 0),
 			       plus_constant (XEXP (addr, 1), offset));
       else
 	addr = plus_constant (addr, offset);
@@ -2075,7 +2099,8 @@ adjust_address_1 (rtx memref, enum machi
     size = plus_constant (MEM_SIZE (memref), -offset);
 
   MEM_ATTRS (new_rtx) = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_EXPR (memref),
-				   memoffset, size, memalign, GET_MODE (new_rtx));
+				       memoffset, size, memalign, as,
+				       GET_MODE (new_rtx));
 
   /* At some point, we should validate that this offset is within the object,
      if all the appropriate values are known.  */
@@ -2103,8 +2128,10 @@ rtx
 offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)
 {
   rtx new_rtx, addr = XEXP (memref, 0);
+  addr_space_t as = MEM_ADDR_SPACE (memref);
+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);
 
-  new_rtx = simplify_gen_binary (PLUS, Pmode, addr, offset);
+  new_rtx = simplify_gen_binary (PLUS, address_mode, addr, offset);
 
   /* At this point we don't know _why_ the address is invalid.  It
      could have secondary memory references, multiplies or anything.
@@ -2113,12 +2140,12 @@ offset_address (rtx memref, rtx offset, 
      being able to recognize the magic around pic_offset_table_rtx.
      This stuff is fragile, and is yet another example of why it is
      bad to expose PIC machinery too early.  */
-  if (! memory_address_p (GET_MODE (memref), new_rtx)
+  if (! memory_address_addr_space_p (GET_MODE (memref), new_rtx, as)
       && GET_CODE (addr) == PLUS
       && XEXP (addr, 0) == pic_offset_table_rtx)
     {
       addr = force_reg (GET_MODE (addr), addr);
-      new_rtx = simplify_gen_binary (PLUS, Pmode, addr, offset);
+      new_rtx = simplify_gen_binary (PLUS, address_mode, addr, offset);
     }
 
   update_temp_slot_address (XEXP (memref, 0), new_rtx);
@@ -2133,7 +2160,7 @@ offset_address (rtx memref, rtx offset, 
   MEM_ATTRS (new_rtx)
     = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_EXPR (memref), 0, 0,
 		     MIN (MEM_ALIGN (memref), pow2 * BITS_PER_UNIT),
-		     GET_MODE (new_rtx));
+		     as, GET_MODE (new_rtx));
   return new_rtx;
 }
 
@@ -2237,7 +2264,8 @@ widen_memory_access (rtx memref, enum ma
   /* ??? Maybe use get_alias_set on any remaining expression.  */
 
   MEM_ATTRS (new_rtx) = get_mem_attrs (0, expr, memoffset, GEN_INT (size),
-				   MEM_ALIGN (new_rtx), mode);
+				       MEM_ALIGN (new_rtx),
+				       MEM_ADDR_SPACE (new_rtx), mode);
 
   return new_rtx;
 }
@@ -2264,7 +2292,7 @@ get_spill_slot_decl (bool force_build_p)
   rd = gen_rtx_MEM (BLKmode, frame_pointer_rtx);
   MEM_NOTRAP_P (rd) = 1;
   MEM_ATTRS (rd) = get_mem_attrs (new_alias_set (), d, const0_rtx,
-				  NULL_RTX, 0, BLKmode);
+				  NULL_RTX, 0, ADDR_SPACE_GENERIC, BLKmode);
   SET_DECL_RTL (d, rd);
 
   return d;
@@ -2297,7 +2325,7 @@ set_mem_attrs_for_spill (rtx mem)
 
   MEM_ATTRS (mem) = get_mem_attrs (alias, expr, offset,
 				   MEM_SIZE (mem), MEM_ALIGN (mem),
-				   GET_MODE (mem));
+				   ADDR_SPACE_GENERIC, GET_MODE (mem));
   MEM_NOTRAP_P (mem) = 1;
 }
 
diff -urNp gcc-4.4.4.orig/gcc/emit-rtl.h gcc-4.4.4/gcc/emit-rtl.h
--- a/src/gcc/emit-rtl.h	2009-02-20
+++ b/src/gcc/emit-rtl.h	2010-06-30
@@ -26,6 +26,9 @@ extern void set_mem_alias_set (rtx, alia
 /* Set the alignment of MEM to ALIGN bits.  */
 extern void set_mem_align (rtx, unsigned int);
 
+/* Set the address space of MEM to ADDRSPACE.  */
+extern void set_mem_addr_space (rtx, addr_space_t);
+
 /* Set the expr for MEM to EXPR.  */
 extern void set_mem_expr (rtx, tree);
 
diff -urNp gcc-4.4.4.orig/gcc/explow.c gcc-4.4.4/gcc/explow.c
--- a/src/gcc/explow.c	2010-06-30
+++ b/src/gcc/explow.c	2010-06-30
@@ -306,27 +306,27 @@ break_out_memory_refs (rtx x)
       rtx op1 = break_out_memory_refs (XEXP (x, 1));
 
       if (op0 != XEXP (x, 0) || op1 != XEXP (x, 1))
-	x = simplify_gen_binary (GET_CODE (x), Pmode, op0, op1);
+	x = simplify_gen_binary (GET_CODE (x), GET_MODE (x), op0, op1);
     }
 
   return x;
 }
 
-/* Given X, a memory address in ptr_mode, convert it to an address
-   in Pmode, or vice versa (TO_MODE says which way).  We take advantage of
-   the fact that pointers are not allowed to overflow by commuting arithmetic
-   operations over conversions so that address arithmetic insns can be
-   used.  */
+/* Given X, a memory address in address space AS' pointer mode, convert it to
+   an address in the address space's address mode, or vice versa (TO_MODE says
+   which way).  We take advantage of the fact that pointers are not allowed to
+   overflow by commuting arithmetic operations over conversions so that address
+   arithmetic insns can be used.  */
 
 rtx
-convert_memory_address (enum machine_mode to_mode ATTRIBUTE_UNUSED, 
-			rtx x)
+convert_memory_address_addr_space (enum machine_mode to_mode ATTRIBUTE_UNUSED,
+				   rtx x, addr_space_t as ATTRIBUTE_UNUSED)
 {
 #ifndef POINTERS_EXTEND_UNSIGNED
   gcc_assert (GET_MODE (x) == to_mode || GET_MODE (x) == VOIDmode);
   return x;
 #else /* defined(POINTERS_EXTEND_UNSIGNED) */
-  enum machine_mode from_mode;
+  enum machine_mode pointer_mode, address_mode, from_mode;
   rtx temp;
   enum rtx_code code;
 
@@ -334,7 +334,9 @@ convert_memory_address (enum machine_mod
   if (GET_MODE (x) == to_mode)
     return x;
 
-  from_mode = to_mode == ptr_mode ? Pmode : ptr_mode;
+  pointer_mode = targetm.addr_space.pointer_mode (as);
+  address_mode = targetm.addr_space.address_mode (as);
+  from_mode = to_mode == pointer_mode ? address_mode : pointer_mode;
 
   /* Here we handle some special cases.  If none of them apply, fall through
      to the default case.  */
@@ -375,7 +377,8 @@ convert_memory_address (enum machine_mod
 
     case CONST:
       return gen_rtx_CONST (to_mode,
-			    convert_memory_address (to_mode, XEXP (x, 0)));
+			    convert_memory_address_addr_space
+			      (to_mode, XEXP (x, 0), as));
       break;
 
     case PLUS:
@@ -389,10 +392,12 @@ convert_memory_address (enum machine_mod
       if (GET_MODE_SIZE (to_mode) < GET_MODE_SIZE (from_mode)
 	  || (GET_CODE (x) == PLUS
 	      && GET_CODE (XEXP (x, 1)) == CONST_INT
-	      && (XEXP (x, 1) == convert_memory_address (to_mode, XEXP (x, 1))
+	      && (XEXP (x, 1) == convert_memory_address_addr_space
+				   (to_mode, XEXP (x, 1), as)
                  || POINTERS_EXTEND_UNSIGNED < 0)))
 	return gen_rtx_fmt_ee (GET_CODE (x), to_mode,
-			       convert_memory_address (to_mode, XEXP (x, 0)),
+			       convert_memory_address_addr_space
+				 (to_mode, XEXP (x, 0), as),
 			       XEXP (x, 1));
       break;
 
@@ -405,21 +410,22 @@ convert_memory_address (enum machine_mod
 #endif /* defined(POINTERS_EXTEND_UNSIGNED) */
 }
 
-/* Return something equivalent to X but valid as a memory address
-   for something of mode MODE.  When X is not itself valid, this
-   works by copying X or subexpressions of it into registers.  */
+/* Return something equivalent to X but valid as a memory address for something
+   of mode MODE in the named address space AS.  When X is not itself valid,
+   this works by copying X or subexpressions of it into registers.  */
 
 rtx
-memory_address (enum machine_mode mode, rtx x)
+memory_address_addr_space (enum machine_mode mode, rtx x, addr_space_t as)
 {
   rtx oldx = x;
+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);
 
-  x = convert_memory_address (Pmode, x);
+  x = convert_memory_address_addr_space (address_mode, x, as);
 
   /* By passing constant addresses through registers
      we get a chance to cse them.  */
   if (! cse_not_expected && CONSTANT_P (x) && CONSTANT_ADDRESS_P (x))
-    x = force_reg (Pmode, x);
+    x = force_reg (address_mode, x);
 
   /* We get better cse by rejecting indirect addressing at this stage.
      Let the combiner create indirect addresses where appropriate.
@@ -431,12 +437,12 @@ memory_address (enum machine_mode mode, 
 	x = break_out_memory_refs (x);
 
       /* At this point, any valid address is accepted.  */
-      if (memory_address_p (mode, x))
+      if (memory_address_addr_space_p (mode, x, as))
 	goto done;
 
       /* If it was valid before but breaking out memory refs invalidated it,
 	 use it the old way.  */
-      if (memory_address_p (mode, oldx))
+      if (memory_address_addr_space_p (mode, oldx, as))
 	{
 	  x = oldx;
 	  goto done;
@@ -446,7 +452,12 @@ memory_address (enum machine_mode mode, 
 	 in certain cases.  This is not necessary since the code
 	 below can handle all possible cases, but machine-dependent
 	 transformations can make better code.  */
-      LEGITIMIZE_ADDRESS (x, oldx, mode, done);
+      {
+	rtx orig_x = x;
+	x = targetm.addr_space.legitimize_address (x, oldx, mode, as);
+	if (orig_x != x && memory_address_addr_space_p (mode, x, as))
+	  goto done;
+      }
 
       /* PLUS and MULT can appear in special ways
 	 as the result of attempts to make an address usable for indexing.
@@ -462,12 +473,12 @@ memory_address (enum machine_mode mode, 
 	  rtx constant_term = const0_rtx;
 	  rtx y = eliminate_constant_term (x, &constant_term);
 	  if (constant_term == const0_rtx
-	      || ! memory_address_p (mode, y))
+	      || ! memory_address_addr_space_p (mode, y, as))
 	    x = force_operand (x, NULL_RTX);
 	  else
 	    {
 	      y = gen_rtx_PLUS (GET_MODE (x), copy_to_reg (y), constant_term);
-	      if (! memory_address_p (mode, y))
+	      if (! memory_address_addr_space_p (mode, y, as))
 		x = force_operand (x, NULL_RTX);
 	      else
 		x = y;
@@ -485,12 +496,12 @@ memory_address (enum machine_mode mode, 
       /* Last resort: copy the value to a register, since
 	 the register is a valid address.  */
       else
-	x = force_reg (Pmode, x);
+	x = force_reg (address_mode, x);
     }
 
  done:
 
-  gcc_assert (memory_address_p (mode, x));
+  gcc_assert (memory_address_addr_space_p (mode, x, as));
   /* If we didn't change the address, we are done.  Otherwise, mark
      a reg as a pointer if we have REG or REG + CONST_INT.  */
   if (oldx == x)
@@ -518,7 +529,8 @@ validize_mem (rtx ref)
   if (!MEM_P (ref))
     return ref;
   ref = use_anchored_address (ref);
-  if (memory_address_p (GET_MODE (ref), XEXP (ref, 0)))
+  if (memory_address_addr_space_p (GET_MODE (ref), XEXP (ref, 0),
+				   MEM_ADDR_SPACE (ref)))
     return ref;
 
   /* Don't alter REF itself, since that is probably a stack slot.  */
@@ -789,7 +801,8 @@ promote_mode (const_tree type, enum mach
 #ifdef POINTERS_EXTEND_UNSIGNED
     case REFERENCE_TYPE:
     case POINTER_TYPE:
-      mode = Pmode;
+      mode = targetm.addr_space.address_mode
+	       (TYPE_ADDR_SPACE (TREE_TYPE (type)));
       unsignedp = POINTERS_EXTEND_UNSIGNED;
       break;
 #endif
diff -urNp gcc-4.4.4.orig/gcc/expmed.c gcc-4.4.4/gcc/expmed.c
--- a/src/gcc/expmed.c	2010-06-30
+++ b/src/gcc/expmed.c	2010-06-30
@@ -5081,10 +5081,11 @@ make_tree (tree type, rtx x)
     default:
       t = build_decl (VAR_DECL, NULL_TREE, type);
 
-      /* If TYPE is a POINTER_TYPE, X might be Pmode with TYPE_MODE being
-	 ptr_mode.  So convert.  */
+      /* If TYPE is a POINTER_TYPE, we might need to convert X from
+	 address mode to pointer mode.  */
       if (POINTER_TYPE_P (type))
-	x = convert_memory_address (TYPE_MODE (type), x);
+	x = convert_memory_address_addr_space
+	      (TYPE_MODE (type), x, TYPE_ADDR_SPACE (TREE_TYPE (type)));
 
       /* Note that we do *not* use SET_DECL_RTL here, because we do not
 	 want set_decl_rtl to go adjusting REG_ATTRS for this temporary.  */
diff -urNp gcc-4.4.4.orig/gcc/expr.c gcc-4.4.4/gcc/expr.c
--- a/src/gcc/expr.c	2010-06-30
+++ b/src/gcc/expr.c	2010-06-30
@@ -895,6 +895,8 @@ move_by_pieces (rtx to, rtx from, unsign
 		unsigned int align, int endp)
 {
   struct move_by_pieces data;
+  enum machine_mode to_addr_mode, from_addr_mode
+    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (from));
   rtx to_addr, from_addr = XEXP (from, 0);
   unsigned int max_size = MOVE_MAX_PIECES + 1;
   enum machine_mode mode = VOIDmode, tmode;
@@ -906,6 +908,7 @@ move_by_pieces (rtx to, rtx from, unsign
   data.from_addr = from_addr;
   if (to)
     {
+      to_addr_mode = targetm.addr_space.address_mode (MEM_ADDR_SPACE (to));
       to_addr = XEXP (to, 0);
       data.to = to;
       data.autinc_to
@@ -916,6 +919,7 @@ move_by_pieces (rtx to, rtx from, unsign
     }
   else
     {
+      to_addr_mode = VOIDmode;
       to_addr = NULL_RTX;
       data.to = NULL_RTX;
       data.autinc_to = 1;
@@ -951,32 +955,34 @@ move_by_pieces (rtx to, rtx from, unsign
 
       if (USE_LOAD_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_from)
 	{
-	  data.from_addr = copy_addr_to_reg (plus_constant (from_addr, len));
+	  data.from_addr = copy_to_mode_reg (from_addr_mode,
+					     plus_constant (from_addr, len));
 	  data.autinc_from = 1;
 	  data.explicit_inc_from = -1;
 	}
       if (USE_LOAD_POST_INCREMENT (mode) && ! data.autinc_from)
 	{
-	  data.from_addr = copy_addr_to_reg (from_addr);
+	  data.from_addr = copy_to_mode_reg (from_addr_mode, from_addr);
 	  data.autinc_from = 1;
 	  data.explicit_inc_from = 1;
 	}
       if (!data.autinc_from && CONSTANT_P (from_addr))
-	data.from_addr = copy_addr_to_reg (from_addr);
+	data.from_addr = copy_to_mode_reg (from_addr_mode, from_addr);
       if (USE_STORE_PRE_DECREMENT (mode) && data.reverse && ! data.autinc_to)
 	{
-	  data.to_addr = copy_addr_to_reg (plus_constant (to_addr, len));
+	  data.to_addr = copy_to_mode_reg (to_addr_mode,
+					   plus_constant (to_addr, len));
 	  data.autinc_to = 1;
 	  data.explicit_inc_to = -1;
 	}
       if (USE_STORE_POST_INCREMENT (mode) && ! data.reverse && ! data.autinc_to)
 	{
-	  data.to_addr = copy_addr_to_reg (to_addr);
+	  data.to_addr = copy_to_mode_reg (to_addr_mode, to_addr);
 	  data.autinc_to = 1;
 	  data.explicit_inc_to = 1;
 	}
       if (!data.autinc_to && CONSTANT_P (to_addr))
-	data.to_addr = copy_addr_to_reg (to_addr);
+	data.to_addr = copy_to_mode_reg (to_addr_mode, to_addr);
     }
 
   tmode = mode_for_size (MOVE_MAX_PIECES * BITS_PER_UNIT, MODE_INT, 1);
@@ -1031,7 +1037,8 @@ move_by_pieces (rtx to, rtx from, unsign
 	      if (HAVE_POST_INCREMENT && data.explicit_inc_to > 0)
 		emit_insn (gen_add2_insn (data.to_addr, constm1_rtx));
 	      else
-		data.to_addr = copy_addr_to_reg (plus_constant (data.to_addr,
+		data.to_addr = copy_to_mode_reg (to_addr_mode,
+						 plus_constant (data.to_addr,
 								-1));
 	    }
 	  to1 = adjust_automodify_address (data.to, QImode, data.to_addr,
@@ -1233,7 +1240,9 @@ emit_block_move_hints (rtx x, rtx y, rtx
   else if (emit_block_move_via_movmem (x, y, size, align,
 				       expected_align, expected_size))
     ;
-  else if (may_use_call)
+  else if (may_use_call
+	   && ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (x))
+	   && ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (y)))
     retval = emit_block_move_via_libcall (x, y, size,
 					  method == BLOCK_OP_TAILCALL);
   else
@@ -1484,6 +1493,10 @@ emit_block_move_via_loop (rtx x, rtx y, 
 			  unsigned int align ATTRIBUTE_UNUSED)
 {
   rtx cmp_label, top_label, iter, x_addr, y_addr, tmp;
+  enum machine_mode x_addr_mode
+    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (x));
+  enum machine_mode y_addr_mode
+    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (y));
   enum machine_mode iter_mode;
 
   iter_mode = GET_MODE (size);
@@ -1503,9 +1516,13 @@ emit_block_move_via_loop (rtx x, rtx y, 
   emit_jump (cmp_label);
   emit_label (top_label);
 
-  tmp = convert_modes (Pmode, iter_mode, iter, true);
-  x_addr = gen_rtx_PLUS (Pmode, x_addr, tmp);
-  y_addr = gen_rtx_PLUS (Pmode, y_addr, tmp);
+  tmp = convert_modes (x_addr_mode, iter_mode, iter, true);
+  x_addr = gen_rtx_PLUS (x_addr_mode, x_addr, tmp);
+
+  if (x_addr_mode != y_addr_mode)
+    tmp = convert_modes (y_addr_mode, iter_mode, iter, true);
+  y_addr = gen_rtx_PLUS (y_addr_mode, y_addr, tmp);
+
   x = change_address (x, QImode, x_addr);
   y = change_address (y, QImode, y_addr);
 
@@ -2380,6 +2397,8 @@ store_by_pieces (rtx to, unsigned HOST_W
 		 rtx (*constfun) (void *, HOST_WIDE_INT, enum machine_mode),
 		 void *constfundata, unsigned int align, bool memsetp, int endp)
 {
+  enum machine_mode to_addr_mode
+    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (to));
   struct store_by_pieces data;
 
   if (len == 0)
@@ -2408,7 +2427,8 @@ store_by_pieces (rtx to, unsigned HOST_W
 	      if (HAVE_POST_INCREMENT && data.explicit_inc_to > 0)
 		emit_insn (gen_add2_insn (data.to_addr, constm1_rtx));
 	      else
-		data.to_addr = copy_addr_to_reg (plus_constant (data.to_addr,
+		data.to_addr = copy_to_mode_reg (to_addr_mode,
+						 plus_constant (data.to_addr,
 								-1));
 	    }
 	  to1 = adjust_automodify_address (data.to, QImode, data.to_addr,
@@ -2463,6 +2483,8 @@ static void
 store_by_pieces_1 (struct store_by_pieces *data ATTRIBUTE_UNUSED,
 		   unsigned int align ATTRIBUTE_UNUSED)
 {
+  enum machine_mode to_addr_mode
+    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (data->to));
   rtx to_addr = XEXP (data->to, 0);
   unsigned int max_size = STORE_MAX_PIECES + 1;
   enum machine_mode mode = VOIDmode, tmode;
@@ -2494,7 +2516,8 @@ store_by_pieces_1 (struct store_by_piece
 
       if (USE_STORE_PRE_DECREMENT (mode) && data->reverse && ! data->autinc_to)
 	{
-	  data->to_addr = copy_addr_to_reg (plus_constant (to_addr, data->len));
+	  data->to_addr = copy_to_mode_reg (to_addr_mode,
+					    plus_constant (to_addr, data->len));
 	  data->autinc_to = 1;
 	  data->explicit_inc_to = -1;
 	}
@@ -2502,13 +2525,13 @@ store_by_pieces_1 (struct store_by_piece
       if (USE_STORE_POST_INCREMENT (mode) && ! data->reverse
 	  && ! data->autinc_to)
 	{
-	  data->to_addr = copy_addr_to_reg (to_addr);
+	  data->to_addr = copy_to_mode_reg (to_addr_mode, to_addr);
 	  data->autinc_to = 1;
 	  data->explicit_inc_to = 1;
 	}
 
       if ( !data->autinc_to && CONSTANT_P (to_addr))
-	data->to_addr = copy_addr_to_reg (to_addr);
+	data->to_addr = copy_to_mode_reg (to_addr_mode, to_addr);
     }
 
   tmode = mode_for_size (STORE_MAX_PIECES * BITS_PER_UNIT, MODE_INT, 1);
@@ -2639,9 +2662,11 @@ clear_storage_hints (rtx object, rtx siz
   else if (set_storage_via_setmem (object, size, const0_rtx, align,
 				   expected_align, expected_size))
     ;
-  else
+  else if (ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (object)))
     return set_storage_via_libcall (object, size, const0_rtx,
 				    method == BLOCK_OP_TAILCALL);
+  else
+    gcc_unreachable ();
 
   return NULL;
 }
@@ -3430,12 +3455,14 @@ emit_move_insn (rtx x, rtx y)
   /* If X or Y are memory references, verify that their addresses are valid
      for the machine.  */
   if (MEM_P (x)
-      && (! memory_address_p (GET_MODE (x), XEXP (x, 0))
+      && (! memory_address_addr_space_p (GET_MODE (x), XEXP (x, 0),
+					 MEM_ADDR_SPACE (x))
 	  && ! push_operand (x, GET_MODE (x))))
     x = validize_mem (x);
 
   if (MEM_P (y)
-      && ! memory_address_p (GET_MODE (y), XEXP (y, 0)))
+      && ! memory_address_addr_space_p (GET_MODE (y), XEXP (y, 0),
+					MEM_ADDR_SPACE (y)))
     y = validize_mem (y);
 
   gcc_assert (mode != BLKmode);
@@ -4206,6 +4233,7 @@ expand_assignment (tree to, tree from, b
 
       if (offset != 0)
 	{
+	  enum machine_mode address_mode;
 	  rtx offset_rtx;
 
 	  if (!MEM_P (to_rtx))
@@ -4218,13 +4246,10 @@ expand_assignment (tree to, tree from, b
 	    }
 
 	  offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode, EXPAND_SUM);
-#ifdef POINTERS_EXTEND_UNSIGNED
-	  if (GET_MODE (offset_rtx) != Pmode)
-	    offset_rtx = convert_to_mode (Pmode, offset_rtx, 0);
-#else
-	  if (GET_MODE (offset_rtx) != ptr_mode)
-	    offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);
-#endif
+	  address_mode
+	    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (to_rtx));
+	  if (GET_MODE (offset_rtx) != address_mode)
+	    offset_rtx = convert_to_mode (address_mode, offset_rtx, 0);
 
 	  /* A constant address in TO_RTX can have VOIDmode, we must not try
 	     to call force_reg for that case.  Avoid that case.  */
@@ -4327,7 +4352,10 @@ expand_assignment (tree to, tree from, b
       else
 	{
 	  if (POINTER_TYPE_P (TREE_TYPE (to)))
-	    value = convert_memory_address (GET_MODE (to_rtx), value);
+	    value = convert_memory_address_addr_space
+		      (GET_MODE (to_rtx), value,
+		       TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (to))));
+
 	  emit_move_insn (to_rtx, value);
 	}
       preserve_temp_slots (to_rtx);
@@ -4367,6 +4395,8 @@ expand_assignment (tree to, tree from, b
      the place the value is being stored, use a safe function when copying
      a value through a pointer into a structure value return block.  */
   if (TREE_CODE (to) == RESULT_DECL && TREE_CODE (from) == INDIRECT_REF
+      && ADDR_SPACE_GENERIC_P
+	  (TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (TREE_OPERAND (from, 0)))))
       && cfun->returns_struct
       && !cfun->returns_pcc_struct)
     {
@@ -4729,6 +4759,11 @@ store_expr (tree exp, rtx target, int ca
 			      ? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));
 	  else
 	    {
+	      enum machine_mode pointer_mode
+		= targetm.addr_space.pointer_mode (MEM_ADDR_SPACE (target));
+	      enum machine_mode address_mode
+		= targetm.addr_space.address_mode (MEM_ADDR_SPACE (target));
+
 	      /* Compute the size of the data to copy from the string.  */
 	      tree copy_size
 		= size_binop (MIN_EXPR,
@@ -4741,14 +4776,14 @@ store_expr (tree exp, rtx target, int ca
 	      rtx label = 0;
 
 	      /* Copy that much.  */
-	      copy_size_rtx = convert_to_mode (ptr_mode, copy_size_rtx,
+	      copy_size_rtx = convert_to_mode (pointer_mode, copy_size_rtx,
 					       TYPE_UNSIGNED (sizetype));
 	      emit_block_move (target, temp, copy_size_rtx,
 			       (call_param_p
 				? BLOCK_OP_CALL_PARM : BLOCK_OP_NORMAL));
 
 	      /* Figure out how much is left in TARGET that we have to clear.
-		 Do all calculations in ptr_mode.  */
+		 Do all calculations in pointer_mode.  */
 	      if (GET_CODE (copy_size_rtx) == CONST_INT)
 		{
 		  size = plus_constant (size, -INTVAL (copy_size_rtx));
@@ -4761,11 +4796,10 @@ store_expr (tree exp, rtx target, int ca
 				       copy_size_rtx, NULL_RTX, 0,
 				       OPTAB_LIB_WIDEN);
 
-#ifdef POINTERS_EXTEND_UNSIGNED
-		  if (GET_MODE (copy_size_rtx) != Pmode)
-		    copy_size_rtx = convert_to_mode (Pmode, copy_size_rtx,
+		  if (GET_MODE (copy_size_rtx) != address_mode)
+		    copy_size_rtx = convert_to_mode (address_mode,
+						     copy_size_rtx,
 						     TYPE_UNSIGNED (sizetype));
-#endif
 
 		  target = offset_address (target, copy_size_rtx,
 					   highest_pow2_factor (copy_size));
@@ -5255,6 +5289,7 @@ store_constructor (tree exp, rtx target,
 
 	    if (offset)
 	      {
+	        enum machine_mode address_mode;
 		rtx offset_rtx;
 
 		offset
@@ -5265,13 +5300,10 @@ store_constructor (tree exp, rtx target,
 		offset_rtx = expand_normal (offset);
 		gcc_assert (MEM_P (to_rtx));
 
-#ifdef POINTERS_EXTEND_UNSIGNED
-		if (GET_MODE (offset_rtx) != Pmode)
-		  offset_rtx = convert_to_mode (Pmode, offset_rtx, 0);
-#else
-		if (GET_MODE (offset_rtx) != ptr_mode)
-		  offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);
-#endif
+		address_mode
+		  = targetm.addr_space.address_mode (MEM_ADDR_SPACE (to_rtx));
+		if (GET_MODE (offset_rtx) != address_mode)
+		  offset_rtx = convert_to_mode (address_mode, offset_rtx, 0);
 
 		to_rtx = offset_address (to_rtx, offset_rtx,
 					 highest_pow2_factor (offset));
@@ -6779,7 +6811,7 @@ expand_expr_constant (tree exp, int defe
 
 static rtx
 expand_expr_addr_expr_1 (tree exp, rtx target, enum machine_mode tmode,
-		         enum expand_modifier modifier)
+		         enum expand_modifier modifier, addr_space_t as)
 {
   rtx result, subtarget;
   tree inner, offset;
@@ -6806,7 +6838,7 @@ expand_expr_addr_expr_1 (tree exp, rtx t
     case CONST_DECL:
       /* Recurse and make the output_constant_def clause above handle this.  */
       return expand_expr_addr_expr_1 (DECL_INITIAL (exp), target,
-				      tmode, modifier);
+				      tmode, modifier, as);
 
     case REALPART_EXPR:
       /* The real part of the complex number is always first, therefore
@@ -6895,7 +6927,7 @@ expand_expr_addr_expr_1 (tree exp, rtx t
       TYPE_ALIGN (TREE_TYPE (inner)) = TYPE_ALIGN (TREE_TYPE (exp));
       TYPE_USER_ALIGN (TREE_TYPE (inner)) = 1;
     }
-  result = expand_expr_addr_expr_1 (inner, subtarget, tmode, modifier);
+  result = expand_expr_addr_expr_1 (inner, subtarget, tmode, modifier, as);
 
   if (offset)
     {
@@ -6907,8 +6939,8 @@ expand_expr_addr_expr_1 (tree exp, rtx t
 			 modifier == EXPAND_INITIALIZER
 			  ? EXPAND_INITIALIZER : EXPAND_NORMAL);
 
-      result = convert_memory_address (tmode, result);
-      tmp = convert_memory_address (tmode, tmp);
+      result = convert_memory_address_addr_space (tmode, result, as);
+      tmp = convert_memory_address_addr_space (tmode, tmp, as);
 
       if (modifier == EXPAND_SUM || modifier == EXPAND_INITIALIZER)
 	result = gen_rtx_PLUS (tmode, result, tmp);
@@ -6941,6 +6973,9 @@ static rtx
 expand_expr_addr_expr (tree exp, rtx target, enum machine_mode tmode,
 		       enum expand_modifier modifier)
 {
+  addr_space_t as = ADDR_SPACE_GENERIC;
+  enum machine_mode address_mode = Pmode;
+  enum machine_mode pointer_mode = ptr_mode;
   enum machine_mode rmode;
   rtx result;
 
@@ -6948,14 +6983,21 @@ expand_expr_addr_expr (tree exp, rtx tar
   if (tmode == VOIDmode)
     tmode = TYPE_MODE (TREE_TYPE (exp));
 
+  if (POINTER_TYPE_P (TREE_TYPE (exp)))
+    {
+      as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)));
+      address_mode = targetm.addr_space.address_mode (as);
+      pointer_mode = targetm.addr_space.pointer_mode (as);
+    }
+
   /* We can get called with some Weird Things if the user does silliness
      like "(short) &a".  In that case, convert_memory_address won't do
      the right thing, so ignore the given target mode.  */
-  if (tmode != Pmode && tmode != ptr_mode)
-    tmode = Pmode;
+  if (tmode != address_mode && tmode != pointer_mode)
+    tmode = address_mode;
 
   result = expand_expr_addr_expr_1 (TREE_OPERAND (exp, 0), target,
-				    tmode, modifier);
+				    tmode, modifier, as);
 
   /* Despite expand_expr claims concerning ignoring TMODE when not
      strictly convenient, stuff breaks if we don't honor it.  Note
@@ -6964,7 +7006,7 @@ expand_expr_addr_expr (tree exp, rtx tar
   if (rmode == VOIDmode)
     rmode = tmode;
   if (rmode != tmode)
-    result = convert_memory_address (tmode, result);
+    result = convert_memory_address_addr_space (tmode, result, as);
 
   return result;
 }
@@ -7366,7 +7408,9 @@ expand_expr_real_1 (tree exp, rtx target
 	  decl_rtl = use_anchored_address (decl_rtl);
 	  if (modifier != EXPAND_CONST_ADDRESS
 	      && modifier != EXPAND_SUM
-	      && !memory_address_p (DECL_MODE (exp), XEXP (decl_rtl, 0)))
+	      && !memory_address_addr_space_p (DECL_MODE (exp),
+					       XEXP (decl_rtl, 0),
+					       MEM_ADDR_SPACE (decl_rtl)))
 	    temp = replace_equiv_address (decl_rtl,
 					  copy_rtx (XEXP (decl_rtl, 0)));
 	}
@@ -7488,7 +7532,8 @@ expand_expr_real_1 (tree exp, rtx target
       if (modifier != EXPAND_CONST_ADDRESS
 	  && modifier != EXPAND_INITIALIZER
 	  && modifier != EXPAND_SUM
-	  && ! memory_address_p (mode, XEXP (temp, 0)))
+	  && ! memory_address_addr_space_p (mode, XEXP (temp, 0),
+					    MEM_ADDR_SPACE (temp)))
 	return replace_equiv_address (temp,
 				      copy_rtx (XEXP (temp, 0)));
       return temp;
@@ -7548,6 +7593,8 @@ expand_expr_real_1 (tree exp, rtx target
     case INDIRECT_REF:
       {
 	tree exp1 = TREE_OPERAND (exp, 0);
+	addr_space_t as = ADDR_SPACE_GENERIC;
+	enum machine_mode address_mode = Pmode;
 
 	if (modifier != EXPAND_WRITE)
 	  {
@@ -7558,19 +7605,26 @@ expand_expr_real_1 (tree exp, rtx target
 	      return expand_expr (t, target, tmode, modifier);
 	  }
 
+	if (POINTER_TYPE_P (TREE_TYPE (exp1)))
+	  {
+	    as = TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp1)));
+	    address_mode = targetm.addr_space.address_mode (as);
+	  }
+
 	op0 = expand_expr (exp1, NULL_RTX, VOIDmode, EXPAND_SUM);
-	op0 = memory_address (mode, op0);
+	op0 = memory_address_addr_space (mode, op0, as);
 
 	if (code == ALIGN_INDIRECT_REF)
 	  {
 	    int align = TYPE_ALIGN_UNIT (type);
-	    op0 = gen_rtx_AND (Pmode, op0, GEN_INT (-align));
-	    op0 = memory_address (mode, op0);
+	    op0 = gen_rtx_AND (address_mode, op0, GEN_INT (-align));
+	    op0 = memory_address_addr_space (mode, op0, as);
 	  }
 
 	temp = gen_rtx_MEM (mode, op0);
 
 	set_mem_attributes (temp, exp, 0);
+	set_mem_addr_space (temp, as);
 
 	/* Resolve the misalignment now, so that we don't have to remember
 	   to resolve it later.  Of course, this only works for reads.  */
@@ -7606,13 +7660,15 @@ expand_expr_real_1 (tree exp, rtx target
 
     case TARGET_MEM_REF:
       {
+	addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (exp));
 	struct mem_address addr;
 
 	get_address_description (exp, &addr);
-	op0 = addr_for_mem_ref (&addr, true);
-	op0 = memory_address (mode, op0);
+	op0 = addr_for_mem_ref (&addr, as, true);
+	op0 = memory_address_addr_space (mode, op0, as);
 	temp = gen_rtx_MEM (mode, op0);
 	set_mem_attributes (temp, TMR_ORIGINAL (exp), 0);
+	set_mem_addr_space (temp, as);
       }
       return temp;
 
@@ -7898,18 +7954,16 @@ expand_expr_real_1 (tree exp, rtx target
 
 	if (offset)
 	  {
+	    enum machine_mode address_mode;
 	    rtx offset_rtx = expand_expr (offset, NULL_RTX, VOIDmode,
 					  EXPAND_SUM);
 
 	    gcc_assert (MEM_P (op0));
 
-#ifdef POINTERS_EXTEND_UNSIGNED
-	    if (GET_MODE (offset_rtx) != Pmode)
-	      offset_rtx = convert_to_mode (Pmode, offset_rtx, 0);
-#else
-	    if (GET_MODE (offset_rtx) != ptr_mode)
-	      offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);
-#endif
+	    address_mode
+	      = targetm.addr_space.address_mode (MEM_ADDR_SPACE (op0));
+	    if (GET_MODE (offset_rtx) != address_mode)
+	      offset_rtx = convert_to_mode (address_mode, offset_rtx, 0);
 
 	    if (GET_MODE (op0) == BLKmode
 		/* A constant address in OP0 can have VOIDmode, we must
@@ -8386,6 +8440,40 @@ expand_expr_real_1 (tree exp, rtx target
 
       return op0;
 
+    case ADDR_SPACE_CONVERT_EXPR:
+      {
+	tree treeop0 = TREE_OPERAND (exp, 0);
+	tree treeop0_type = TREE_TYPE (treeop0);
+	addr_space_t as_to;
+	addr_space_t as_from;
+
+	gcc_assert (POINTER_TYPE_P (type));
+	gcc_assert (POINTER_TYPE_P (treeop0_type));
+
+	as_to = TYPE_ADDR_SPACE (TREE_TYPE (type));
+	as_from = TYPE_ADDR_SPACE (TREE_TYPE (treeop0_type));
+
+        /* Conversions between pointers to the same address space should
+	   have been implemented via CONVERT_EXPR / NOP_EXPR.  */
+	gcc_assert (as_to != as_from);
+
+        /* Ask target code to handle conversion between pointers
+	   to overlapping address spaces.  */
+	if (targetm.addr_space.subset_p (as_to, as_from)
+	    || targetm.addr_space.subset_p (as_from, as_to))
+	  {
+	    op0 = expand_expr (treeop0, NULL_RTX, VOIDmode, modifier);
+	    op0 = targetm.addr_space.convert (op0, treeop0_type, type);
+	    gcc_assert (op0);
+	    return op0;
+	  }
+
+	/* For disjoint address spaces, converting anything but
+	   a null pointer invokes undefined behaviour.  We simply
+	   always return a null pointer here.  */
+	return CONST0_RTX (mode);
+      }
+
     case POINTER_PLUS_EXPR: 
       /* Even though the sizetype mode and the pointer's mode can be different
          expand is able to handle this correctly and get the correct result out 
diff -urNp gcc-4.4.4.orig/gcc/expr.h gcc-4.4.4/gcc/expr.h
--- a/src/gcc/expr.h	2010-06-30
+++ b/src/gcc/expr.h	2010-06-30
@@ -635,9 +635,15 @@ extern rtx force_label_rtx (tree);
    The constant terms are added and stored via a second arg.  */
 extern rtx eliminate_constant_term (rtx, rtx *);
 
-/* Convert arg to a valid memory address for specified machine mode,
-   by emitting insns to perform arithmetic if nec.  */
-extern rtx memory_address (enum machine_mode, rtx);
+/* Convert arg to a valid memory address for specified machine mode that points
+   to a specific named address space, by emitting insns to perform arithmetic
+   if necessary.  */
+extern rtx memory_address_addr_space (enum machine_mode, rtx, addr_space_t);
+
+/* Like memory_address_addr_space, except assume the memory address points to
+   the generic named address space.  */
+#define memory_address(MODE,RTX) \
+	memory_address_addr_space ((MODE), (RTX), ADDR_SPACE_GENERIC)
 
 /* Return a memory reference like MEMREF, but with its mode changed
    to MODE and its address changed to ADDR.
diff -urNp gcc-4.4.4.orig/gcc/fold-const.c gcc-4.4.4/gcc/fold-const.c
--- a/src/gcc/fold-const.c	2010-06-30
+++ b/src/gcc/fold-const.c	2010-06-30
@@ -202,15 +202,9 @@ fit_double_type (unsigned HOST_WIDE_INT 
 {
   unsigned HOST_WIDE_INT low0 = l1;
   HOST_WIDE_INT high0 = h1;
-  unsigned int prec;
+  unsigned int prec = TYPE_PRECISION (type);
   int sign_extended_type;
 
-  if (POINTER_TYPE_P (type)
-      || TREE_CODE (type) == OFFSET_TYPE)
-    prec = POINTER_SIZE;
-  else
-    prec = TYPE_PRECISION (type);
-
   /* Size types *are* sign extended.  */
   sign_extended_type = (!TYPE_UNSIGNED (type)
 			|| (TREE_CODE (type) == INTEGER_TYPE
@@ -2530,8 +2524,16 @@ fold_convert (tree type, tree arg)
 
   switch (TREE_CODE (type))
     {
+    case POINTER_TYPE:
+    case REFERENCE_TYPE:
+      /* Handle conversions between pointers to different address spaces.  */
+      if (POINTER_TYPE_P (orig)
+	  && (TYPE_ADDR_SPACE (TREE_TYPE (type))
+	      != TYPE_ADDR_SPACE (TREE_TYPE (orig))))
+	return fold_build1 (ADDR_SPACE_CONVERT_EXPR, type, arg);
+      /* fall through */
+
     case INTEGER_TYPE: case ENUMERAL_TYPE: case BOOLEAN_TYPE:
-    case POINTER_TYPE: case REFERENCE_TYPE:
     case OFFSET_TYPE:
       if (TREE_CODE (arg) == INTEGER_CST)
 	{
@@ -3053,6 +3055,12 @@ operand_equal_p (const_tree arg0, const_
       || POINTER_TYPE_P (TREE_TYPE (arg0)) != POINTER_TYPE_P (TREE_TYPE (arg1)))
     return 0;
 
+  /* We cannot consider pointers to different address space equal.  */
+  if (POINTER_TYPE_P (TREE_TYPE (arg0)) && POINTER_TYPE_P (TREE_TYPE (arg1))
+      && (TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg0)))
+	  != TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (arg1)))))
+    return 0;
+
   /* If both types don't have the same precision, then it is not safe
      to strip NOPs.  */
   if (TYPE_PRECISION (TREE_TYPE (arg0)) != TYPE_PRECISION (TREE_TYPE (arg1)))
@@ -8405,6 +8413,11 @@ fold_unary (enum tree_code code, tree ty
       tem = fold_convert_const (code, type, op0);
       return tem ? tem : NULL_TREE;
 
+    case ADDR_SPACE_CONVERT_EXPR:
+      if (integer_zerop (arg0))
+	return fold_convert_const (code, type, arg0);
+      return NULL_TREE;
+
     case FIXED_CONVERT_EXPR:
       tem = fold_convert_const (code, type, arg0);
       return tem ? tem : NULL_TREE;
diff -urNp gcc-4.4.4.orig/gcc/fwprop.c gcc-4.4.4/gcc/fwprop.c
--- a/src/gcc/fwprop.c	2009-04-26
+++ b/src/gcc/fwprop.c	2010-06-30
@@ -185,11 +185,12 @@ canonicalize_address (rtx x)
 
 static bool
 should_replace_address (rtx old_rtx, rtx new_rtx, enum machine_mode mode,
-			bool speed)
+			addr_space_t as, bool speed)
 {
   int gain;
 
-  if (rtx_equal_p (old_rtx, new_rtx) || !memory_address_p (mode, new_rtx))
+  if (rtx_equal_p (old_rtx, new_rtx)
+      || !memory_address_addr_space_p (mode, new_rtx, as))
     return false;
 
   /* Copy propagation is always ok.  */
@@ -197,7 +198,8 @@ should_replace_address (rtx old_rtx, rtx
     return true;
 
   /* Prefer the new address if it is less expensive.  */
-  gain = address_cost (old_rtx, mode, speed) - address_cost (new_rtx, mode, speed);
+  gain = (address_cost (old_rtx, mode, as, speed)
+	  - address_cost (new_rtx, mode, as, speed));
 
   /* If the addresses have equivalent cost, prefer the new address
      if it has the highest `rtx_cost'.  That has the potential of
@@ -365,6 +367,7 @@ propagate_rtx_1 (rtx *px, rtx old_rtx, r
 	  /* Copy propagations are always ok.  Otherwise check the costs.  */
 	  if (!(REG_P (old_rtx) && REG_P (new_rtx))
 	      && !should_replace_address (op0, new_op0, GET_MODE (x),
+					  MEM_ADDR_SPACE (x),
 	      			 	  flags & PR_OPTIMIZE_FOR_SPEED))
 	    return true;
 
diff -urNp gcc-4.4.4.orig/gcc/gimple-pretty-print.c gcc-4.4.4/gcc/gimple-pretty-print.c
--- a/src/gcc/gimple-pretty-print.c	2009-01-02
+++ b/src/gcc/gimple-pretty-print.c	2010-06-30
@@ -254,6 +254,7 @@ dump_unary_rhs (pretty_printer *buffer, 
       break;
 
     case FIXED_CONVERT_EXPR:
+    case ADDR_SPACE_CONVERT_EXPR:
     case FIX_TRUNC_EXPR:
     case FLOAT_EXPR:
     CASE_CONVERT:
diff -urNp gcc-4.4.4.orig/gcc/ifcvt.c gcc-4.4.4/gcc/ifcvt.c
--- a/src/gcc/ifcvt.c	2010-06-30
+++ b/src/gcc/ifcvt.c	2010-06-30
@@ -1411,11 +1411,15 @@ noce_try_cmove_arith (struct noce_if_inf
   /* ??? FIXME: Magic number 5.  */
   if (cse_not_expected
       && MEM_P (a) && MEM_P (b)
+      && MEM_ADDR_SPACE (a) == MEM_ADDR_SPACE (b)
       && if_info->branch_cost >= 5)
     {
+      enum machine_mode address_mode
+	= targetm.addr_space.address_mode (MEM_ADDR_SPACE (a));
+
       a = XEXP (a, 0);
       b = XEXP (b, 0);
-      x = gen_reg_rtx (Pmode);
+      x = gen_reg_rtx (address_mode);
       is_mem = 1;
     }
 
@@ -1564,6 +1568,9 @@ noce_try_cmove_arith (struct noce_if_inf
       set_mem_align (tmp,
 		     MIN (MEM_ALIGN (if_info->a), MEM_ALIGN (if_info->b)));
 
+      gcc_assert (MEM_ADDR_SPACE (if_info->a) == MEM_ADDR_SPACE (if_info->b));
+      set_mem_addr_space (tmp, MEM_ADDR_SPACE (if_info->a));
+
       noce_emit_move_insn (if_info->x, tmp);
     }
   else if (target != x)
diff -urNp gcc-4.4.4.orig/gcc/jump.c gcc-4.4.4/gcc/jump.c
--- a/src/gcc/jump.c	2009-02-25
+++ b/src/gcc/jump.c	2010-06-30
@@ -1641,6 +1641,10 @@ rtx_renumbered_equal_p (const_rtx x, con
   if (GET_MODE (x) != GET_MODE (y))
     return 0;
 
+  /* MEMs refering to different address space are not equivalent.  */
+  if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))
+    return 0;
+
   /* For commutative operations, the RTX match if the operand match in any
      order.  Also handle the simple binary and unary cases without a loop.  */
   if (targetm.commutative_p (x, UNKNOWN))
diff -urNp gcc-4.4.4.orig/gcc/Makefile.in gcc-4.4.4/gcc/Makefile.in
--- a/src/gcc/Makefile.in	2010-06-30
+++ b/src/gcc/Makefile.in	2010-06-30
@@ -2278,7 +2278,7 @@ tree-ssa-address.o : tree-ssa-address.c 
    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) \
    output.h $(DIAGNOSTIC_H) $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
    tree-pass.h $(FLAGS_H) $(TREE_INLINE_H) $(RECOG_H) insn-config.h $(EXPR_H) \
-   gt-tree-ssa-address.h $(GGC_H) tree-affine.h
+   gt-tree-ssa-address.h $(GGC_H) tree-affine.h $(TARGET_H)
 tree-ssa-loop-niter.o : tree-ssa-loop-niter.c $(TREE_FLOW_H) $(CONFIG_H) \
    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(PARAMS_H) \
    $(TREE_INLINE_H) output.h $(DIAGNOSTIC_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \
@@ -2598,7 +2598,7 @@ emit-rtl.o : emit-rtl.c $(CONFIG_H) $(SY
    $(TREE_H) $(FLAGS_H) $(FUNCTION_H) $(REGS_H) insn-config.h $(RECOG_H) \
    $(GGC_H) $(EXPR_H) hard-reg-set.h $(BITMAP_H) $(TOPLEV_H) $(BASIC_BLOCK_H) \
    $(HASHTAB_H) $(TM_P_H) debug.h langhooks.h tree-pass.h gt-emit-rtl.h \
-   $(REAL_H) $(DF_H)
+   $(REAL_H) $(DF_H) $(TARGET_H)
 real.o : real.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \
    $(TOPLEV_H) $(TM_P_H) $(REAL_H) dfp.h
 dfp.o : dfp.c dfp.h $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)	$(TREE_H) \
@@ -2806,7 +2806,7 @@ alloc-pool.o : alloc-pool.c $(CONFIG_H) 
 auto-inc-dec.o : auto-inc-dec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(TREE_H) $(RTL_H) $(TM_P_H) hard-reg-set.h $(BASIC_BLOCK_H) insn-config.h \
    $(REGS_H) $(FLAGS_H) output.h $(FUNCTION_H) except.h $(TOPLEV_H) $(RECOG_H) \
-   $(EXPR_H) $(TIMEVAR_H) tree-pass.h $(DF_H) $(DBGCNT_H)
+   $(EXPR_H) $(TIMEVAR_H) tree-pass.h $(DF_H) $(DBGCNT_H) $(TARGET_H)
 cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) \
    $(REGS_H) hard-reg-set.h output.h $(TOPLEV_H) $(FUNCTION_H) except.h $(GGC_H) \
    $(TM_P_H) $(TIMEVAR_H) $(OBSTACK_H) $(TREE_H) alloc-pool.h \
@@ -2987,7 +2987,7 @@ haifa-sched.o : haifa-sched.c $(CONFIG_H
 sched-deps.o : sched-deps.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
    $(FUNCTION_H) $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) except.h cselib.h \
-   $(PARAMS_H) $(TM_P_H)
+   $(PARAMS_H) $(TM_P_H) $(TARGET_H)
 sched-rgn.o : sched-rgn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \
    $(RTL_H) $(SCHED_INT_H) $(REGS_H) hard-reg-set.h $(FLAGS_H) insn-config.h \
    $(FUNCTION_H) $(INSN_ATTR_H) $(TOPLEV_H) $(RECOG_H) except.h $(PARAMS_H) \
diff -urNp gcc-4.4.4.orig/gcc/output.h gcc-4.4.4/gcc/output.h
--- a/src/gcc/output.h	2010-06-30
+++ b/src/gcc/output.h	2010-06-30
@@ -623,7 +623,6 @@ extern void default_emit_except_table_la
 extern void default_internal_label (FILE *, const char *, unsigned long);
 extern void default_file_start (void);
 extern void file_end_indicate_exec_stack (void);
-extern bool default_valid_pointer_mode (enum machine_mode);
 
 extern void default_elf_asm_output_external (FILE *file, tree,
 					     const char *);
diff -urNp gcc-4.4.4.orig/gcc/print-rtl.c gcc-4.4.4/gcc/print-rtl.c
--- a/src/gcc/print-rtl.c	2009-02-20
+++ b/src/gcc/print-rtl.c	2010-06-30
@@ -556,6 +556,9 @@ print_rtx (const_rtx in_rtx)
       if (MEM_ALIGN (in_rtx) != 1)
 	fprintf (outfile, " A%u", MEM_ALIGN (in_rtx));
 
+      if (!ADDR_SPACE_GENERIC_P (MEM_ADDR_SPACE (in_rtx)))
+	fprintf (outfile, " AS%u", MEM_ADDR_SPACE (in_rtx));
+
       fputc (']', outfile);
       break;
 
diff -urNp gcc-4.4.4.orig/gcc/print-tree.c gcc-4.4.4/gcc/print-tree.c
--- a/src/gcc/print-tree.c	2008-11-04
+++ b/src/gcc/print-tree.c	2010-06-30
@@ -110,6 +110,8 @@ print_node_brief (FILE *file, const char
 	    fprintf (file, " %s",
 		     IDENTIFIER_POINTER (DECL_NAME (TYPE_NAME (node))));
 	}
+      if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (node)))
+	fprintf (file, " address-space-%d", TYPE_ADDR_SPACE (node));
     }
   if (TREE_CODE (node) == IDENTIFIER_NODE)
     fprintf (file, " %s", IDENTIFIER_POINTER (node));
@@ -299,6 +301,9 @@ print_node (FILE *file, const char *pref
   else if (TYPE_P (node) && TYPE_SIZES_GIMPLIFIED (node))
     fputs (" sizes-gimplified", file);
 
+  if (TYPE_P (node) && !ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (node)))
+    fprintf (file, " address-space-%d", TYPE_ADDR_SPACE (node));
+
   if (TREE_ADDRESSABLE (node))
     fputs (" addressable", file);
   if (TREE_THIS_VOLATILE (node))
diff -urNp gcc-4.4.4.orig/gcc/recog.c gcc-4.4.4/gcc/recog.c
--- a/src/gcc/recog.c	2009-03-09
+++ b/src/gcc/recog.c	2010-06-30
@@ -376,7 +376,9 @@ verify_changes (int num)
 
       if (MEM_P (object))
 	{
-	  if (! memory_address_p (GET_MODE (object), XEXP (object, 0)))
+	  if (! memory_address_addr_space_p (GET_MODE (object),
+					     XEXP (object, 0),
+					     MEM_ADDR_SPACE (object)))
 	    break;
 	}
       else if (REG_P (changes[i].old)
@@ -964,7 +966,7 @@ general_operand (rtx op, enum machine_mo
 	return 0;
 
       /* Use the mem's mode, since it will be reloaded thus.  */
-      if (memory_address_p (GET_MODE (op), y))
+      if (memory_address_addr_space_p (GET_MODE (op), y, MEM_ADDR_SPACE (op)))
 	return 1;
     }
 
@@ -1248,11 +1250,16 @@ pop_operand (rtx op, enum machine_mode m
   return XEXP (op, 0) == stack_pointer_rtx;
 }
 
-/* Return 1 if ADDR is a valid memory address for mode MODE.  */
+/* Return 1 if ADDR is a valid memory address
+   for mode MODE in address space AS.  */
 
 int
-memory_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx addr)
+memory_address_addr_space_p (enum machine_mode mode ATTRIBUTE_UNUSED,
+			     rtx addr, addr_space_t as)
 {
+  if (!ADDR_SPACE_GENERIC_P (as))
+    return targetm.addr_space.legitimate_address_p (mode, addr, 0, as);
+
   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);
   return 0;
 
@@ -1829,7 +1836,8 @@ int
 offsettable_memref_p (rtx op)
 {
   return ((MEM_P (op))
-	  && offsettable_address_p (1, GET_MODE (op), XEXP (op, 0)));
+	  && offsettable_address_addr_space_p (1, GET_MODE (op), XEXP (op, 0),
+					       MEM_ADDR_SPACE (op)));
 }
 
 /* Similar, but don't require a strictly valid mem ref:
@@ -1839,12 +1847,13 @@ int
 offsettable_nonstrict_memref_p (rtx op)
 {
   return ((MEM_P (op))
-	  && offsettable_address_p (0, GET_MODE (op), XEXP (op, 0)));
+	  && offsettable_address_addr_space_p (0, GET_MODE (op), XEXP (op, 0),
+					       MEM_ADDR_SPACE (op)));
 }
 
 /* Return 1 if Y is a memory address which contains no side effects
-   and would remain valid after the addition of a positive integer
-   less than the size of that mode.
+   and would remain valid for address space AS after the addition of
+   a positive integer less than the size of that mode.
 
    We assume that the original address is valid and do not check it.
    We do check that it is valid for narrower modes.
@@ -1853,14 +1862,16 @@ offsettable_nonstrict_memref_p (rtx op)
    for the sake of use in reload.c.  */
 
 int
-offsettable_address_p (int strictp, enum machine_mode mode, rtx y)
+offsettable_address_addr_space_p (int strictp, enum machine_mode mode, rtx y,
+				  addr_space_t as)
 {
   enum rtx_code ycode = GET_CODE (y);
   rtx z;
   rtx y1 = y;
   rtx *y2;
-  int (*addressp) (enum machine_mode, rtx) =
-    (strictp ? strict_memory_address_p : memory_address_p);
+  int (*addressp) (enum machine_mode, rtx, addr_space_t) =
+    (strictp ? strict_memory_address_addr_space_p
+	     : memory_address_addr_space_p);
   unsigned int mode_sz = GET_MODE_SIZE (mode);
 
   if (CONSTANT_ADDRESS_P (y))
@@ -1890,7 +1901,7 @@ offsettable_address_p (int strictp, enum
       *y2 = plus_constant (*y2, mode_sz - 1);
       /* Use QImode because an odd displacement may be automatically invalid
 	 for any wider mode.  But it should be valid for a single byte.  */
-      good = (*addressp) (QImode, y);
+      good = (*addressp) (QImode, y, as);
 
       /* In any case, restore old contents of memory.  */
       *y2 = y1;
@@ -1915,7 +1926,7 @@ offsettable_address_p (int strictp, enum
 
   /* Use QImode because an odd displacement may be automatically invalid
      for any wider mode.  But it should be valid for a single byte.  */
-  return (*addressp) (QImode, z);
+  return (*addressp) (QImode, z, as);
 }
 
 /* Return 1 if ADDR is an address-expression whose effect depends
@@ -2459,11 +2470,14 @@ constrain_operands (int strict)
 		if (MEM_P (op))
 		  {
 		    if (strict > 0
-			&& !strict_memory_address_p (GET_MODE (op),
-						     XEXP (op, 0)))
+			&& !strict_memory_address_addr_space_p
+			     (GET_MODE (op), XEXP (op, 0),
+			      MEM_ADDR_SPACE (op)))
 		      break;
 		    if (strict == 0
-			&& !memory_address_p (GET_MODE (op), XEXP (op, 0)))
+			&& !memory_address_addr_space_p
+			     (GET_MODE (op), XEXP (op, 0),
+			      MEM_ADDR_SPACE (op)))
 		      break;
 		    win = 1;
 		  }
diff -urNp gcc-4.4.4.orig/gcc/recog.h gcc-4.4.4/gcc/recog.h
--- a/src/gcc/recog.h	2009-02-02
+++ b/src/gcc/recog.h	2010-06-30
@@ -84,8 +84,13 @@ extern int num_validated_changes (void);
 extern void cancel_changes (int);
 extern int constrain_operands (int);
 extern int constrain_operands_cached (int);
-extern int memory_address_p (enum machine_mode, rtx);
-extern int strict_memory_address_p (enum machine_mode, rtx);
+extern int memory_address_addr_space_p (enum machine_mode, rtx, addr_space_t);
+#define memory_address_p(mode,addr) \
+	memory_address_addr_space_p ((mode), (addr), ADDR_SPACE_GENERIC)
+extern int strict_memory_address_addr_space_p (enum machine_mode, rtx,
+					       addr_space_t);
+#define strict_memory_address_p(mode,addr) \
+	strict_memory_address_addr_space_p ((mode), (addr), ADDR_SPACE_GENERIC)
 extern int validate_replace_rtx (rtx, rtx, rtx);
 extern int validate_replace_rtx_part (rtx, rtx, rtx *, rtx);
 extern int validate_replace_rtx_part_nosimplify (rtx, rtx, rtx *, rtx);
@@ -100,7 +105,11 @@ extern int reg_fits_class_p (rtx, enum r
 
 extern int offsettable_memref_p (rtx);
 extern int offsettable_nonstrict_memref_p (rtx);
-extern int offsettable_address_p (int, enum machine_mode, rtx);
+extern int offsettable_address_addr_space_p (int, enum machine_mode, rtx,
+					     addr_space_t);
+#define offsettable_address_p(strict,mode,addr) \
+	offsettable_address_addr_space_p ((strict), (mode), (addr), \
+					  ADDR_SPACE_GENERIC)
 extern int mode_dependent_address_p (rtx);
 
 extern int recog (rtx, rtx, int *);
diff -urNp gcc-4.4.4.orig/gcc/regmove.c gcc-4.4.4/gcc/regmove.c
--- a/src/gcc/regmove.c	2010-06-30
+++ b/src/gcc/regmove.c	2010-06-30
@@ -179,7 +179,9 @@ try_auto_increment (rtx insn, rtx inc_in
 		   &SET_SRC (inc_insn_set),
 		   XEXP (SET_SRC (inc_insn_set), 0), 1);
 	      validate_change (insn, &XEXP (use, 0),
-			       gen_rtx_fmt_e (inc_code, Pmode, reg), 1);
+			       gen_rtx_fmt_e (inc_code,
+					      GET_MODE (XEXP (use, 0)), reg),
+			       1);
 	      if (apply_change_group ())
 		{
 		  /* If there is a REG_DEAD note on this insn, we must
diff -urNp gcc-4.4.4.orig/gcc/regrename.c gcc-4.4.4/gcc/regrename.c
--- a/src/gcc/regrename.c	2010-06-30
+++ b/src/gcc/regrename.c	2010-06-30
@@ -1207,7 +1207,7 @@ kill_autoinc_value (rtx *px, void *data)
     {
       x = XEXP (x, 0);
       kill_value (x, vd);
-      set_value_regno (REGNO (x), Pmode, vd);
+      set_value_regno (REGNO (x), GET_MODE (x), vd);
       return -1;
     }
 
diff -urNp gcc-4.4.4.orig/gcc/reload1.c gcc-4.4.4/gcc/reload1.c
--- a/src/gcc/reload1.c	2009-03-26
+++ b/src/gcc/reload1.c	2010-06-30
@@ -999,8 +999,9 @@ reload (rtx first, int global)
 	  {
 	    rtx x = eliminate_regs (reg_equiv_memory_loc[i], 0, NULL_RTX);
 
-	    if (strict_memory_address_p (GET_MODE (regno_reg_rtx[i]),
-					 XEXP (x, 0)))
+	    if (strict_memory_address_addr_space_p
+		  (GET_MODE (regno_reg_rtx[i]), XEXP (x, 0),
+		   MEM_ADDR_SPACE (x)))
 	      reg_equiv_mem[i] = x, reg_equiv_address[i] = 0;
 	    else if (CONSTANT_P (XEXP (x, 0))
 		     || (REG_P (XEXP (x, 0))
@@ -2610,7 +2611,7 @@ eliminate_regs_1 (rtx x, enum machine_mo
 		     && reg_equiv_constant[REGNO (new0)] != 0)
 	      new0 = reg_equiv_constant[REGNO (new0)];
 
-	    new_rtx = form_sum (new0, new1);
+	    new_rtx = form_sum (GET_MODE (x), new0, new1);
 
 	    /* As above, if we are not inside a MEM we do not want to
 	       turn a PLUS into something else.  We might try to do so here
diff -urNp gcc-4.4.4.orig/gcc/reload.c gcc-4.4.4/gcc/reload.c
--- a/src/gcc/reload.c	2010-06-30
+++ b/src/gcc/reload.c	2010-06-30
@@ -267,7 +267,8 @@ static bool alternative_allows_const_poo
 static rtx find_reloads_toplev (rtx, int, enum reload_type, int, int, rtx,
 				int *);
 static rtx make_memloc (rtx, int);
-static int maybe_memory_address_p (enum machine_mode, rtx, rtx *);
+static int maybe_memory_address_addr_space_p (enum machine_mode, rtx,
+					      addr_space_t, rtx *);
 static int find_reloads_address (enum machine_mode, rtx *, rtx, rtx *,
 				 int, enum reload_type, int, rtx);
 static rtx subst_reg_equivs (rtx, rtx);
@@ -611,7 +612,8 @@ get_secondary_mem (rtx x ATTRIBUTE_UNUSE
      didn't give us a new MEM, make a new one if it isn't valid.  */
 
   loc = eliminate_regs (secondary_memlocs[(int) mode], VOIDmode, NULL_RTX);
-  mem_valid = strict_memory_address_p (mode, XEXP (loc, 0));
+  mem_valid = strict_memory_address_addr_space_p (mode, XEXP (loc, 0),
+						  MEM_ADDR_SPACE (loc));
 
   if (! mem_valid && loc == secondary_memlocs[(int) mode])
     loc = copy_rtx (loc);
@@ -2127,13 +2129,17 @@ hard_reg_set_here_p (unsigned int beg_re
   return 0;
 }
 
-/* Return 1 if ADDR is a valid memory address for mode MODE,
-   and check that each pseudo reg has the proper kind of
-   hard reg.  */
+/* Return 1 if ADDR is a valid memory address for mode MODE
+   in address space AS, and check that each pseudo reg has the
+   proper kind of hard reg.  */
 
 int
-strict_memory_address_p (enum machine_mode mode ATTRIBUTE_UNUSED, rtx addr)
+strict_memory_address_addr_space_p (enum machine_mode mode ATTRIBUTE_UNUSED,
+				    rtx addr, addr_space_t as)
 {
+  if (!ADDR_SPACE_GENERIC_P (as))
+    return targetm.addr_space.legitimate_address_p (mode, addr, 1, as);
+
   GO_IF_LEGITIMATE_ADDRESS (mode, addr, win);
   return 0;
 
@@ -2241,6 +2247,10 @@ operands_match_p (rtx x, rtx y)
   if (GET_MODE (x) != GET_MODE (y))
     return 0;
 
+  /* MEMs refering to different address space are not equivalent.  */
+  if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))
+    return 0;
+
   switch (code)
     {
     case CONST_INT:
@@ -3947,12 +3957,15 @@ find_reloads (rtx insn, int replace, int
 		 && MEM_P (recog_data.operand[i]))
 	  {
 	    /* If the address to be reloaded is a VOIDmode constant,
-	       use Pmode as mode of the reload register, as would have
-	       been done by find_reloads_address.  */
+	       use the default address mode as mode of the reload register,
+	       as would have been done by find_reloads_address.  */
 	    enum machine_mode address_mode;
 	    address_mode = GET_MODE (XEXP (recog_data.operand[i], 0));
 	    if (address_mode == VOIDmode)
-	      address_mode = Pmode;
+	      {
+		addr_space_t as = MEM_ADDR_SPACE (recog_data.operand[i]);
+		address_mode = targetm.addr_space.address_mode (as);
+	      }
 
 	    operand_reloadnum[i]
 	      = push_reload (XEXP (recog_data.operand[i], 0), NULL_RTX,
@@ -4727,8 +4740,9 @@ find_reloads_toplev (rtx x, int opnum, e
 #endif
 	       && (reg_equiv_address[regno] != 0
 		   || (reg_equiv_mem[regno] != 0
-		       && (! strict_memory_address_p (GET_MODE (x),
-						      XEXP (reg_equiv_mem[regno], 0))
+		       && (! strict_memory_address_addr_space_p
+			       (GET_MODE (x), XEXP (reg_equiv_mem[regno], 0),
+				MEM_ADDR_SPACE (reg_equiv_mem[regno]))
 			   || ! offsettable_memref_p (reg_equiv_mem[regno])
 			   || num_not_at_initial_offset))))
 	x = find_reloads_subreg_address (x, 1, opnum, type, ind_levels,
@@ -4785,18 +4799,19 @@ make_memloc (rtx ad, int regno)
 }
 
 /* Returns true if AD could be turned into a valid memory reference
-   to mode MODE by reloading the part pointed to by PART into a
-   register.  */
+   to mode MODE in address space AS by reloading the part pointed to
+   by PART into a register.  */
 
 static int
-maybe_memory_address_p (enum machine_mode mode, rtx ad, rtx *part)
+maybe_memory_address_addr_space_p (enum machine_mode mode, rtx ad,
+				   addr_space_t as, rtx *part)
 {
   int retv;
   rtx tem = *part;
   rtx reg = gen_rtx_REG (GET_MODE (tem), max_reg_num ());
 
   *part = reg;
-  retv = memory_address_p (mode, ad);
+  retv = memory_address_addr_space_p (mode, ad, as);
   *part = tem;
 
   return retv;
@@ -4832,6 +4847,8 @@ find_reloads_address (enum machine_mode 
 		      rtx *loc, int opnum, enum reload_type type,
 		      int ind_levels, rtx insn)
 {
+  addr_space_t as = memrefloc? MEM_ADDR_SPACE (*memrefloc)
+			     : ADDR_SPACE_GENERIC;
   int regno;
   int removed_and = 0;
   int op_index;
@@ -4859,7 +4876,9 @@ find_reloads_address (enum machine_mode 
 	  if (reg_equiv_address[regno] != 0 || num_not_at_initial_offset)
 	    {
 	      tem = make_memloc (ad, regno);
-	      if (! strict_memory_address_p (GET_MODE (tem), XEXP (tem, 0)))
+	      if (! strict_memory_address_addr_space_p (GET_MODE (tem),
+							XEXP (tem, 0),
+							MEM_ADDR_SPACE (tem)))
 		{
 		  rtx orig = tem;
 
@@ -4875,7 +4894,7 @@ find_reloads_address (enum machine_mode 
 		 address: only reg or reg+constant.  */
 
 	      if (ind_levels > 0
-		  && strict_memory_address_p (mode, tem)
+		  && strict_memory_address_addr_space_p (mode, tem, as)
 		  && (REG_P (XEXP (tem, 0))
 		      || (GET_CODE (XEXP (tem, 0)) == PLUS
 			  && REG_P (XEXP (XEXP (tem, 0), 0))
@@ -4919,7 +4938,7 @@ find_reloads_address (enum machine_mode 
       return 1;
     }
 
-  if (strict_memory_address_p (mode, ad))
+  if (strict_memory_address_addr_space_p (mode, ad, as))
     {
       /* The address appears valid, so reloads are not needed.
 	 But the address may contain an eliminable register.
@@ -4942,14 +4961,14 @@ find_reloads_address (enum machine_mode 
 	return 0;
 
       /* Check result for validity after substitution.  */
-      if (strict_memory_address_p (mode, ad))
+      if (strict_memory_address_addr_space_p (mode, ad, as))
 	return 0;
     }
 
 #ifdef LEGITIMIZE_RELOAD_ADDRESS
   do
     {
-      if (memrefloc)
+      if (memrefloc && ADDR_SPACE_GENERIC_P (as))
 	{
 	  LEGITIMIZE_RELOAD_ADDRESS (ad, GET_MODE (*memrefloc), opnum, type,
 				     ind_levels, win);
@@ -5065,7 +5084,7 @@ find_reloads_address (enum machine_mode 
 	     That will at least work.  */
 	  find_reloads_address_part (ad, loc,
 				     base_reg_class (mode, MEM, SCRATCH),
-				     Pmode, opnum, type, ind_levels);
+				     GET_MODE (ad), opnum, type, ind_levels);
 	}
       return ! removed_and;
     }
@@ -5126,8 +5145,8 @@ find_reloads_address (enum machine_mode 
 	   || operand == arg_pointer_rtx
 #endif
 	   || operand == stack_pointer_rtx)
-	  && ! maybe_memory_address_p (mode, ad, 
-				       &XEXP (XEXP (ad, 0), 1 - op_index)))
+	  && ! maybe_memory_address_addr_space_p
+		(mode, ad, as, &XEXP (XEXP (ad, 0), 1 - op_index)))
 	{
 	  rtx offset_reg;
 	  enum reg_class cls;
@@ -5165,7 +5184,7 @@ find_reloads_address (enum machine_mode 
   tem = ad;
   if (GET_CODE (ad) == PLUS)
     tem = subst_indexed_address (ad);
-  if (tem != ad && strict_memory_address_p (mode, tem))
+  if (tem != ad && strict_memory_address_addr_space_p (mode, tem, as))
     {
       /* Ok, we win that way.  Replace any additional eliminable
 	 registers.  */
@@ -5175,7 +5194,8 @@ find_reloads_address (enum machine_mode 
 
       /* Make sure that didn't make the address invalid again.  */
 
-      if (! subst_reg_equivs_changed || strict_memory_address_p (mode, tem))
+      if (! subst_reg_equivs_changed
+	  || strict_memory_address_addr_space_p (mode, tem, as))
 	{
 	  *loc = tem;
 	  return 0;
@@ -5184,8 +5204,12 @@ find_reloads_address (enum machine_mode 
 
   /* If constants aren't valid addresses, reload the constant address
      into a register.  */
-  if (CONSTANT_P (ad) && ! strict_memory_address_p (mode, ad))
+  if (CONSTANT_P (ad) && ! strict_memory_address_addr_space_p (mode, ad, as))
     {
+      enum machine_mode address_mode = GET_MODE (ad);
+      if (address_mode == VOIDmode)
+	address_mode = targetm.addr_space.address_mode (as);
+
       /* If AD is an address in the constant pool, the MEM rtx may be shared.
 	 Unshare it so we can safely alter it.  */
       if (memrefloc && GET_CODE (ad) == SYMBOL_REF
@@ -5198,7 +5222,7 @@ find_reloads_address (enum machine_mode 
 	}
 
       find_reloads_address_part (ad, loc, base_reg_class (mode, MEM, SCRATCH),
-				 Pmode, opnum, type, ind_levels);
+				 address_mode, opnum, type, ind_levels);
       return ! removed_and;
     }
 
@@ -5285,16 +5309,12 @@ subst_reg_equivs (rtx ad, rtx insn)
    This routine assumes both inputs are already in canonical form.  */
 
 rtx
-form_sum (rtx x, rtx y)
+form_sum (enum machine_mode mode, rtx x, rtx y)
 {
   rtx tem;
-  enum machine_mode mode = GET_MODE (x);
-
-  if (mode == VOIDmode)
-    mode = GET_MODE (y);
 
-  if (mode == VOIDmode)
-    mode = Pmode;
+  gcc_assert (GET_MODE (x) == mode || GET_MODE (x) == VOIDmode);
+  gcc_assert (GET_MODE (y) == mode || GET_MODE (y) == VOIDmode);
 
   if (GET_CODE (x) == CONST_INT)
     return plus_constant (y, INTVAL (x));
@@ -5304,12 +5324,12 @@ form_sum (rtx x, rtx y)
     tem = x, x = y, y = tem;
 
   if (GET_CODE (x) == PLUS && CONSTANT_P (XEXP (x, 1)))
-    return form_sum (XEXP (x, 0), form_sum (XEXP (x, 1), y));
+    return form_sum (mode, XEXP (x, 0), form_sum (mode, XEXP (x, 1), y));
 
   /* Note that if the operands of Y are specified in the opposite
      order in the recursive calls below, infinite recursion will occur.  */
   if (GET_CODE (y) == PLUS && CONSTANT_P (XEXP (y, 1)))
-    return form_sum (form_sum (x, XEXP (y, 0)), XEXP (y, 1));
+    return form_sum (mode, form_sum (mode, x, XEXP (y, 0)), XEXP (y, 1));
 
   /* If both constant, encapsulate sum.  Otherwise, just form sum.  A
      constant will have been placed second.  */
@@ -5376,9 +5396,9 @@ subst_indexed_address (rtx addr)
 
       /* Compute the sum.  */
       if (op2 != 0)
-	op1 = form_sum (op1, op2);
+	op1 = form_sum (GET_MODE (addr), op1, op2);
       if (op1 != 0)
-	op0 = form_sum (op0, op1);
+	op0 = form_sum (GET_MODE (addr), op0, op1);
 
       return op0;
     }
@@ -5778,7 +5798,8 @@ find_reloads_address_1 (enum machine_mod
 	      rtx equiv = (MEM_P (XEXP (x, 0))
 			   ? XEXP (x, 0)
 			   : reg_equiv_mem[regno]);
-	      int icode = (int) optab_handler (add_optab, Pmode)->insn_code;
+	      int icode
+		= (int) optab_handler (add_optab, GET_MODE (x))->insn_code;
 	      if (insn && NONJUMP_INSN_P (insn) && equiv
 		  && memory_operand (equiv, GET_MODE (equiv))
 #ifdef HAVE_cc0
@@ -5786,9 +5807,9 @@ find_reloads_address_1 (enum machine_mod
 #endif
 		  && ! (icode != CODE_FOR_nothing
 			&& ((*insn_data[icode].operand[0].predicate)
-			    (equiv, Pmode))
+			    (equiv, GET_MODE (x)))
 			&& ((*insn_data[icode].operand[1].predicate)
-			    (equiv, Pmode))))
+			    (equiv, GET_MODE (x)))))
 		{
 		  /* We use the original pseudo for loc, so that
 		     emit_reload_insns() knows which pseudo this
@@ -6149,8 +6170,9 @@ find_reloads_subreg_address (rtx x, int 
 		 the address, there is nothing further to do.  */
 	      if (reloaded == 0
 		  && reg_equiv_mem[regno] != 0
-		  && !strict_memory_address_p (GET_MODE (x),
-					       XEXP (reg_equiv_mem[regno], 0)))
+		  && !strict_memory_address_addr_space_p
+			(GET_MODE (x), XEXP (reg_equiv_mem[regno], 0),
+			 MEM_ADDR_SPACE (reg_equiv_mem[regno])))
 		push_reload (XEXP (tem, 0), NULL_RTX, &XEXP (tem, 0), (rtx*) 0,
 			     base_reg_class (GET_MODE (tem), MEM, SCRATCH),
 			     GET_MODE (XEXP (tem, 0)), VOIDmode, 0, 0,
diff -urNp gcc-4.4.4.orig/gcc/reload.h gcc-4.4.4/gcc/reload.h
--- a/src/gcc/reload.h	2010-03-31
+++ b/src/gcc/reload.h	2010-06-30
@@ -289,7 +289,7 @@ extern int find_reloads (rtx, int, int, 
    address, namely: sum constant integers, surround the sum of two
    constants with a CONST, put the constant as the second operand, and
    group the constant on the outermost sum.  */
-extern rtx form_sum (rtx, rtx);
+extern rtx form_sum (enum machine_mode, rtx, rtx);
 
 /* Substitute into the current INSN the registers into which we have reloaded
    the things that need reloading.  */
diff -urNp gcc-4.4.4.orig/gcc/rtlanal.c gcc-4.4.4/gcc/rtlanal.c
--- a/src/gcc/rtlanal.c	2010-06-30
+++ b/src/gcc/rtlanal.c	2010-06-30
@@ -3621,13 +3621,13 @@ rtx_cost (rtx x, enum rtx_code outer_cod
    be returned.  */
 
 int
-address_cost (rtx x, enum machine_mode mode, bool speed)
+address_cost (rtx x, enum machine_mode mode, addr_space_t as, bool speed)
 {
   /* We may be asked for cost of various unusual addresses, such as operands
      of push instruction.  It is not worthwhile to complicate writing
      of the target hook by such cases.  */
 
-  if (!memory_address_p (mode, x))
+  if (!memory_address_addr_space_p (mode, x, as))
     return 1000;
 
   return targetm.address_cost (x, speed);
@@ -3766,7 +3766,11 @@ nonzero_bits1 (const_rtx x, enum machine
 #if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)
       /* If pointers extend unsigned and this is a pointer in Pmode, say that
 	 all the bits above ptr_mode are known to be zero.  */
-      if (POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode
+      /* As we do not know which address space the pointer is refering to,
+	 we can do this only if the target does not support different pointer
+	 or address modes depending on the address space.  */
+      if (target_default_pointer_address_modes_p ()
+	  && POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode
 	  && REG_POINTER (x))
 	nonzero &= GET_MODE_MASK (ptr_mode);
 #endif
@@ -4003,7 +4007,11 @@ nonzero_bits1 (const_rtx x, enum machine
 	/* If pointers extend unsigned and this is an addition or subtraction
 	   to a pointer in Pmode, all the bits above ptr_mode are known to be
 	   zero.  */
-	if (POINTERS_EXTEND_UNSIGNED > 0 && GET_MODE (x) == Pmode
+	/* As we do not know which address space the pointer is refering to,
+	   we can do this only if the target does not support different pointer
+	   or address modes depending on the address space.  */
+	if (target_default_pointer_address_modes_p ()
+	    && POINTERS_EXTEND_UNSIGNED > 0 && GET_MODE (x) == Pmode
 	    && (code == PLUS || code == MINUS)
 	    && REG_P (XEXP (x, 0)) && REG_POINTER (XEXP (x, 0)))
 	  nonzero &= GET_MODE_MASK (ptr_mode);
@@ -4277,8 +4285,12 @@ num_sign_bit_copies1 (const_rtx x, enum 
 #if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)
       /* If pointers extend signed and this is a pointer in Pmode, say that
 	 all the bits above ptr_mode are known to be sign bit copies.  */
-      if (! POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode && mode == Pmode
-	  && REG_POINTER (x))
+      /* As we do not know which address space the pointer is refering to,
+	 we can do this only if the target does not support different pointer
+	 or address modes depending on the address space.  */
+      if (target_default_pointer_address_modes_p ()
+	  && ! POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode
+	  && mode == Pmode && REG_POINTER (x))
 	return GET_MODE_BITSIZE (Pmode) - GET_MODE_BITSIZE (ptr_mode) + 1;
 #endif
 
@@ -4474,7 +4486,11 @@ num_sign_bit_copies1 (const_rtx x, enum 
       /* If pointers extend signed and this is an addition or subtraction
 	 to a pointer in Pmode, all the bits above ptr_mode are known to be
 	 sign bit copies.  */
-      if (! POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode
+      /* As we do not know which address space the pointer is refering to,
+	 we can do this only if the target does not support different pointer
+	 or address modes depending on the address space.  */
+      if (target_default_pointer_address_modes_p ()
+	  && ! POINTERS_EXTEND_UNSIGNED && GET_MODE (x) == Pmode
 	  && (code == PLUS || code == MINUS)
 	  && REG_P (XEXP (x, 0)) && REG_POINTER (XEXP (x, 0)))
 	result = MAX ((int) (GET_MODE_BITSIZE (Pmode)
diff -urNp gcc-4.4.4.orig/gcc/rtl.c gcc-4.4.4/gcc/rtl.c
--- a/src/gcc/rtl.c	2009-02-20
+++ b/src/gcc/rtl.c	2010-06-30
@@ -367,6 +367,14 @@ rtx_equal_p_cb (const_rtx x, const_rtx y
   if (GET_MODE (x) != GET_MODE (y))
     return 0;
 
+  /* MEMs refering to different address space are not equivalent.  */
+  if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))
+    return 0;
+
+  /* MEMs refering to different address space are not equivalent.  */
+  if (code == MEM && MEM_ADDR_SPACE (x) != MEM_ADDR_SPACE (y))
+    return 0;
+
   /* Some RTL can be compared nonrecursively.  */
   switch (code)
     {
diff -urNp gcc-4.4.4.orig/gcc/rtl.h gcc-4.4.4/gcc/rtl.h
--- a/src/gcc/rtl.h	2010-03-08
+++ b/src/gcc/rtl.h	2010-06-30
@@ -146,6 +146,7 @@ typedef struct mem_attrs GTY(())
   rtx size;			/* Size in bytes, as a CONST_INT.  */
   alias_set_type alias;		/* Memory alias set.  */
   unsigned int align;		/* Alignment of MEM in bits.  */
+  unsigned char addrspace;	/* Address space (0 for generic).  */
 } mem_attrs;
 
 /* Structure used to describe the attributes of a REG in similar way as
@@ -1075,7 +1076,7 @@ rhs_regno (const_rtx x)
 
 extern void init_rtlanal (void);
 extern int rtx_cost (rtx, enum rtx_code, bool);
-extern int address_cost (rtx, enum machine_mode, bool);
+extern int address_cost (rtx, enum machine_mode, addr_space_t, bool);
 extern unsigned int subreg_lsb (const_rtx);
 extern unsigned int subreg_lsb_1 (enum machine_mode, enum machine_mode,
 				  unsigned int);
@@ -1209,6 +1210,10 @@ do {						\
    RTX that is always a CONST_INT.  */
 #define MEM_OFFSET(RTX) (MEM_ATTRS (RTX) == 0 ? 0 : MEM_ATTRS (RTX)->offset)
 
+/* For a MEM rtx, the address space.  */
+#define MEM_ADDR_SPACE(RTX) (MEM_ATTRS (RTX) == 0 ? ADDR_SPACE_GENERIC \
+						  : MEM_ATTRS (RTX)->addrspace)
+
 /* For a MEM rtx, the size in bytes of the MEM, if known, as an RTX that
    is always a CONST_INT.  */
 #define MEM_SIZE(RTX)							\
@@ -1542,7 +1547,10 @@ extern unsigned int subreg_highpart_offs
 					    enum machine_mode);
 extern int byte_lowpart_offset (enum machine_mode, enum machine_mode);
 extern rtx make_safe_from (rtx, rtx);
-extern rtx convert_memory_address (enum machine_mode, rtx);
+extern rtx convert_memory_address_addr_space (enum machine_mode, rtx,
+					      addr_space_t);
+#define convert_memory_address(to_mode,x) \
+	convert_memory_address_addr_space ((to_mode), (x), ADDR_SPACE_GENERIC)
 extern rtx get_insns (void);
 extern const char *get_insn_name (int);
 extern rtx get_last_insn (void);
diff -urNp gcc-4.4.4.orig/gcc/rtlhooks.c gcc-4.4.4/gcc/rtlhooks.c
--- a/src/gcc/rtlhooks.c	2009-02-20
+++ b/src/gcc/rtlhooks.c	2010-06-30
@@ -153,7 +153,8 @@ gen_lowpart_if_possible (enum machine_mo
 		   - MIN (UNITS_PER_WORD, GET_MODE_SIZE (GET_MODE (x))));
 
       new_rtx = adjust_address_nv (x, mode, offset);
-      if (! memory_address_p (mode, XEXP (new_rtx, 0)))
+      if (! memory_address_addr_space_p (mode, XEXP (new_rtx, 0),
+					 MEM_ADDR_SPACE (x)))
 	return 0;
 
       return new_rtx;
diff -urNp gcc-4.4.4.orig/gcc/sched-deps.c gcc-4.4.4/gcc/sched-deps.c
--- a/src/gcc/sched-deps.c	2009-02-20
+++ b/src/gcc/sched-deps.c	2010-06-30
@@ -41,6 +41,7 @@ along with GCC; see the file COPYING3.  
 #include "sched-int.h"
 #include "params.h"
 #include "cselib.h"
+#include "target.h"
 
 #ifdef INSN_SCHEDULING
 
@@ -1907,8 +1908,11 @@ sched_analyze_1 (struct deps *deps, rtx 
 
       if (sched_deps_info->use_cselib)
 	{
+	  enum machine_mode address_mode
+	    = targetm.addr_space.address_mode (MEM_ADDR_SPACE (dest));
+
 	  t = shallow_copy_rtx (dest);
-	  cselib_lookup (XEXP (t, 0), Pmode, 1);
+	  cselib_lookup (XEXP (t, 0), address_mode, 1);
 	  XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));
 	}
       t = canon_rtx (t);
@@ -2061,8 +2065,11 @@ sched_analyze_2 (struct deps *deps, rtx 
 
 	if (sched_deps_info->use_cselib)
 	  {
+	    enum machine_mode address_mode
+	      = targetm.addr_space.address_mode (MEM_ADDR_SPACE (t));
+
 	    t = shallow_copy_rtx (t);
-	    cselib_lookup (XEXP (t, 0), Pmode, 1);
+	    cselib_lookup (XEXP (t, 0), address_mode, 1);
 	    XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));
 	  }
 	t = canon_rtx (t);
diff -urNp gcc-4.4.4.orig/gcc/sel-sched-dump.c gcc-4.4.4/gcc/sel-sched-dump.c
--- a/src/gcc/sel-sched-dump.c	2010-06-30
+++ b/src/gcc/sel-sched-dump.c	2010-06-30
@@ -34,6 +34,7 @@ along with GCC; see the file COPYING3.  
 #include "output.h"
 #include "basic-block.h"
 #include "cselib.h"
+#include "target.h"
 
 #ifdef INSN_SCHEDULING
 #include "sel-sched-ir.h"
@@ -953,10 +954,13 @@ rtx
 debug_mem_addr_value (rtx x)
 {
   rtx t, addr;
+  enum machine_mode address_mode;
 
   gcc_assert (MEM_P (x));
+  address_mode = targetm.addr_space.address_mode (MEM_ADDR_SPACE (x));
+
   t = shallow_copy_rtx (x);
-  if (cselib_lookup (XEXP (t, 0), Pmode, 0))
+  if (cselib_lookup (XEXP (t, 0), address_mode, 0))
     XEXP (t, 0) = cselib_subst_to_values (XEXP (t, 0));
 
   t = canon_rtx (t);
diff -urNp gcc-4.4.4.orig/gcc/simplify-rtx.c gcc-4.4.4/gcc/simplify-rtx.c
--- a/src/gcc/simplify-rtx.c	2010-01-12
+++ b/src/gcc/simplify-rtx.c	2010-06-30
@@ -863,7 +863,11 @@ simplify_unary_operation_1 (enum rtx_cod
 	return rtl_hooks.gen_lowpart_no_emit (mode, op);
 
 #if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)
-      if (! POINTERS_EXTEND_UNSIGNED
+      /* As we do not know which address space the pointer is refering to,
+	 we can do this only if the target does not support different pointer
+	 or address modes depending on the address space.  */
+      if (target_default_pointer_address_modes_p ()
+	  && ! POINTERS_EXTEND_UNSIGNED
 	  && mode == Pmode && GET_MODE (op) == ptr_mode
 	  && (CONSTANT_P (op)
 	      || (GET_CODE (op) == SUBREG
@@ -885,7 +889,11 @@ simplify_unary_operation_1 (enum rtx_cod
 	return rtl_hooks.gen_lowpart_no_emit (mode, op);
 
 #if defined(POINTERS_EXTEND_UNSIGNED) && !defined(HAVE_ptr_extend)
-      if (POINTERS_EXTEND_UNSIGNED > 0
+      /* As we do not know which address space the pointer is refering to,
+	 we can do this only if the target does not support different pointer
+	 or address modes depending on the address space.  */
+      if (target_default_pointer_address_modes_p ()
+	  && POINTERS_EXTEND_UNSIGNED > 0
 	  && mode == Pmode && GET_MODE (op) == ptr_mode
 	  && (CONSTANT_P (op)
 	      || (GET_CODE (op) == SUBREG
diff -urNp gcc-4.4.4.orig/gcc/stor-layout.c gcc-4.4.4/gcc/stor-layout.c
--- a/src/gcc/stor-layout.c	2010-03-31
+++ b/src/gcc/stor-layout.c	2010-06-30
@@ -48,9 +48,9 @@ unsigned int maximum_field_alignment = T
 /* ... and its original value in bytes, specified via -fpack-struct=<value>.  */
 unsigned int initial_max_fld_align = TARGET_DEFAULT_PACK_STRUCT;
 
-/* Nonzero if all REFERENCE_TYPEs are internal and hence should be
-   allocated in Pmode, not ptr_mode.   Set only by internal_reference_types
-   called only by a front end.  */
+/* Nonzero if all REFERENCE_TYPEs are internal and hence should be allocated
+   in the address spaces' address_mode, not pointer_mode.   Set only by
+   internal_reference_types called only by a front end.  */
 static int reference_types_internal = 0;
 
 static void finalize_record_size (record_layout_info);
@@ -66,8 +66,8 @@ extern void debug_rli (record_layout_inf
 
 static GTY(()) tree pending_sizes;
 
-/* Show that REFERENCE_TYPES are internal and should be Pmode.  Called only
-   by front end.  */
+/* Show that REFERENCE_TYPES are internal and should use address_mode.
+   Called only by front end.  */
 
 void
 internal_reference_types (void)
@@ -1700,6 +1700,7 @@ layout_type (tree type)
       /* A pointer might be MODE_PARTIAL_INT,
 	 but ptrdiff_t must be integral.  */
       SET_TYPE_MODE (type, mode_for_size (POINTER_SIZE, MODE_INT, 0));
+      TYPE_PRECISION (type) = POINTER_SIZE;
       break;
 
     case FUNCTION_TYPE:
@@ -1715,16 +1716,17 @@ layout_type (tree type)
     case POINTER_TYPE:
     case REFERENCE_TYPE:
       {
-	enum machine_mode mode = ((TREE_CODE (type) == REFERENCE_TYPE
-				   && reference_types_internal)
-				  ? Pmode : TYPE_MODE (type));
-
-	int nbits = GET_MODE_BITSIZE (mode);
+	enum machine_mode mode = TYPE_MODE (type);
+	if (TREE_CODE (type) == REFERENCE_TYPE && reference_types_internal)
+	  {
+	    addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (type));
+	    mode = targetm.addr_space.address_mode (as);
+	  }
 
-	TYPE_SIZE (type) = bitsize_int (nbits);
+	TYPE_SIZE (type) = bitsize_int (GET_MODE_BITSIZE (mode));
 	TYPE_SIZE_UNIT (type) = size_int (GET_MODE_SIZE (mode));
 	TYPE_UNSIGNED (type) = 1;
-	TYPE_PRECISION (type) = nbits;
+	TYPE_PRECISION (type) = GET_MODE_BITSIZE (mode);
       }
       break;
 
diff -urNp gcc-4.4.4.orig/gcc/target-def.h gcc-4.4.4/gcc/target-def.h
--- a/src/gcc/target-def.h	2010-06-30
+++ b/src/gcc/target-def.h	2010-06-30
@@ -471,6 +471,48 @@
 #define TARGET_VALID_POINTER_MODE default_valid_pointer_mode
 #endif
 
+#ifndef TARGET_ADDR_SPACE_POINTER_MODE
+#define TARGET_ADDR_SPACE_POINTER_MODE default_addr_space_pointer_mode
+#endif
+
+#ifndef TARGET_ADDR_SPACE_ADDRESS_MODE
+#define TARGET_ADDR_SPACE_ADDRESS_MODE default_addr_space_address_mode
+#endif
+
+#ifndef TARGET_ADDR_SPACE_VALID_POINTER_MODE
+#define TARGET_ADDR_SPACE_VALID_POINTER_MODE \
+	default_addr_space_valid_pointer_mode
+#endif
+
+#ifndef TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P
+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P \
+  default_addr_space_legitimate_address_p
+#endif
+
+#ifndef TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS
+#define TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS \
+  default_addr_space_legitimize_address
+#endif
+
+#ifndef TARGET_ADDR_SPACE_SUBSET_P
+#define TARGET_ADDR_SPACE_SUBSET_P default_addr_space_subset_p
+#endif
+
+#ifndef TARGET_ADDR_SPACE_CONVERT
+#define TARGET_ADDR_SPACE_CONVERT default_addr_space_convert
+#endif
+
+#define TARGET_ADDR_SPACE_HOOKS			\
+  {						\
+    TARGET_ADDR_SPACE_POINTER_MODE,		\
+    TARGET_ADDR_SPACE_ADDRESS_MODE,		\
+    TARGET_ADDR_SPACE_VALID_POINTER_MODE,	\
+    TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P,	\
+    TARGET_ADDR_SPACE_LEGITIMIZE_ADDRESS,	\
+    TARGET_ADDR_SPACE_SUBSET_P,			\
+    TARGET_ADDR_SPACE_CONVERT,			\
+  }
+
 #ifndef TARGET_SCALAR_MODE_SUPPORTED_P
 #define TARGET_SCALAR_MODE_SUPPORTED_P default_scalar_mode_supported_p
 #endif
@@ -906,6 +948,7 @@
   TARGET_MIN_DIVISIONS_FOR_RECIP_MUL,		\
   TARGET_MODE_REP_EXTENDED,			\
   TARGET_VALID_POINTER_MODE,                    \
+  TARGET_ADDR_SPACE_HOOKS,			\
   TARGET_SCALAR_MODE_SUPPORTED_P,		\
   TARGET_VECTOR_MODE_SUPPORTED_P,               \
   TARGET_VECTOR_OPAQUE_P,			\
diff -urNp gcc-4.4.4.orig/gcc/target.h gcc-4.4.4/gcc/target.h
--- a/src/gcc/target.h	2010-06-30
+++ b/src/gcc/target.h	2010-06-30
@@ -68,6 +68,12 @@ typedef int (* print_switch_fn_type) (pr
 /* An example implementation for ELF targets.  Defined in varasm.c  */
 extern int elf_record_gcc_switches (print_switch_type type, const char *);
 
+/* Some places still assume that all pointer or address modes are the
+   standard Pmode and ptr_mode.  These optimizations become invalid if
+   the target actually supports multiple different modes.  For now,
+   we disable such optimizations on such targets, using this function.  */
+extern bool target_default_pointer_address_modes_p (void);
+
 struct stdarg_info;
 struct spec_info_def;
 
@@ -673,6 +679,36 @@ struct gcc_target
   /* True if MODE is valid for a pointer in __attribute__((mode("MODE"))).  */
   bool (* valid_pointer_mode) (enum machine_mode mode);
 
+  /* Support for named address spaces.  */
+  struct addr_space {
+    /* MODE to use for a pointer into another address space.  */
+    enum machine_mode (* pointer_mode) (addr_space_t);
+
+    /* MODE to use for an address in another address space.  */
+    enum machine_mode (* address_mode) (addr_space_t);
+
+    /* True if MODE is valid for a pointer in __attribute__((mode("MODE")))
+       in another address space.  */
+    bool (* valid_pointer_mode) (enum machine_mode, addr_space_t);
+
+    /* True if an address is a valid memory address to a given named address
+       space for a given mode.  */
+    bool (* legitimate_address_p) (enum machine_mode, rtx, bool, addr_space_t);
+
+    /* Return an updated address to convert an invalid pointer to a named
+       address space to a valid one.  If NULL_RTX is returned use machine
+       independent methods to make the address valid.  */
+    rtx (* legitimize_address) (rtx, rtx, enum machine_mode, addr_space_t);
+
+    /* True if one named address space is a subset of another named address. */
+    bool (* subset_p) (addr_space_t, addr_space_t);
+
+    /* Function to convert an rtl expression from one address space to
+       another.  */
+    rtx (* convert) (rtx, tree, tree);
+
+  } addr_space;
+
   /* True if MODE is valid for the target.  By "valid", we mean able to
      be manipulated in non-trivial ways.  In particular, this means all
      the arithmetic is supported.  */
diff -urNp gcc-4.4.4.orig/gcc/targhooks.c gcc-4.4.4/gcc/targhooks.c
--- a/src/gcc/targhooks.c	2010-06-30
+++ b/src/gcc/targhooks.c	2010-06-30
@@ -743,6 +743,106 @@ default_vector_min_alignment (const_tree
   return TYPE_ALIGN_UNIT (type);
 }
 
+/* Determine whether or not a pointer mode is valid. Assume defaults
+   of ptr_mode or Pmode - can be overridden.  */
+bool
+default_valid_pointer_mode (enum machine_mode mode)
+{
+  return (mode == ptr_mode || mode == Pmode);
+}
+
+/* Return the mode for a pointer to a given ADDRSPACE, defaulting to ptr_mode
+   for the generic address space only.  */
+
+enum machine_mode
+default_addr_space_pointer_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)
+{
+  gcc_assert (ADDR_SPACE_GENERIC_P (addrspace));
+  return ptr_mode;
+}
+
+/* Return the mode for an address in a given ADDRSPACE, defaulting to Pmode
+   for the generic address space only.  */
+
+enum machine_mode
+default_addr_space_address_mode (addr_space_t addrspace ATTRIBUTE_UNUSED)
+{
+  gcc_assert (ADDR_SPACE_GENERIC_P (addrspace));
+  return Pmode;
+}
+
+/* Named address space version of valid_pointer_mode.  */
+
+bool
+default_addr_space_valid_pointer_mode (enum machine_mode mode, addr_space_t as)
+{
+  if (!ADDR_SPACE_GENERIC_P (as))
+    return (mode == targetm.addr_space.pointer_mode (as)
+	    || mode == targetm.addr_space.address_mode (as));
+
+  return targetm.valid_pointer_mode (mode);
+}
+
+/* Some places still assume that all pointer or address modes are the
+   standard Pmode and ptr_mode.  These optimizations become invalid if
+   the target actually supports multiple different modes.  For now,
+   we disable such optimizations on such targets, using this function.  */
+
+bool
+target_default_pointer_address_modes_p (void)
+{
+  if (targetm.addr_space.address_mode != default_addr_space_address_mode)
+    return false;
+  if (targetm.addr_space.pointer_mode != default_addr_space_pointer_mode)
+    return false;
+
+  return true;
+}
+
+/* Named address space version of legitimate_address_p.  */
+
+bool
+default_addr_space_legitimate_address_p (enum machine_mode mode, rtx mem,
+					 bool strict, addr_space_t as)
+{
+  gcc_unreachable ();
+}
+
+/* Named address space version of LEGITIMIZE_ADDRESS.  */
+
+rtx
+default_addr_space_legitimize_address (rtx x, rtx oldx,
+				       enum machine_mode mode, addr_space_t as)
+{
+  if (!ADDR_SPACE_GENERIC_P (as))
+    return x;
+
+  LEGITIMIZE_ADDRESS (x, oldx, mode, done);
+done:
+  return x;
+}
+
+/* The default hook for determining if one named address space is a subset of
+   another and to return which address space to use as the common address
+   space.  */
+
+bool
+default_addr_space_subset_p (addr_space_t subset, addr_space_t superset)
+{
+  return (subset == superset);
+}
+
+/* The default hook for TARGET_ADDR_SPACE_CONVERT. This hook should never be
+   called for targets with only a generic address space.  */
+
+rtx
+default_addr_space_convert (rtx op ATTRIBUTE_UNUSED,
+			    tree from_type ATTRIBUTE_UNUSED,
+			    tree to_type ATTRIBUTE_UNUSED)
+{
+  gcc_unreachable ();
+}
+
 bool
 default_hard_regno_scratch_ok (unsigned int regno ATTRIBUTE_UNUSED)
 {
diff -urNp gcc-4.4.4.orig/gcc/targhooks.h gcc-4.4.4/gcc/targhooks.h
--- a/src/gcc/targhooks.h	2010-06-30
+++ b/src/gcc/targhooks.h	2010-06-30
@@ -108,3 +108,15 @@ extern bool default_hard_regno_scratch_o
 extern bool default_target_option_valid_attribute_p (tree, tree, tree, int);
 extern bool default_target_option_pragma_parse (tree, tree);
 extern bool default_target_option_can_inline_p (tree, tree);
+extern bool default_valid_pointer_mode (enum machine_mode);
+extern enum machine_mode default_addr_space_pointer_mode (addr_space_t);
+extern enum machine_mode default_addr_space_address_mode (addr_space_t);
+extern bool default_addr_space_valid_pointer_mode (enum machine_mode,
+						   addr_space_t);
+extern bool default_addr_space_legitimate_address_p (enum machine_mode, rtx,
+						     bool, addr_space_t);
+extern rtx default_addr_space_legitimize_address (rtx, rtx, enum machine_mode,
+						  addr_space_t);
+extern bool default_addr_space_subset_p (addr_space_t, addr_space_t);
+extern rtx default_addr_space_convert (rtx, tree, tree);
+
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.dg/simd-1b.c gcc-4.4.4/gcc/testsuite/gcc.dg/simd-1b.c
--- a/src/gcc/testsuite/gcc.dg/simd-1b.c	2005-06-15
+++ b/src/gcc/testsuite/gcc.dg/simd-1b.c	2010-06-30
@@ -14,7 +14,7 @@ void
 hanneke ()
 {
   /* Operators on compatible SIMD types.  */
-  a %= b; /* { dg-error "invalid operands to binary %" } */
+  a %= b;
   c &= d;
   a |= b;
   c ^= d;
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.dg/vector-4.c gcc-4.4.4/gcc/testsuite/gcc.dg/vector-4.c
--- a/src/gcc/testsuite/gcc.dg/vector-4.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.dg/vector-4.c	2010-06-30
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+#define vector __attribute__((vector_size(4*sizeof(int)) ))
+
+vector int a, b, c;
+
+
+/* Test that remainder works for vectors. */
+void f(void)
+{
+  a = b % c;
+}
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.dg/vector-init-1.c gcc-4.4.4/gcc/testsuite/gcc.dg/vector-init-1.c
--- a/src/gcc/testsuite/gcc.dg/vector-init-1.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.dg/vector-init-1.c	2010-06-30
@@ -0,0 +1,6 @@
+/* { dg-do compile } */
+
+/* PR C/31499, test that the C front-end treats vectors like an array. */
+
+#define vector __attribute__((__vector_size__(4*sizeof(int)) ))
+vector signed int v1[]={0,1,2,3,4,5,6,7};
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.dg/vector-init-2.c gcc-4.4.4/gcc/testsuite/gcc.dg/vector-init-2.c
--- a/src/gcc/testsuite/gcc.dg/vector-init-2.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.dg/vector-init-2.c	2010-06-30
@@ -0,0 +1,25 @@
+/* { dg-do run } */
+
+/* PR C/31499, test that the C front-end treats vectors like an array
+   and that it works at runtime. */
+
+#define vector __attribute__((__vector_size__(4*sizeof(int)) ))
+vector signed int v1[]={0,1,2,3,4,5,6,7};
+
+
+int main(void)
+{
+  int i;
+  for (i = 0; i < sizeof(v1)/sizeof(v1[0]); i++)
+  {
+    vector int t = v1[i];
+    int *d = (int*)&t;
+    int j;
+    for (j = 0; j < 4; j++)
+      {
+        if (d[j] != i * 4 + j)
+	  __builtin_abort ();
+      }
+  }
+  return 0;
+}
\ No newline at end of file
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/s390/pr42224.c gcc-4.4.4/gcc/testsuite/gcc.target/s390/pr42224.c
--- a/src/gcc/testsuite/gcc.target/s390/pr42224.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/s390/pr42224.c	2010-06-30
@@ -0,0 +1,36 @@
+
+/* { dg-do compile } */
+/* { dg-options "-O0" } */
+
+typedef char* __char_ptr32 __attribute__ (( mode (SI) ));
+typedef __char_ptr32 *__char_ptr_char_ptr32 __attribute__ ((mode (SI)));
+
+void to_ptr32 (int x)
+{
+  __char_ptr32 ptr = (__char_ptr32) x;
+}
+
+void to_int (__char_ptr32 ptr)
+{
+  int x = (int) ptr;
+}
+
+__char_ptr_char_ptr32
+to_ptr32_ptr32 (char **ptr64)
+{
+  int argc;
+  __char_ptr_char_ptr32 short_argv;
+
+  for (argc=0; ptr64[argc]; argc++);
+
+  short_argv = (__char_ptr_char_ptr32) malloc32
+    (sizeof (__char_ptr32) * (argc + 1));
+
+  for (argc=0; ptr64[argc]; argc++)
+    short_argv[argc] = (__char_ptr32) strdup32 (ptr64[argc]);
+
+  short_argv[argc] = (__char_ptr32) 0;
+  return short_argv;
+
+}
+
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/cache1.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/cache1.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/cache1.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/cache1.c	2010-06-30
@@ -0,0 +1,195 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* { dg-do run } */
+/* { dg-require-effective-target "ealib" } */
+
+#include <stdlib.h>
+#include <string.h>
+#include <ea.h>
+#include <spu_cache.h>
+
+#ifdef __EA64__
+#define addr unsigned long long
+#else
+#define addr unsigned long
+#endif
+
+static __ea void *bigblock;
+static __ea void *block;
+static int *ls_block;
+
+extern char __cache_tag_array_size[];
+#define CACHE_SIZE (4 * (int) &__cache_tag_array_size[0])
+#define LINE_SIZE ((addr)128)
+
+void
+init_mem (void)
+{
+  bigblock = malloc_ea (CACHE_SIZE + 2 * LINE_SIZE);
+  block = malloc_ea (2 * LINE_SIZE);
+  ls_block = malloc (LINE_SIZE);
+
+  memset_ea (bigblock, 0, CACHE_SIZE + 2 * LINE_SIZE);
+  memset_ea (block, -1, 2 * LINE_SIZE);
+  memset (ls_block, -1, LINE_SIZE);
+  cache_flush ();
+}
+
+/* Test 1: Simple cache fetching.  */
+void
+test1 (void)
+{
+  addr aligned = ((((addr) block) + LINE_SIZE - 1) & -LINE_SIZE);
+  int *p1 = NULL;
+  int *p2 = NULL;
+  int i = 0;
+
+  /* First, check if the same addr give the same cache ptr.  */
+  p1 = cache_fetch ((__ea void *) aligned);
+  p2 = cache_fetch ((__ea void *) aligned);
+
+  if (p1 != p2)
+    abort ();
+
+  /* Check that the data actually is in the cache. */
+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)
+    {
+      if (p1[i] != -1)
+	abort ();
+    }
+
+  /* Check returning within the cache line. */
+  p2 = cache_fetch ((__ea void *) (aligned + sizeof (int)));
+
+  if (p2 - p1 != 1)
+    abort ();
+
+  /* Finally, check that fetching an LS pointer returns that pointer.  */
+  p1 = cache_fetch ((__ea char *) ls_block);
+  if (p1 != ls_block)
+    abort ();
+}
+
+/* Test 2: Eviction testing. */
+void
+test2 (void)
+{
+  addr aligned = ((((addr) block) + LINE_SIZE - 1) & -LINE_SIZE);
+  int *p = NULL;
+  int i = 0;
+
+  /* First check that clean evictions don't write back.  */
+  p = cache_fetch ((__ea void *) aligned);
+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)
+    p[i] = 0;
+
+  cache_evict ((__ea void *) aligned);
+  memcpy_ea ((__ea char *) ls_block, (__ea void *) aligned, LINE_SIZE);
+
+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)
+    {
+      if (ls_block[i] == 0)
+	abort ();
+    }
+
+  /* Now check that dirty evictions do write back.  */
+  p = cache_fetch_dirty ((__ea void *) aligned, LINE_SIZE);
+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)
+    p[i] = 0;
+
+  cache_evict ((__ea void *) aligned);
+  memcpy_ea ((__ea char *) ls_block, (__ea void *) aligned, LINE_SIZE);
+
+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)
+    {
+      if (ls_block[i] != 0)
+	abort ();
+    }
+
+  /* Finally, check that non-atomic writeback only writes dirty bytes.  */
+
+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)
+    {
+      p = cache_fetch_dirty ((__ea void *) (aligned + i * sizeof (int)),
+			     (i % 2) * sizeof (int));
+      p[0] = -1;
+    }
+
+  cache_evict ((__ea void *) aligned);
+  memcpy_ea ((__ea char *) ls_block, (__ea void *) aligned, LINE_SIZE);
+
+  for (i = 0; i < LINE_SIZE / sizeof (int); i++)
+    {
+      if ((ls_block[i] == -1) && (i % 2 == 0))
+	abort ();
+      if ((ls_block[i] == 0) && (i % 2 == 1))
+	abort ();
+    }
+}
+
+/* Test LS forced-eviction. */
+void
+test3 (void)
+{
+  addr aligned = ((((addr) bigblock) + LINE_SIZE - 1) & -LINE_SIZE);
+  char *test = NULL;
+  char *ls = NULL;
+  int i = 0;
+
+  /* Init memory, fill the cache to capacity.  */
+  ls = cache_fetch_dirty ((__ea void *) aligned, LINE_SIZE);
+  for (i = 1; i < (CACHE_SIZE / LINE_SIZE); i++)
+    cache_fetch_dirty ((__ea void *) (aligned + i * LINE_SIZE), LINE_SIZE);
+
+  memset (ls, -1, LINE_SIZE);
+  test = cache_fetch ((__ea void *) (aligned + CACHE_SIZE));
+
+  /* test == ls indicates cache collision.  */
+  if (test != ls)
+    abort ();
+
+  /* Make sure it actually wrote the cache line.  */
+  for (i = 0; i < LINE_SIZE; i++)
+    {
+      if (ls[i] != 0)
+	abort ();
+    }
+
+  ls = cache_fetch ((__ea void *) aligned);
+
+  /* test != ls indicates another entry was evicted.  */
+  if (test == ls)
+    abort ();
+
+  /* Make sure that the previous eviction actually wrote back.  */
+  for (i = 0; i < LINE_SIZE; i++)
+    {
+      if (ls[i] != 0xFF)
+	abort ();
+    }
+}
+
+int
+main (int argc, char **argv)
+{
+  init_mem ();
+  test1 ();
+  test2 ();
+  test3 ();
+
+  return 0;
+}
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/cast1.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/cast1.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/cast1.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/cast1.c	2010-06-30
@@ -0,0 +1,43 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* { dg-do run } */
+
+extern void abort (void);
+extern unsigned long long __ea_local_store;
+
+__ea int *ppu;
+int x, *spu = &x, *spu2;
+
+int
+main (int argc, char **argv)
+{
+  ppu = (__ea int *) spu;
+  spu2 = (int *) ppu;
+
+#ifdef __EA32__
+  if ((int) ppu != (int) __ea_local_store + (int) spu)
+#else
+  if ((unsigned long long) ppu != __ea_local_store + (unsigned long long)(int) spu)
+#endif
+
+    abort ();
+
+  if (spu != spu2)
+    abort ();
+
+  return 0;
+}
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/cast2.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/cast2.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/cast2.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/cast2.c	2010-06-30
@@ -0,0 +1,74 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* { dg-do run } */
+
+extern void abort (void);
+
+int array[128];
+
+__ea int *ea;
+int *lm;
+
+void verify_ea (void) __attribute__ ((noinline));
+void
+verify_ea (void)
+{
+  if (ea != (__ea int *)lm)
+    abort ();
+}
+
+void verify_lm (void) __attribute__ ((noinline));
+void
+verify_lm (void)
+{
+  if ((int *)ea != lm)
+    abort ();
+}
+
+void verify_diff (int x) __attribute__ ((noinline));
+void
+verify_diff (int x)
+{
+  if (ea - lm != x)
+    abort ();
+}
+
+int
+main (int argc, char **argv)
+{
+  ea = 0;
+  lm = 0;
+  verify_ea ();
+  verify_lm ();
+  verify_diff (0);
+
+  ea = &array[64];
+  lm = &array[64];
+  verify_ea ();
+  verify_lm ();
+  verify_diff (0);
+
+  ea = &array[0];
+  lm = &array[64];
+  verify_diff (-64);
+
+  ea = &array[64];
+  lm = &array[0];
+  verify_diff (64);
+
+  return 0;
+}
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/compile1.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/compile1.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/compile1.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/compile1.c	2010-06-30
@@ -0,0 +1,109 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Valid __ea declarations.  */
+
+/* { dg-do compile } */
+
+/* Typedefs.  */
+typedef __ea int ea_int_t;
+typedef __ea int *ea_int_star_t;
+typedef int outer_t;
+
+/* Externs.  */
+
+__ea extern int i1;
+extern __ea int i2;
+extern int __ea i3;
+extern __ea ea_int_t i4;		/* __ea qualifier permitted via typedef.  */
+extern int __ea __ea __ea dupe;		/* __ea duplicate permitted directly.  */
+extern int __ea *ppu;
+
+/* Pointers.  */
+__ea int *i4p;
+
+/* Structs.  */
+struct st {
+  __ea int *p;
+};
+
+/* Variable definitions.  */
+__ea int ii0;
+int *__ea ii1;
+static int __ea ii2;
+
+void
+f1 ()
+{
+  int *spu;
+  ppu = (ea_int_t *) spu;
+  ppu = (ea_int_star_t) spu;
+}
+
+void
+f2 ()
+{
+  int *spu;
+  spu = (int *) ppu;
+  ppu = (__ea int *) spu;
+}
+
+void
+f3 ()
+{
+  int i = sizeof (__ea int);
+}
+
+__ea int *f4 (void)
+{
+  return 0;
+}
+
+int f5 (__ea int *parm)
+{
+  static __ea int local4;
+  int tmp = local4;
+  local4 = *parm;
+  return tmp;
+}
+
+static inline __ea void *f6 (__ea void *start)
+{
+  return 0;
+}
+
+void f7 (void)
+{
+  __ea void *s1;
+  auto __ea void *s2;
+}
+
+__ea int *f8 (__ea int *x)
+{
+  register __ea int *y = x;
+  __ea int *z = y;
+  return z;
+}
+
+long long f9 (__ea long long x[2])
+{
+  return x[0] + x[1];
+}
+
+void f10 ()
+{
+  static __ea outer_t o;
+}
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/compile2.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/compile2.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/compile2.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/compile2.c	2010-06-30
@@ -0,0 +1,43 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Make sure __ea structure references work.  */
+
+/* { dg-do compile } */
+
+typedef unsigned long int uintptr_t;
+
+struct tostruct
+{
+  uintptr_t selfpc;
+  long count;
+  unsigned short link;
+};
+
+/* froms are indexing tos */
+static __ea unsigned short *froms;
+static __ea struct tostruct *tos = 0;
+
+void
+foo (uintptr_t frompc, uintptr_t selfpc)
+{
+  __ea unsigned short *frompcindex;
+
+  frompcindex = &froms[(frompc) / (4 * sizeof (*froms))];
+  *frompcindex = tos[0].link;
+
+  return;
+}
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/cppdefine.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/cppdefine.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/cppdefine.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/cppdefine.c	2010-06-30
@@ -0,0 +1,36 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Test default __EA32__/__EA64__ define.  */
+
+/* { dg-do compile } */
+
+#if !defined (__EA32__) && !defined (__EA64__)
+#error both __EA32__ and __EA64__ undefined
+#endif
+
+#if defined (__EA32__) && defined (__EA64__)
+#error both __EA32__ and __EA64__ defined
+#endif
+
+#ifdef __EA32__
+int x [ sizeof (__ea char *) == 4 ? 1 : -1 ];
+#endif
+
+#ifdef __EA64__
+int x [ sizeof (__ea char *) == 8 ? 1 : -1 ];
+#endif
+
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/ea.exp gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/ea.exp
--- a/src/gcc/testsuite/gcc.target/spu/ea/ea.exp	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/ea.exp	2010-06-30
@@ -0,0 +1,54 @@
+#   Copyright (C) 2008, 2009 Free Software Foundation, Inc.
+
+# This program is free software; you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with GCC; see the file COPYING3.  If not see
+# <http://www.gnu.org/licenses/>.
+
+# GCC testsuite that uses the `dg.exp' driver.
+
+# Exit immediately if this isn't a SPU target.
+if { ![istarget spu-*-*] } then {
+  return
+}
+
+# Load support procs.
+load_lib gcc-dg.exp
+
+# Return 1 if target __ea library functions are available
+proc check_effective_target_ealib { } {
+    return [check_no_compiler_messages ealib executable {
+	#include <ea.h>
+	int main (void)
+	{
+	    __ea void *ptr = malloc_ea (1024);
+	    return 0;
+	}
+    }]
+}
+
+# If a testcase doesn't have special options, use these.
+# We do not use the global DEFAULT_CFLAGS as all test cases
+# in this directory use the __ea address space qualifier
+# extension and thus will not compile with -ansi.
+set DEFAULT_EA_CFLAGS "-std=gnu99 -pedantic-errors -O2"
+
+# Initialize `dg'.
+dg-init
+
+# Run all tests in both -mea32 and -mea64 mode.
+set tests [lsort [glob -nocomplain $srcdir/$subdir/*.\[cS\]]]
+dg-runtest $tests "-mea32" $DEFAULT_EA_CFLAGS
+dg-runtest $tests "-mea64" $DEFAULT_EA_CFLAGS
+
+# All done.
+dg-finish
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/errors1.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/errors1.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/errors1.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/errors1.c	2010-06-30
@@ -0,0 +1,67 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Invalid __ea declarations.  */
+
+/* { dg-do compile } */
+
+typedef __ea int eaint;
+
+void func ()
+{
+  register __ea int local1; /* { dg-error "'__ea' combined with 'register' qualifier for 'local1'" } */
+  auto __ea int local2;     /* { dg-error "'__ea' combined with 'auto' qualifier for 'local2'" } */
+  __ea int local3;	    /* { dg-error "'__ea' specified for auto variable 'local3'" } */
+  register int *__ea p1;    /* { dg-error "'__ea' combined with 'register' qualifier for 'p1'" } */
+  auto char *__ea p2;       /* { dg-error "'__ea' combined with 'auto' qualifier for 'p2'" } */
+  void *__ea p3;            /* { dg-error "'__ea' specified for auto variable 'p3'" } */
+  register __ea int a1[2];  /* { dg-error "'__ea' combined with 'register' qualifier for 'a1'" } */
+  auto __ea char a2[1];     /* { dg-error "'__ea' combined with 'auto' qualifier for 'a2'" } */
+  __ea char a3[5];          /* { dg-error "'__ea' specified for auto variable 'a3'" } */
+  register eaint td1;       /* { dg-error "'__ea' combined with 'register' qualifier for 'td1'" } */
+  auto eaint td2;           /* { dg-error "'__ea' combined with 'auto' qualifier for 'td2'" } */
+  eaint td3;	            /* { dg-error "'__ea' specified for auto variable 'td3'" } */
+}
+
+void func2 (__ea int x)	    /* { dg-error "'__ea' specified for parameter 'x'" } */
+{ }
+
+void func2td (eaint x)	    /* { dg-error "'__ea' specified for parameter 'x'" } */
+{ }
+
+struct st {
+  __ea int x;		    /* { dg-error "'__ea' specified for structure field 'x'" } */
+  eaint td;		    /* { dg-error "'__ea' specified for structure field 'td'" } */
+  int *__ea q;		    /* { dg-error "'__ea' specified for structure field 'q'" } */
+  int __ea b : 7;	    /* { dg-error "'__ea' specified for structure field 'b'" } */
+  int __ea : 1;		    /* { dg-error "'__ea' specified for structure field" } */
+} s;
+
+struct A { int a; };
+
+int func3 (int *__ea);	    /* { dg-error "'__ea' specified for unnamed parameter" } */
+int func3 (int *__ea x)	    /* { dg-error "'__ea' specified for parameter 'x'" } */
+{
+  struct A i = (__ea struct A) { 1 };	/* { dg-error "compound literal qualified by address-space qualifier" } */
+  return i.a;
+}
+
+extern __ea int ea_var;		/* { dg-message "note: previous declaration of 'ea_var' was here" } */
+int ea_var;			/* { dg-error "conflicting named address spaces \\(generic vs __ea\\) for 'ea_var'" } */
+
+extern eaint ea_var_td;		/* { dg-message "note: previous declaration of 'ea_var_td' was here" } */
+int ea_var_td;			/* { dg-error "conflicting named address spaces \\(generic vs __ea\\) for 'ea_var_td'" } */
+
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/errors2.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/errors2.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/errors2.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/errors2.c	2010-06-30
@@ -0,0 +1,107 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Invalid __ea declarations.  */
+
+/* { dg-do compile } */
+
+__ea char ea_str[] = "abc";
+char lm_str[] = "abc";
+
+__ea char *lm_ea_ptr1 = "abc";				/* { dg-error "initializer element is not computable at load time" } */
+__ea char *lm_ea_ptr2 = (__ea char *)"abc";		/* { dg-error "initializer element is not constant" } */
+__ea char *lm_ea_ptr3 = ea_str;
+__ea char *lm_ea_ptr4 = (__ea char *)ea_str;
+__ea char *lm_ea_ptr5 = lm_str;				/* { dg-error "initializer element is not computable at load time" } */
+__ea char *lm_ea_ptr6 = (__ea char *)lm_str;		/* { dg-error "initializer element is not constant" } */
+
+__ea char * __ea ea_ea_ptr1 = ea_str;
+__ea char * __ea ea_ea_ptr2 = (__ea char *)ea_str;
+
+char * __ea ea_lm_ptr1 = lm_str;
+char * __ea ea_lm_ptr2 = (char *)lm_str;
+
+struct foo {
+  int first;
+  __ea char *ptr;
+  int last;
+};
+
+__ea struct foo ea_struct1 = {
+  10,
+  (__ea char *)0,
+  11,
+};
+
+__ea struct foo ea_struct2 = {
+  20,
+  0,
+  21,
+};
+
+struct foo ea_struct3 = {
+  30,
+  ea_str,
+  31,
+};
+
+struct foo ea_struct4 = {
+  40,
+  (__ea char *)lm_str,	/* { dg-error "(initializer element is not constant)|(near initialization)" "" } */
+  41,
+};
+
+struct bar {
+  int first;
+  char *ptr;
+  int last;
+};
+
+__ea struct bar ea_struct5 = {
+  50,
+  0,
+  51,
+};
+
+__ea struct bar ea_struct6 = {
+  60,
+  (char *)0,
+  61,
+};
+
+__ea struct bar ea_struct7 = {
+  70,
+  lm_str,
+  71,
+};
+
+struct bar lm_struct8 = {
+  80,
+  0,
+  81,
+};
+
+struct bar lm_struct9 = {
+  90,
+  (char *)0,
+  91,
+};
+
+struct bar lm_struct10 = {
+  100,
+  lm_str,
+  101,
+};
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/execute1.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/execute1.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/execute1.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/execute1.c	2010-06-30
@@ -0,0 +1,41 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* { dg-do compile } */
+
+#include <stdlib.h>
+
+__ea char str[] = "abc";
+
+int
+main (void)
+{
+  __ea char *p = str;
+
+  if (*p++ != 'a')
+    abort ();
+
+  if (*p++ != 'b')
+    abort ();
+
+  if (*p++ != 'c')
+    abort ();
+
+  if (*p++ != '\0')
+    abort ();
+
+  return 0;
+}
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/execute2.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/execute2.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/execute2.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/execute2.c	2010-06-30
@@ -0,0 +1,41 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* { dg-do run } */
+
+#include <stdlib.h>
+
+char str[] = "abc";
+
+int
+main (void)
+{
+  __ea char *p = (__ea char *)str;
+
+  if (*p++ != 'a')
+    abort ();
+
+  if (*p++ != 'b')
+    abort ();
+
+  if (*p++ != 'c')
+    abort ();
+
+  if (*p++ != '\0')
+    abort ();
+
+  return 0;
+}
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/execute3.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/execute3.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/execute3.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/execute3.c	2010-06-30
@@ -0,0 +1,39 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* { dg-do run } */
+
+#include <stdlib.h>
+
+int
+main (void)
+{
+  __ea char *p = (__ea char *)"abc";
+
+  if (*p++ != 'a')
+    abort ();
+
+  if (*p++ != 'b')
+    abort ();
+
+  if (*p++ != 'c')
+    abort ();
+
+  if (*p++ != '\0')
+    abort ();
+
+  return 0;
+}
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/ops1.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/ops1.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/ops1.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/ops1.c	2010-06-30
@@ -0,0 +1,94 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This is the same as ops2.c except for the compile option.
+   If you modify this code, please modify ops2.c as well.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -std=gnu99 -pedantic-errors -maddress-space-conversion" } */
+
+#define __lm
+
+__ea int ea_var = 1;
+__lm int lm_var = 2;
+
+typedef __ea int *ea_ptr_t;
+typedef __lm int *lm_ptr_t;
+
+typedef __ea void *ea_vptr_t;
+typedef __lm void *lm_vptr_t;
+
+ea_ptr_t ea, ea2;
+lm_ptr_t lm, lm2;
+
+ea_vptr_t eav;
+lm_vptr_t lmv;
+
+extern void call_ea (ea_ptr_t);
+extern void call_lm (lm_ptr_t);
+
+/* Assignment, initialization, argument passing, and return.  */
+void to_ea (void) { ea = lm; }
+void to_lm (void) { lm = ea; }			/* { dg-error "assignment from pointer to non-enclosed address space" } */
+void init_ea (void) { ea_ptr_t l_ea = lm; }
+void init_lm (void) { lm_ptr_t l_lm = ea; }	/* { dg-error "initialization from pointer to non-enclosed address space" } */
+ea_ptr_t ret_ea (void) { return lm; }
+lm_ptr_t ret_lm (void) { return ea; }		/* { dg-error "return from pointer to non-enclosed address space" } */
+void call_ea2 (void) { call_ea (lm); }
+void call_lm2 (void) { call_lm (ea); }		/* { dg-error "passing argument 1 of 'call_lm' from pointer to non-enclosed address space" } */
+
+/* Explicit casts.  */
+void to_ea_with_cast (void) { ea = (ea_ptr_t)lm; }
+void to_lm_with_cast (void) { lm = (lm_ptr_t)ea; }
+void init_ea_with_cast (void) { ea_ptr_t l_ea = (ea_ptr_t)lm; }
+void init_lm_with_cast (void) { lm_ptr_t l_lm = (lm_ptr_t)ea; }
+ea_ptr_t ret_ea_with_cast (void) { return (ea_ptr_t)lm; }
+lm_ptr_t ret_lm_with_cast (void) { return (lm_ptr_t)ea; }
+void call_ea2_with_cast (void) { call_ea ((ea_ptr_t)lm); }
+void call_lm2_with_cast (void) { call_lm ((lm_ptr_t)ea); }
+
+/* Arithmetic operators.  */
+int sub_eaea (void) { return ea - ea2; }
+int sub_ealm (void) { return ea - lm2; }
+int sub_lmea (void) { return lm - ea2; }
+int sub_lmlm (void) { return lm - lm2; }
+ea_ptr_t if_eaea1 (int test) { return test? ea : ea2; }
+lm_ptr_t if_eaea2 (int test) { return test? ea : ea2; }	/* { dg-error "return from pointer to non-enclosed address space" } */
+ea_ptr_t if_ealm1 (int test) { return test? ea : lm2; }
+lm_ptr_t if_ealm2 (int test) { return test? ea : lm2; }	/* { dg-error "return from pointer to non-enclosed address space" } */
+ea_ptr_t if_lmea1 (int test) { return test? lm : ea2; }
+lm_ptr_t if_lmea2 (int test) { return test? lm : ea2; }	/* { dg-error "return from pointer to non-enclosed address space" } */
+ea_ptr_t if_lmlm1 (int test) { return test? lm : lm2; }
+lm_ptr_t if_lmlm2 (int test) { return test? lm : lm2; }
+
+/* Relational operators.  */
+int eq_eaea (void) { return ea == ea2; }
+int eq_ealm (void) { return ea == lm2; }
+int eq_lmea (void) { return lm == ea2; }
+int eq_lmlm (void) { return lm == lm2; }
+int lt_eaea (void) { return ea < ea2; }
+int lt_ealm (void) { return ea < lm2; }
+int lt_lmea (void) { return lm < ea2; }
+int lt_lmlm (void) { return lm < lm2; }
+
+/* Null pointer.  */
+void null_ea1 (void) { ea = 0; }
+void null_ea2 (void) { ea = (void *)0; }
+void null_ea3 (void) { ea = (__ea void *)0; }
+void null_lm1 (void) { lm = 0; }
+void null_lm2 (void) { lm = (void *)0; }
+void null_lm3 (void) { lm = (__ea void *)0; }	/* { dg-error "assignment from pointer to non-enclosed address space" } */
+
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/ops2.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/ops2.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/ops2.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/ops2.c	2010-06-30
@@ -0,0 +1,94 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This is the same as ops1.c except for the compile option.
+   If you modify this code, please modify ops1.c as well.  */
+
+/* { dg-do compile } */
+/* { dg-options "-O2 -std=gnu99 -pedantic-errors -mno-address-space-conversion" } */
+
+#define __lm
+
+__ea int ea_var = 1;
+__lm int lm_var = 2;
+
+typedef __ea int *ea_ptr_t;
+typedef __lm int *lm_ptr_t;
+
+typedef __ea void *ea_vptr_t;
+typedef __lm void *lm_vptr_t;
+
+ea_ptr_t ea, ea2;
+lm_ptr_t lm, lm2;
+
+ea_vptr_t eav;
+lm_vptr_t lmv;
+
+extern void call_ea (ea_ptr_t);
+extern void call_lm (lm_ptr_t);
+
+/* Assignment, initialization, argument passing, and return.  */
+void to_ea (void) { ea = lm; }			/* { dg-error "assignment from pointer to non-enclosed address space" } */
+void to_lm (void) { lm = ea; }			/* { dg-error "assignment from pointer to non-enclosed address space" } */
+void init_ea (void) { ea_ptr_t l_ea = lm; }	/* { dg-error "initialization from pointer to non-enclosed address space" } */
+void init_lm (void) { lm_ptr_t l_lm = ea; }	/* { dg-error "initialization from pointer to non-enclosed address space" } */
+ea_ptr_t ret_ea (void) { return lm; }		/* { dg-error "return from pointer to non-enclosed address space" } */
+lm_ptr_t ret_lm (void) { return ea; }		/* { dg-error "return from pointer to non-enclosed address space" } */
+void call_ea2 (void) { call_ea (lm); }		/* { dg-error "passing argument 1 of 'call_ea' from pointer to non-enclosed address space" } */
+void call_lm2 (void) { call_lm (ea); }		/* { dg-error "passing argument 1 of 'call_lm' from pointer to non-enclosed address space" } */
+
+/* Explicit casts.  */
+void to_ea_with_cast (void) { ea = (ea_ptr_t)lm; }		/* { dg-warning "cast to __ea address space pointer" } */
+void to_lm_with_cast (void) { lm = (lm_ptr_t)ea; }		/* { dg-warning "cast to generic address space pointer" } */
+void init_ea_with_cast (void) { ea_ptr_t l_ea = (ea_ptr_t)lm; }	/* { dg-warning "cast to __ea address space pointer" } */
+void init_lm_with_cast (void) { lm_ptr_t l_lm = (lm_ptr_t)ea; }	/* { dg-warning "cast to generic address space pointer" } */
+ea_ptr_t ret_ea_with_cast (void) { return (ea_ptr_t)lm; }	/* { dg-warning "cast to __ea address space pointer" } */
+lm_ptr_t ret_lm_with_cast (void) { return (lm_ptr_t)ea; }	/* { dg-warning "cast to generic address space pointer" } */
+void call_ea2_with_cast (void) { call_ea ((ea_ptr_t)lm); }	/* { dg-warning "cast to __ea address space pointer" } */
+void call_lm2_with_cast (void) { call_lm ((lm_ptr_t)ea); }	/* { dg-warning "cast to generic address space pointer" } */
+
+/* Arithmetic operators.  */
+int sub_eaea (void) { return ea - ea2; }
+int sub_ealm (void) { return ea - lm2; }		/* { dg-error "invalid operands to binary -" } */
+int sub_lmea (void) { return lm - ea2; }		/* { dg-error "invalid operands to binary -" } */
+int sub_lmlm (void) { return lm - lm2; }
+ea_ptr_t if_eaea1 (int test) { return test? ea : ea2; }
+lm_ptr_t if_eaea2 (int test) { return test? ea : ea2; }	/* { dg-error "return from pointer to non-enclosed address space" } */
+ea_ptr_t if_ealm1 (int test) { return test? ea : lm2; } /* { dg-error "pointers to disjoint address spaces used in conditional expression" } */
+lm_ptr_t if_ealm2 (int test) { return test? ea : lm2; } /* { dg-error "pointers to disjoint address spaces used in conditional expression" } */
+ea_ptr_t if_lmea1 (int test) { return test? lm : ea2; } /* { dg-error "pointers to disjoint address spaces used in conditional expression" } */
+lm_ptr_t if_lmea2 (int test) { return test? lm : ea2; } /* { dg-error "pointers to disjoint address spaces used in conditional expression" } */
+ea_ptr_t if_lmlm1 (int test) { return test? lm : lm2; }	/* { dg-error "return from pointer to non-enclosed address space" } */
+lm_ptr_t if_lmlm2 (int test) { return test? lm : lm2; }
+
+/* Relational operators.  */
+int eq_eaea (void) { return ea == ea2; }
+int eq_ealm (void) { return ea == lm2; }	/* { dg-error "comparison of pointers to disjoint address spaces" } */
+int eq_lmea (void) { return lm == ea2; }	/* { dg-error "comparison of pointers to disjoint address spaces" } */
+int eq_lmlm (void) { return lm == lm2; }
+int lt_eaea (void) { return ea < ea2; }
+int lt_ealm (void) { return ea < lm2; }		/* { dg-error "comparison of pointers to disjoint address spaces" } */
+int lt_lmea (void) { return lm < ea2; }		/* { dg-error "comparison of pointers to disjoint address spaces" } */
+int lt_lmlm (void) { return lm < lm2; }
+
+/* Null pointer.  */
+void null_ea1 (void) { ea = 0; }
+void null_ea2 (void) { ea = (void *)0; }
+void null_ea3 (void) { ea = (__ea void *)0; }
+void null_lm1 (void) { lm = 0; }
+void null_lm2 (void) { lm = (void *)0; }
+void null_lm3 (void) { lm = (__ea void *)0; }	/* { dg-error "assignment from pointer to non-enclosed address space" } */
+
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/options1.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/options1.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/options1.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/options1.c	2010-06-30
@@ -0,0 +1,22 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Test -mcache-size.  */
+
+/* { dg-do compile } */
+/* { dg-options "-mcache-size=128" } */
+
+int x;
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/pr41857.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/pr41857.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/pr41857.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/pr41857.c	2010-06-30
@@ -0,0 +1,29 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* { dg-do compile } */
+
+__ea char *strchr_ea (__ea const char *s, int c);
+__ea char *foo (__ea char *s)
+{
+  __ea char *ret = s;
+  int i;
+
+  for (i = 0; i < 3; i++)
+    ret = strchr_ea (ret, s[i]);
+
+  return ret;
+}
diff -urNp gcc-4.4.4.orig/gcc/testsuite/gcc.target/spu/ea/test-sizes.c gcc-4.4.4/gcc/testsuite/gcc.target/spu/ea/test-sizes.c
--- a/src/gcc/testsuite/gcc.target/spu/ea/test-sizes.c	1970-01-01
+++ b/src/gcc/testsuite/gcc.target/spu/ea/test-sizes.c	2010-06-30
@@ -0,0 +1,608 @@
+/* Copyright (C) 2009 Free Software Foundation, Inc.
+
+   This file is free software; you can redistribute it and/or modify it under
+   the terms of the GNU General Public License as published by the Free
+   Software Foundation; either version 3 of the License, or (at your option)
+   any later version.
+
+   This file is distributed in the hope that it will be useful, but WITHOUT
+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+   for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this file; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+/* { dg-do run } */
+
+#ifdef __EA32__
+#define EA_PTRSIZE 4
+#endif
+#ifdef __EA64__
+#define EA_PTRSIZE 8
+#endif
+
+#if !defined(LEVEL1) && !defined(LEVEL2) && !defined(LEVEL3)
+#define LEVEL1 1		/* single pointer indirection */
+#define LEVEL2 1		/* 2 levels of pointer indirection */
+#define LEVEL3 1		/* 3 levels of pointer indirection */
+
+#else
+#ifndef LEVEL1
+#define LEVEL1 0
+#endif
+
+#ifndef LEVEL2
+#define LEVEL2 0
+#endif
+
+#ifndef LEVEL3
+#define LEVEL3 0
+#endif
+#endif
+
+#if !defined(USE_SIMPLE) && !defined(USE_COMPLEX)
+#define USE_SIMPLE  1		/* build up pointers via multiple typedefs */
+#define USE_COMPLEX 1		/* single typedef for pointer indirections */
+
+#else
+#ifndef USE_SIMPLE
+#define USE_SIMPLE 0
+#endif
+
+#ifndef USE_COMPLEX
+#define USE_COMPLEX 0
+#endif
+#endif
+
+#if !defined(USE_LOCAL_VAR) && !defined(USE_EA_VAR)
+#define USE_LOCAL_VAR 1		/* use variables declared locally */
+#define USE_EA_VAR    1		/* use variables on the host */
+
+#else
+#ifndef USE_LOCAL_VAR
+#define USE_LOCAL_VAR 0
+#endif
+
+#ifndef USE_EA_VAR
+#define USE_EA_VAR    0
+#endif
+#endif
+
+static int errors;
+
+#ifdef USE_PRINTF		/* print results via printf */
+#include <stdio.h>
+#include <stdlib.h>
+
+static int num_tests;
+
+#define TEST_SIZE(EXPR, EXPECTED)					\
+do {									\
+  char *msg;								\
+									\
+  if (sizeof (EXPR) != EXPECTED)					\
+    {									\
+      msg = ", FAIL";							\
+      errors++;								\
+    }									\
+  else									\
+    msg = "";								\
+									\
+  num_tests++;								\
+  printf ("sizeof %-20s = %2u, expected = %2u%s\n",			\
+	  #EXPR,							\
+	  (unsigned) sizeof (EXPR),					\
+	  (unsigned) EXPECTED,						\
+	  msg);								\
+} while (0)
+
+#define PRINT1(FMT)	  printf (FMT)
+#define PRINT2(FMT,A1)	  printf (FMT,A1)
+#define PRINT3(FMT,A1,A2) printf (FMT,A1,A2)
+
+#else	/* standalone */
+extern void abort (void);
+
+#define TEST_SIZE(EXPR, EXPECTED)					\
+do {									\
+  if (sizeof (EXPR) != EXPECTED)					\
+    abort ();								\
+} while (0)
+
+#define PRINT1(FMT)
+#define PRINT2(FMT,ARG)
+#define PRINT3(FMT,A1,A2)
+#endif
+
+/* 'local memory' hack to keep the same spacing.  */
+#define __lm
+
+#if USE_SIMPLE
+#if (LEVEL1 || LEVEL2 || LEVEL3)
+typedef __lm char *lm_ptr_t;
+typedef __ea char *ea_ptr_t;
+#endif
+
+#if LEVEL1
+#if USE_LOCAL_VAR
+__lm lm_ptr_t lm_ptr;
+__lm ea_ptr_t ea_ptr;
+#endif
+
+#if USE_EA_VAR
+__ea lm_ptr_t lm_ptr_ea;
+__ea ea_ptr_t ea_ptr_ea;
+#endif
+#endif
+
+#if (LEVEL2 || LEVEL3)
+typedef __lm lm_ptr_t *lm_lm_ptr_t;
+typedef __ea lm_ptr_t *ea_lm_ptr_t;
+typedef __lm ea_ptr_t *lm_ea_ptr_t;
+typedef __ea ea_ptr_t *ea_ea_ptr_t;
+#endif
+
+#if LEVEL2
+#if USE_LOCAL_VAR
+__lm lm_lm_ptr_t lm_lm_ptr;
+__lm ea_lm_ptr_t ea_lm_ptr;
+__lm lm_ea_ptr_t lm_ea_ptr;
+__lm ea_ea_ptr_t ea_ea_ptr;
+#endif
+
+#if USE_EA_VAR
+__ea lm_lm_ptr_t lm_lm_ptr_ea;
+__ea ea_lm_ptr_t ea_lm_ptr_ea;
+__ea lm_ea_ptr_t lm_ea_ptr_ea;
+__ea ea_ea_ptr_t ea_ea_ptr_ea;
+#endif
+#endif
+
+#if LEVEL3
+typedef __lm lm_lm_ptr_t *lm_lm_lm_ptr_t;
+typedef __ea lm_lm_ptr_t *ea_lm_lm_ptr_t;
+typedef __lm ea_lm_ptr_t *lm_ea_lm_ptr_t;
+typedef __ea ea_lm_ptr_t *ea_ea_lm_ptr_t;
+typedef __lm lm_ea_ptr_t *lm_lm_ea_ptr_t;
+typedef __ea lm_ea_ptr_t *ea_lm_ea_ptr_t;
+typedef __lm ea_ea_ptr_t *lm_ea_ea_ptr_t;
+typedef __ea ea_ea_ptr_t *ea_ea_ea_ptr_t;
+
+#if USE_LOCAL_VAR
+__lm lm_lm_lm_ptr_t lm_lm_lm_ptr;
+__lm ea_lm_lm_ptr_t ea_lm_lm_ptr;
+__lm lm_ea_lm_ptr_t lm_ea_lm_ptr;
+__lm ea_ea_lm_ptr_t ea_ea_lm_ptr;
+__lm lm_lm_ea_ptr_t lm_lm_ea_ptr;
+__lm ea_lm_ea_ptr_t ea_lm_ea_ptr;
+__lm lm_ea_ea_ptr_t lm_ea_ea_ptr;
+__lm ea_ea_ea_ptr_t ea_ea_ea_ptr;
+#endif
+
+#if USE_EA_VAR
+__ea lm_lm_lm_ptr_t lm_lm_lm_ptr_ea;
+__ea ea_lm_lm_ptr_t ea_lm_lm_ptr_ea;
+__ea lm_ea_lm_ptr_t lm_ea_lm_ptr_ea;
+__ea ea_ea_lm_ptr_t ea_ea_lm_ptr_ea;
+__ea lm_lm_ea_ptr_t lm_lm_ea_ptr_ea;
+__ea ea_lm_ea_ptr_t ea_lm_ea_ptr_ea;
+__ea lm_ea_ea_ptr_t lm_ea_ea_ptr_ea;
+__ea ea_ea_ea_ptr_t ea_ea_ea_ptr_ea;
+#endif
+#endif
+#endif
+
+#if USE_COMPLEX
+#if LEVEL1
+#if USE_LOCAL_VAR
+__lm char *__lm lm_cptr;
+__ea char *__lm ea_cptr;
+#endif
+
+#if USE_EA_VAR
+__lm char *__ea lm_cptr_ea;
+__ea char *__ea ea_cptr_ea;
+#endif
+#endif
+
+#if LEVEL2
+#if USE_LOCAL_VAR
+__lm char *__lm *__lm lm_lm_cptr;
+__lm char *__ea *__lm ea_lm_cptr;
+__ea char *__lm *__lm lm_ea_cptr;
+__ea char *__ea *__lm ea_ea_cptr;
+#endif
+
+#if USE_EA_VAR
+__lm char *__lm *__ea lm_lm_cptr_ea;
+__lm char *__ea *__ea ea_lm_cptr_ea;
+__ea char *__lm *__ea lm_ea_cptr_ea;
+__ea char *__ea *__ea ea_ea_cptr_ea;
+#endif
+#endif
+
+#if LEVEL3
+#if USE_LOCAL_VAR
+__lm char *__lm *__lm *__lm lm_lm_lm_cptr;
+__lm char *__ea *__lm *__lm lm_ea_lm_cptr;
+__ea char *__lm *__lm *__lm lm_lm_ea_cptr;
+__ea char *__ea *__lm *__lm lm_ea_ea_cptr;
+__lm char *__lm *__ea *__lm ea_lm_lm_cptr;
+__lm char *__ea *__ea *__lm ea_ea_lm_cptr;
+__ea char *__lm *__ea *__lm ea_lm_ea_cptr;
+__ea char *__ea *__ea *__lm ea_ea_ea_cptr;
+#endif
+
+#if USE_EA_VAR
+__lm char *__lm *__lm *__ea lm_lm_lm_cptr_ea;
+__lm char *__ea *__lm *__ea lm_ea_lm_cptr_ea;
+__ea char *__lm *__lm *__ea lm_lm_ea_cptr_ea;
+__ea char *__ea *__lm *__ea lm_ea_ea_cptr_ea;
+__lm char *__lm *__ea *__ea ea_lm_lm_cptr_ea;
+__lm char *__ea *__ea *__ea ea_ea_lm_cptr_ea;
+__ea char *__lm *__ea *__ea ea_lm_ea_cptr_ea;
+__ea char *__ea *__ea *__ea ea_ea_ea_cptr_ea;
+#endif
+#endif
+#endif
+
+int
+main ()
+{
+  PRINT2 ("LEVEL1        = %d\n", LEVEL1);
+  PRINT2 ("LEVEL2        = %d\n", LEVEL2);
+  PRINT2 ("LEVEL3        = %d\n", LEVEL3);
+  PRINT2 ("USE_SIMPLE    = %d\n", USE_SIMPLE);
+  PRINT2 ("USE_COMPLEX   = %d\n", USE_COMPLEX);
+  PRINT2 ("USE_LOCAL_VAR = %d\n", USE_LOCAL_VAR);
+  PRINT2 ("USE_EA_VAR    = %d\n", USE_EA_VAR);
+  PRINT1 ("\n");
+
+#if USE_SIMPLE
+#if LEVEL1
+#if USE_LOCAL_VAR
+  TEST_SIZE ( lm_ptr, 4);
+  TEST_SIZE (*lm_ptr, 1);
+  TEST_SIZE ( ea_ptr, EA_PTRSIZE);
+  TEST_SIZE (*ea_ptr, 1);
+  PRINT1 ("\n");
+#endif
+
+#if USE_EA_VAR
+  TEST_SIZE ( lm_ptr_ea, 4);
+  TEST_SIZE (*lm_ptr_ea, 1);
+  TEST_SIZE ( ea_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE (*ea_ptr_ea, 1);
+  PRINT1 ("\n");
+#endif
+#endif
+
+#if LEVEL2
+#if USE_LOCAL_VAR
+  TEST_SIZE (  lm_lm_ptr, 4);
+  TEST_SIZE ( *lm_lm_ptr, 4);
+  TEST_SIZE (**lm_lm_ptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (  lm_ea_ptr, 4);
+  TEST_SIZE ( *lm_ea_ptr, EA_PTRSIZE);
+  TEST_SIZE (**lm_ea_ptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (  ea_lm_ptr, EA_PTRSIZE);
+  TEST_SIZE ( *ea_lm_ptr, 4);
+  TEST_SIZE (**ea_lm_ptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (  ea_ea_ptr, EA_PTRSIZE);
+  TEST_SIZE ( *ea_ea_ptr, EA_PTRSIZE);
+  TEST_SIZE (**ea_ea_ptr, 1);
+  PRINT1 ("\n");
+#endif
+
+#if USE_EA_VAR
+  TEST_SIZE (  lm_lm_ptr_ea, 4);
+  TEST_SIZE ( *lm_lm_ptr_ea, 4);
+  TEST_SIZE (**lm_lm_ptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (  lm_ea_ptr_ea, 4);
+  TEST_SIZE ( *lm_ea_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE (**lm_ea_ptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (  ea_lm_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE ( *ea_lm_ptr_ea, 4);
+  TEST_SIZE (**ea_lm_ptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (  ea_ea_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE ( *ea_ea_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE (**ea_ea_ptr_ea, 1);
+  PRINT1 ("\n");
+#endif
+#endif
+
+#if LEVEL3
+#if USE_LOCAL_VAR
+  TEST_SIZE (   lm_lm_lm_ptr, 4);
+  TEST_SIZE (  *lm_lm_lm_ptr, 4);
+  TEST_SIZE ( **lm_lm_lm_ptr, 4);
+  TEST_SIZE (***lm_lm_lm_ptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   lm_lm_ea_ptr, 4);
+  TEST_SIZE (  *lm_lm_ea_ptr, 4);
+  TEST_SIZE ( **lm_lm_ea_ptr, EA_PTRSIZE);
+  TEST_SIZE (***lm_lm_ea_ptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   lm_ea_lm_ptr, 4);
+  TEST_SIZE (  *lm_ea_lm_ptr, EA_PTRSIZE);
+  TEST_SIZE ( **lm_ea_lm_ptr, 4);
+  TEST_SIZE (***lm_ea_lm_ptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   lm_ea_ea_ptr, 4);
+  TEST_SIZE (  *lm_ea_ea_ptr, EA_PTRSIZE);
+  TEST_SIZE ( **lm_ea_ea_ptr, EA_PTRSIZE);
+  TEST_SIZE (***lm_ea_ea_ptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_lm_lm_ptr, EA_PTRSIZE);
+  TEST_SIZE (  *ea_lm_lm_ptr, 4);
+  TEST_SIZE ( **ea_lm_lm_ptr, 4);
+  TEST_SIZE (***ea_lm_lm_ptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_lm_ea_ptr, EA_PTRSIZE);
+  TEST_SIZE (  *ea_lm_ea_ptr, 4);
+  TEST_SIZE ( **ea_lm_ea_ptr, EA_PTRSIZE);
+  TEST_SIZE (***ea_lm_ea_ptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_ea_lm_ptr, EA_PTRSIZE);
+  TEST_SIZE (  *ea_ea_lm_ptr, EA_PTRSIZE);
+  TEST_SIZE ( **ea_ea_lm_ptr, 4);
+  TEST_SIZE (***ea_ea_lm_ptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_ea_ea_ptr, EA_PTRSIZE);
+  TEST_SIZE (  *ea_ea_ea_ptr, EA_PTRSIZE);
+  TEST_SIZE ( **ea_ea_ea_ptr, EA_PTRSIZE);
+  TEST_SIZE (***ea_ea_ea_ptr, 1);
+  PRINT1 ("\n");
+#endif
+
+#if USE_EA_VAR
+  TEST_SIZE (   lm_lm_lm_ptr_ea, 4);
+  TEST_SIZE (  *lm_lm_lm_ptr_ea, 4);
+  TEST_SIZE ( **lm_lm_lm_ptr_ea, 4);
+  TEST_SIZE (***lm_lm_lm_ptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   lm_lm_ea_ptr_ea, 4);
+  TEST_SIZE (  *lm_lm_ea_ptr_ea, 4);
+  TEST_SIZE ( **lm_lm_ea_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE (***lm_lm_ea_ptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   lm_ea_lm_ptr_ea, 4);
+  TEST_SIZE (  *lm_ea_lm_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE ( **lm_ea_lm_ptr_ea, 4);
+  TEST_SIZE (***lm_ea_lm_ptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   lm_ea_ea_ptr_ea, 4);
+  TEST_SIZE (  *lm_ea_ea_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE ( **lm_ea_ea_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE (***lm_ea_ea_ptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_lm_lm_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE (  *ea_lm_lm_ptr_ea, 4);
+  TEST_SIZE ( **ea_lm_lm_ptr_ea, 4);
+  TEST_SIZE (***ea_lm_lm_ptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_lm_ea_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE (  *ea_lm_ea_ptr_ea, 4);
+  TEST_SIZE ( **ea_lm_ea_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE (***ea_lm_ea_ptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_ea_lm_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE (  *ea_ea_lm_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE ( **ea_ea_lm_ptr_ea, 4);
+  TEST_SIZE (***ea_ea_lm_ptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_ea_ea_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE (  *ea_ea_ea_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE ( **ea_ea_ea_ptr_ea, EA_PTRSIZE);
+  TEST_SIZE (***ea_ea_ea_ptr_ea, 1);
+  PRINT1 ("\n");
+#endif
+#endif
+#endif
+
+#if USE_COMPLEX
+#if LEVEL1
+#if USE_LOCAL_VAR
+  TEST_SIZE ( lm_cptr, 4);
+  TEST_SIZE (*lm_cptr, 1);
+  TEST_SIZE ( ea_cptr, EA_PTRSIZE);
+  TEST_SIZE (*ea_cptr, 1);
+  PRINT1 ("\n");
+#endif
+
+#if USE_EA_VAR
+  TEST_SIZE ( lm_cptr_ea, 4);
+  TEST_SIZE (*lm_cptr_ea, 1);
+  TEST_SIZE ( ea_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE (*ea_cptr_ea, 1);
+  PRINT1 ("\n");
+#endif
+#endif
+
+#if LEVEL2
+#if USE_LOCAL_VAR
+  TEST_SIZE (  lm_lm_cptr, 4);
+  TEST_SIZE ( *lm_lm_cptr, 4);
+  TEST_SIZE (**lm_lm_cptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (  lm_ea_cptr, 4);
+  TEST_SIZE ( *lm_ea_cptr, EA_PTRSIZE);
+  TEST_SIZE (**lm_ea_cptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (  ea_lm_cptr, EA_PTRSIZE);
+  TEST_SIZE ( *ea_lm_cptr, 4);
+  TEST_SIZE (**ea_lm_cptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (  ea_ea_cptr, EA_PTRSIZE);
+  TEST_SIZE ( *ea_ea_cptr, EA_PTRSIZE);
+  TEST_SIZE (**ea_ea_cptr, 1);
+  PRINT1 ("\n");
+#endif
+
+#if USE_EA_VAR
+  TEST_SIZE (  lm_lm_cptr_ea, 4);
+  TEST_SIZE ( *lm_lm_cptr_ea, 4);
+  TEST_SIZE (**lm_lm_cptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (  lm_ea_cptr_ea, 4);
+  TEST_SIZE ( *lm_ea_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE (**lm_ea_cptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (  ea_lm_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE ( *ea_lm_cptr_ea, 4);
+  TEST_SIZE (**ea_lm_cptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (  ea_ea_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE ( *ea_ea_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE (**ea_ea_cptr_ea, 1);
+  PRINT1 ("\n");
+#endif
+#endif
+
+#if LEVEL3
+#if USE_LOCAL_VAR
+  TEST_SIZE (   lm_lm_lm_cptr, 4);
+  TEST_SIZE (  *lm_lm_lm_cptr, 4);
+  TEST_SIZE ( **lm_lm_lm_cptr, 4);
+  TEST_SIZE (***lm_lm_lm_cptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   lm_lm_ea_cptr, 4);
+  TEST_SIZE (  *lm_lm_ea_cptr, 4);
+  TEST_SIZE ( **lm_lm_ea_cptr, EA_PTRSIZE);
+  TEST_SIZE (***lm_lm_ea_cptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   lm_ea_lm_cptr, 4);
+  TEST_SIZE (  *lm_ea_lm_cptr, EA_PTRSIZE);
+  TEST_SIZE ( **lm_ea_lm_cptr, 4);
+  TEST_SIZE (***lm_ea_lm_cptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   lm_ea_ea_cptr, 4);
+  TEST_SIZE (  *lm_ea_ea_cptr, EA_PTRSIZE);
+  TEST_SIZE ( **lm_ea_ea_cptr, EA_PTRSIZE);
+  TEST_SIZE (***lm_ea_ea_cptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_lm_lm_cptr, EA_PTRSIZE);
+  TEST_SIZE (  *ea_lm_lm_cptr, 4);
+  TEST_SIZE ( **ea_lm_lm_cptr, 4);
+  TEST_SIZE (***ea_lm_lm_cptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_lm_ea_cptr, EA_PTRSIZE);
+  TEST_SIZE (  *ea_lm_ea_cptr, 4);
+  TEST_SIZE ( **ea_lm_ea_cptr, EA_PTRSIZE);
+  TEST_SIZE (***ea_lm_ea_cptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_ea_lm_cptr, EA_PTRSIZE);
+  TEST_SIZE (  *ea_ea_lm_cptr, EA_PTRSIZE);
+  TEST_SIZE ( **ea_ea_lm_cptr, 4);
+  TEST_SIZE (***ea_ea_lm_cptr, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_ea_ea_cptr, EA_PTRSIZE);
+  TEST_SIZE (  *ea_ea_ea_cptr, EA_PTRSIZE);
+  TEST_SIZE ( **ea_ea_ea_cptr, EA_PTRSIZE);
+  TEST_SIZE (***ea_ea_ea_cptr, 1);
+  PRINT1 ("\n");
+#endif
+
+#if USE_EA_VAR
+  TEST_SIZE (   lm_lm_lm_cptr_ea, 4);
+  TEST_SIZE (  *lm_lm_lm_cptr_ea, 4);
+  TEST_SIZE ( **lm_lm_lm_cptr_ea, 4);
+  TEST_SIZE (***lm_lm_lm_cptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   lm_lm_ea_cptr_ea, 4);
+  TEST_SIZE (  *lm_lm_ea_cptr_ea, 4);
+  TEST_SIZE ( **lm_lm_ea_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE (***lm_lm_ea_cptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   lm_ea_lm_cptr_ea, 4);
+  TEST_SIZE (  *lm_ea_lm_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE ( **lm_ea_lm_cptr_ea, 4);
+  TEST_SIZE (***lm_ea_lm_cptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   lm_ea_ea_cptr_ea, 4);
+  TEST_SIZE (  *lm_ea_ea_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE ( **lm_ea_ea_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE (***lm_ea_ea_cptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_lm_lm_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE (  *ea_lm_lm_cptr_ea, 4);
+  TEST_SIZE ( **ea_lm_lm_cptr_ea, 4);
+  TEST_SIZE (***ea_lm_lm_cptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_lm_ea_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE (  *ea_lm_ea_cptr_ea, 4);
+  TEST_SIZE ( **ea_lm_ea_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE (***ea_lm_ea_cptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_ea_lm_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE (  *ea_ea_lm_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE ( **ea_ea_lm_cptr_ea, 4);
+  TEST_SIZE (***ea_ea_lm_cptr_ea, 1);
+  PRINT1 ("\n");
+
+  TEST_SIZE (   ea_ea_ea_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE (  *ea_ea_ea_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE ( **ea_ea_ea_cptr_ea, EA_PTRSIZE);
+  TEST_SIZE (***ea_ea_ea_cptr_ea, 1);
+  PRINT1 ("\n");
+#endif
+#endif
+#endif
+
+  if (errors)
+    {
+      PRINT3 ("%d error(s), %d test(s)\n", errors, num_tests);
+      abort ();
+    }
+  else
+    PRINT2 ("No errors, %d test(s)\n", num_tests);
+
+  return 0;
+}
diff -urNp gcc-4.4.4.orig/gcc/testsuite/g++.dg/ext/vector16.C gcc-4.4.4/gcc/testsuite/g++.dg/ext/vector16.C
--- a/src/gcc/testsuite/g++.dg/ext/vector16.C	1970-01-01
+++ b/src/gcc/testsuite/g++.dg/ext/vector16.C	2010-06-30
@@ -0,0 +1,11 @@
+/* { dg-do compile } */
+#define vector __attribute__((vector_size(4*sizeof(int)) ))
+
+vector int a, b, c;
+
+
+/* Test that remainder works for vectors. */
+void f(void)
+{
+  a = b % c;
+}
diff -urNp gcc-4.4.4.orig/gcc/tree.c gcc-4.4.4/gcc/tree.c
--- a/src/gcc/tree.c	2010-06-30
+++ b/src/gcc/tree.c	2010-06-30
@@ -1479,8 +1479,7 @@ integer_pow2p (const_tree expr)
   if (TREE_CODE (expr) != INTEGER_CST)
     return 0;
 
-  prec = (POINTER_TYPE_P (TREE_TYPE (expr))
-	  ? POINTER_SIZE : TYPE_PRECISION (TREE_TYPE (expr)));
+  prec = TYPE_PRECISION (TREE_TYPE (expr));
   high = TREE_INT_CST_HIGH (expr);
   low = TREE_INT_CST_LOW (expr);
 
@@ -1544,9 +1543,7 @@ tree_log2 (const_tree expr)
   if (TREE_CODE (expr) == COMPLEX_CST)
     return tree_log2 (TREE_REALPART (expr));
 
-  prec = (POINTER_TYPE_P (TREE_TYPE (expr))
-	  ? POINTER_SIZE : TYPE_PRECISION (TREE_TYPE (expr)));
-
+  prec = TYPE_PRECISION (TREE_TYPE (expr));
   high = TREE_INT_CST_HIGH (expr);
   low = TREE_INT_CST_LOW (expr);
 
@@ -1582,9 +1579,7 @@ tree_floor_log2 (const_tree expr)
   if (TREE_CODE (expr) == COMPLEX_CST)
     return tree_log2 (TREE_REALPART (expr));
 
-  prec = (POINTER_TYPE_P (TREE_TYPE (expr))
-	  ? POINTER_SIZE : TYPE_PRECISION (TREE_TYPE (expr)));
-
+  prec = TYPE_PRECISION (TREE_TYPE (expr));
   high = TREE_INT_CST_HIGH (expr);
   low = TREE_INT_CST_LOW (expr);
 
@@ -4205,6 +4200,7 @@ set_type_quals (tree type, int type_qual
   TYPE_READONLY (type) = (type_quals & TYPE_QUAL_CONST) != 0;
   TYPE_VOLATILE (type) = (type_quals & TYPE_QUAL_VOLATILE) != 0;
   TYPE_RESTRICT (type) = (type_quals & TYPE_QUAL_RESTRICT) != 0;
+  TYPE_ADDR_SPACE (type) = DECODE_QUAL_ADDR_SPACE (type_quals);
 }
 
 /* Returns true iff CAND is equivalent to BASE with TYPE_QUALS.  */
@@ -5566,7 +5562,10 @@ build_pointer_type_for_mode (tree to_typ
 tree
 build_pointer_type (tree to_type)
 {
-  return build_pointer_type_for_mode (to_type, ptr_mode, false);
+  addr_space_t as = to_type == error_mark_node? ADDR_SPACE_GENERIC
+					      : TYPE_ADDR_SPACE (to_type);
+  enum machine_mode pointer_mode = targetm.addr_space.pointer_mode (as);
+  return build_pointer_type_for_mode (to_type, pointer_mode, false);
 }
 
 /* Same as build_pointer_type_for_mode, but for REFERENCE_TYPE.  */
@@ -5630,7 +5629,10 @@ build_reference_type_for_mode (tree to_t
 tree
 build_reference_type (tree to_type)
 {
-  return build_reference_type_for_mode (to_type, ptr_mode, false);
+  addr_space_t as = to_type == error_mark_node? ADDR_SPACE_GENERIC
+					      : TYPE_ADDR_SPACE (to_type);
+  enum machine_mode pointer_mode = targetm.addr_space.pointer_mode (as);
+  return build_reference_type_for_mode (to_type, pointer_mode, false);
 }
 
 /* Build a type that is compatible with t but has no cv quals anywhere
@@ -5773,6 +5775,7 @@ build_array_type (tree elt_type, tree in
   t = make_node (ARRAY_TYPE);
   TREE_TYPE (t) = elt_type;
   TYPE_DOMAIN (t) = index_type;
+  TYPE_ADDR_SPACE (t) = TYPE_ADDR_SPACE (elt_type);
   
   if (index_type == 0)
     {
@@ -8349,7 +8352,15 @@ signed_or_unsigned_type_for (int unsigne
 {
   tree t = type;
   if (POINTER_TYPE_P (type))
-    t = size_type_node;
+    {
+      /* If the pointer points to the normal address space, use the
+	 size_type_node.  Otherwise use an appropriate size for the pointer
+	 based on the named address space it points to.  */
+      if (!TYPE_ADDR_SPACE (TREE_TYPE (t)))
+	t = size_type_node;
+      else
+	return lang_hooks.types.type_for_size (TYPE_PRECISION (t), unsignedp);
+    }
 
   if (!INTEGRAL_TYPE_P (t) || TYPE_UNSIGNED (t) == unsignedp)
     return t;
diff -urNp gcc-4.4.4.orig/gcc/tree-cfg.c gcc-4.4.4/gcc/tree-cfg.c
--- a/src/gcc/tree-cfg.c	2010-06-30
+++ b/src/gcc/tree-cfg.c	2010-06-30
@@ -3365,6 +3365,21 @@ verify_gimple_assign_unary (gimple stmt)
 	return false;
       }
 
+    case ADDR_SPACE_CONVERT_EXPR:
+      {
+	if (!POINTER_TYPE_P (rhs1_type) || !POINTER_TYPE_P (lhs_type)
+	    || (TYPE_ADDR_SPACE (TREE_TYPE (rhs1_type))
+		== TYPE_ADDR_SPACE (TREE_TYPE (lhs_type))))
+	  {
+	    error ("invalid types in address space conversion");
+	    debug_generic_expr (lhs_type);
+	    debug_generic_expr (rhs1_type);
+	    return true;
+	  }
+
+	return false;
+      }
+
     case FIXED_CONVERT_EXPR:
       {
 	if (!valid_fixed_convert_types_p (lhs_type, rhs1_type)
diff -urNp gcc-4.4.4.orig/gcc/tree.def gcc-4.4.4/gcc/tree.def
--- a/src/gcc/tree.def	2009-02-20
+++ b/src/gcc/tree.def	2010-06-30
@@ -763,6 +763,10 @@ DEFTREECODE (PAREN_EXPR, "paren_expr", t
    represented by CONVERT_EXPR or NOP_EXPR nodes.  */
 DEFTREECODE (CONVERT_EXPR, "convert_expr", tcc_unary, 1)
 
+/* Conversion of a pointer value to a pointer to a different
+   address space.  */
+DEFTREECODE (ADDR_SPACE_CONVERT_EXPR, "addr_space_convert_expr", tcc_unary, 1)
+
 /* Conversion of a fixed-point value to an integer, a real, or a fixed-point
    value.  Or conversion of a fixed-point value from an integer, a real, or
    a fixed-point value.  */
diff -urNp gcc-4.4.4.orig/gcc/tree-flow.h gcc-4.4.4/gcc/tree-flow.h
--- a/src/gcc/tree-flow.h	2009-03-06
+++ b/src/gcc/tree-flow.h	2010-06-30
@@ -1133,7 +1133,8 @@ extern void tree_check_data_deps (void);
 /* In tree-ssa-loop-ivopts.c  */
 bool expr_invariant_in_loop_p (struct loop *, tree);
 bool stmt_invariant_in_loop_p (struct loop *, gimple);
-bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode);
+bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode,
+				      addr_space_t);
 unsigned multiply_by_cost (HOST_WIDE_INT, enum machine_mode, bool);
 
 /* In tree-ssa-threadupdate.c.  */
@@ -1166,8 +1167,8 @@ struct mem_address
 
 struct affine_tree_combination;
 tree create_mem_ref (gimple_stmt_iterator *, tree, 
-		     struct affine_tree_combination *, bool);
-rtx addr_for_mem_ref (struct mem_address *, bool);
+		     struct affine_tree_combination *, tree, bool);
+rtx addr_for_mem_ref (struct mem_address *, addr_space_t, bool);
 void get_address_description (tree, struct mem_address *);
 tree maybe_fold_tmr (tree);
 
diff -urNp gcc-4.4.4.orig/gcc/tree.h gcc-4.4.4/gcc/tree.h
--- a/src/gcc/tree.h	2010-06-30
+++ b/src/gcc/tree.h	2010-06-30
@@ -384,7 +384,12 @@ struct tree_base GTY(())
   unsigned packed_flag : 1;
   unsigned user_align : 1;
 
-  unsigned spare : 21;
+  unsigned spare : 13;
+
+  /* This field is only used with type nodes; the only reason it is present
+     in tree_base instead of tree_type is to save space.  The size of the
+     field must be large enough to hold addr_space_t values.  */
+  unsigned address_space : 8;
 
   union tree_ann_d *ann;
 };
@@ -2182,6 +2187,9 @@ extern enum machine_mode vector_type_mod
    the term.  */
 #define TYPE_RESTRICT(NODE) (TYPE_CHECK (NODE)->type.restrict_flag)
 
+/* The address space the type is in.  */
+#define TYPE_ADDR_SPACE(NODE) (TYPE_CHECK (NODE)->base.address_space)
+
 /* There is a TYPE_QUAL value for each type qualifier.  They can be
    combined by bitwise-or to form the complete set of qualifiers for a
    type.  */
@@ -2191,10 +2199,29 @@ extern enum machine_mode vector_type_mod
 #define TYPE_QUAL_VOLATILE 0x2
 #define TYPE_QUAL_RESTRICT 0x4
 
+/* Encode/decode the named memory support as part of the qualifier.  If more
+   than 8 qualifiers are added, these macros need to be adjusted.  */
+#define ENCODE_QUAL_ADDR_SPACE(NUM) ((NUM & 0xFF) << 8)
+#define DECODE_QUAL_ADDR_SPACE(X) (((X) >> 8) & 0xFF)
+
+/* Return all qualifiers except for the address space qualifiers.  */
+#define CLEAR_QUAL_ADDR_SPACE(X) ((X) & ~0xFF00)
+
+/* Only keep the address space out of the qualifiers and discard the other
+   qualifiers.  */
+#define KEEP_QUAL_ADDR_SPACE(X) ((X) & 0xFF00)
+
 /* The set of type qualifiers for this type.  */
 #define TYPE_QUALS(NODE)					\
   ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)			\
    | (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)		\
+   | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT)		\
+   | (ENCODE_QUAL_ADDR_SPACE (TYPE_ADDR_SPACE (NODE))))
+
+/* The same as TYPE_QUALS without the address space qualifications.  */
+#define TYPE_QUALS_NO_ADDR_SPACE(NODE)				\
+  ((TYPE_READONLY (NODE) * TYPE_QUAL_CONST)			\
+   | (TYPE_VOLATILE (NODE) * TYPE_QUAL_VOLATILE)		\
    | (TYPE_RESTRICT (NODE) * TYPE_QUAL_RESTRICT))
 
 /* These flags are available for each language front end to use internally.  */
diff -urNp gcc-4.4.4.orig/gcc/tree-inline.c gcc-4.4.4/gcc/tree-inline.c
--- a/src/gcc/tree-inline.c	2010-02-08
+++ b/src/gcc/tree-inline.c	2010-06-30
@@ -2765,6 +2765,7 @@ estimate_operator_cost (enum tree_code c
     case MINUS_EXPR:
     case MULT_EXPR:
 
+    case ADDR_SPACE_CONVERT_EXPR:
     case FIXED_CONVERT_EXPR:
     case FIX_TRUNC_EXPR:
 
diff -urNp gcc-4.4.4.orig/gcc/tree-pretty-print.c gcc-4.4.4/gcc/tree-pretty-print.c
--- a/src/gcc/tree-pretty-print.c	2009-02-18
+++ b/src/gcc/tree-pretty-print.c	2010-06-30
@@ -527,6 +527,13 @@ dump_generic_node (pretty_printer *buffe
 	else if (quals & TYPE_QUAL_RESTRICT)
 	  pp_string (buffer, "restrict ");
 
+	if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (node)))
+	  {
+	    pp_string (buffer, "<address-space-");
+	    pp_decimal_int (buffer, TYPE_ADDR_SPACE (node));
+	    pp_string (buffer, "> ");
+	  }
+
 	tclass = TREE_CODE_CLASS (TREE_CODE (node));
 
 	if (tclass == tcc_declaration)
@@ -603,6 +610,13 @@ dump_generic_node (pretty_printer *buffe
 	  if (quals & TYPE_QUAL_RESTRICT)
 	    pp_string (buffer, " restrict");
 
+	  if (!ADDR_SPACE_GENERIC_P (TYPE_ADDR_SPACE (node)))
+	    {
+	      pp_string (buffer, " <address-space-");
+	      pp_decimal_int (buffer, TYPE_ADDR_SPACE (node));
+	      pp_string (buffer, ">");
+	    }
+
 	  if (TYPE_REF_CAN_ALIAS_ALL (node))
 	    pp_string (buffer, " {ref-all}");
 	}
@@ -1383,6 +1397,7 @@ dump_generic_node (pretty_printer *buffe
       NIY;
       break;
 
+    case ADDR_SPACE_CONVERT_EXPR:
     case FIXED_CONVERT_EXPR:
     case FIX_TRUNC_EXPR:
     case FLOAT_EXPR:
diff -urNp gcc-4.4.4.orig/gcc/tree-ssa-address.c gcc-4.4.4/gcc/tree-ssa-address.c
--- a/src/gcc/tree-ssa-address.c	2010-04-08
+++ b/src/gcc/tree-ssa-address.c	2010-06-30
@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  
 #include "expr.h"
 #include "ggc.h"
 #include "tree-affine.h"
+#include "target.h"
 
 /* TODO -- handling of symbols (according to Richard Hendersons
    comments, http://gcc.gnu.org/ml/gcc-patches/2005-04/msg00949.html):
@@ -70,33 +71,39 @@ along with GCC; see the file COPYING3.  
 /* A "template" for memory address, used to determine whether the address is
    valid for mode.  */
 
-struct mem_addr_template GTY (())
+typedef struct mem_addr_template GTY (())
 {
   rtx ref;			/* The template.  */
   rtx * GTY ((skip)) step_p;	/* The point in template where the step should be
 				   filled in.  */
   rtx * GTY ((skip)) off_p;	/* The point in template where the offset should
 				   be filled in.  */
-};
+} mem_addr_template;
 
-/* The templates.  Each of the five bits of the index corresponds to one
-   component of TARGET_MEM_REF being present, see TEMPL_IDX.  */
+DEF_VEC_O (mem_addr_template);
+DEF_VEC_ALLOC_O (mem_addr_template, gc);
 
-static GTY (()) struct mem_addr_template templates[32];
+/* The templates.  Each of the low five bits of the index corresponds to one
+   component of TARGET_MEM_REF being present, while the high bits identify
+   the address space.  See TEMPL_IDX.  */
 
-#define TEMPL_IDX(SYMBOL, BASE, INDEX, STEP, OFFSET) \
-  (((SYMBOL != 0) << 4) \
+static GTY(()) VEC (mem_addr_template, gc) *mem_addr_template_list;
+
+#define TEMPL_IDX(AS, SYMBOL, BASE, INDEX, STEP, OFFSET) \
+  (((int) (AS) << 5) \
+   | ((SYMBOL != 0) << 4) \
    | ((BASE != 0) << 3) \
    | ((INDEX != 0) << 2) \
    | ((STEP != 0) << 1) \
    | (OFFSET != 0))
 
 /* Stores address for memory reference with parameters SYMBOL, BASE, INDEX,
-   STEP and OFFSET to *ADDR.  Stores pointers to where step is placed to
-   *STEP_P and offset to *OFFSET_P.  */
+   STEP and OFFSET to *ADDR using address mode ADDRESS_MODE.  Stores pointers
+   to where step is placed to *STEP_P and offset to *OFFSET_P.  */
 
 static void
-gen_addr_rtx (rtx symbol, rtx base, rtx index, rtx step, rtx offset,
+gen_addr_rtx (enum machine_mode address_mode,
+	      rtx symbol, rtx base, rtx index, rtx step, rtx offset,
 	      rtx *addr, rtx **step_p, rtx **offset_p)
 {
   rtx act_elem;
@@ -112,7 +119,7 @@ gen_addr_rtx (rtx symbol, rtx base, rtx 
       act_elem = index;
       if (step)
 	{
-	  act_elem = gen_rtx_MULT (Pmode, act_elem, step);
+	  act_elem = gen_rtx_MULT (address_mode, act_elem, step);
 
 	  if (step_p)
 	    *step_p = &XEXP (act_elem, 1);
@@ -124,7 +131,7 @@ gen_addr_rtx (rtx symbol, rtx base, rtx 
   if (base)
     {
       if (*addr)
-	*addr = simplify_gen_binary (PLUS, Pmode, base, *addr);
+	*addr = simplify_gen_binary (PLUS, address_mode, base, *addr);
       else
 	*addr = base;
     }
@@ -134,7 +141,7 @@ gen_addr_rtx (rtx symbol, rtx base, rtx 
       act_elem = symbol;
       if (offset)
 	{
-	  act_elem = gen_rtx_PLUS (Pmode, act_elem, offset);
+	  act_elem = gen_rtx_PLUS (address_mode, act_elem, offset);
 
 	  if (offset_p)
 	    *offset_p = &XEXP (act_elem, 1);
@@ -142,11 +149,11 @@ gen_addr_rtx (rtx symbol, rtx base, rtx 
 	  if (GET_CODE (symbol) == SYMBOL_REF
 	      || GET_CODE (symbol) == LABEL_REF
 	      || GET_CODE (symbol) == CONST)
-	    act_elem = gen_rtx_CONST (Pmode, act_elem);
+	    act_elem = gen_rtx_CONST (address_mode, act_elem);
 	}
 
       if (*addr)
-	*addr = gen_rtx_PLUS (Pmode, *addr, act_elem);
+	*addr = gen_rtx_PLUS (address_mode, *addr, act_elem);
       else
 	*addr = act_elem;
     }
@@ -154,7 +161,7 @@ gen_addr_rtx (rtx symbol, rtx base, rtx 
     {
       if (*addr)
 	{
-	  *addr = gen_rtx_PLUS (Pmode, *addr, offset);
+	  *addr = gen_rtx_PLUS (address_mode, *addr, offset);
 	  if (offset_p)
 	    *offset_p = &XEXP (*addr, 1);
 	}
@@ -170,55 +177,64 @@ gen_addr_rtx (rtx symbol, rtx base, rtx 
     *addr = const0_rtx;
 }
 
-/* Returns address for TARGET_MEM_REF with parameters given by ADDR.
+/* Returns address for TARGET_MEM_REF with parameters given by ADDR
+   in address space AS.
    If REALLY_EXPAND is false, just make fake registers instead 
    of really expanding the operands, and perform the expansion in-place
    by using one of the "templates".  */
 
 rtx
-addr_for_mem_ref (struct mem_address *addr, bool really_expand)
+addr_for_mem_ref (struct mem_address *addr, addr_space_t as,
+		  bool really_expand)
 {
+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);
   rtx address, sym, bse, idx, st, off;
-  static bool templates_initialized = false;
   struct mem_addr_template *templ;
 
   if (addr->step && !integer_onep (addr->step))
     st = immed_double_const (TREE_INT_CST_LOW (addr->step),
-			     TREE_INT_CST_HIGH (addr->step), Pmode);
+			     TREE_INT_CST_HIGH (addr->step), address_mode);
   else
     st = NULL_RTX;
 
   if (addr->offset && !integer_zerop (addr->offset))
     off = immed_double_const (TREE_INT_CST_LOW (addr->offset),
-			      TREE_INT_CST_HIGH (addr->offset), Pmode);
+			      TREE_INT_CST_HIGH (addr->offset), address_mode);
   else
     off = NULL_RTX;
 
   if (!really_expand)
     {
+      unsigned int templ_index
+	= TEMPL_IDX (as, addr->symbol, addr->base, addr->index, st, off);
+
+      if (templ_index
+	  >= VEC_length (mem_addr_template, mem_addr_template_list))
+	VEC_safe_grow_cleared (mem_addr_template, gc, mem_addr_template_list,
+			       templ_index + 1);
+
       /* Reuse the templates for addresses, so that we do not waste memory.  */
-      if (!templates_initialized)
+      templ = VEC_index (mem_addr_template, mem_addr_template_list, templ_index);
+      if (!templ->ref)
 	{
-	  unsigned i;
-
-	  templates_initialized = true;
-	  sym = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup ("test_symbol"));
-	  bse = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);
-	  idx = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 2);
-
-	  for (i = 0; i < 32; i++)
-	    gen_addr_rtx ((i & 16 ? sym : NULL_RTX),
-			  (i & 8 ? bse : NULL_RTX),
-			  (i & 4 ? idx : NULL_RTX),
-			  (i & 2 ? const0_rtx : NULL_RTX),
-			  (i & 1 ? const0_rtx : NULL_RTX),
-			  &templates[i].ref,
-			  &templates[i].step_p,
-			  &templates[i].off_p);
+	  sym = (addr->symbol ?
+		 gen_rtx_SYMBOL_REF (address_mode, ggc_strdup ("test_symbol"))
+		 : NULL_RTX);
+	  bse = (addr->base ?
+		 gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 1)
+		 : NULL_RTX);
+	  idx = (addr->index ?
+		 gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 2)
+		 : NULL_RTX);
+
+	  gen_addr_rtx (address_mode, sym, bse, idx,
+			st? const0_rtx : NULL_RTX,
+			off? const0_rtx : NULL_RTX,
+			&templ->ref,
+			&templ->step_p,
+			&templ->off_p);
 	}
 
-      templ = templates + TEMPL_IDX (addr->symbol, addr->base, addr->index,
-				     st, off);
       if (st)
 	*templ->step_p = st;
       if (off)
@@ -230,16 +246,16 @@ addr_for_mem_ref (struct mem_address *ad
   /* Otherwise really expand the expressions.  */
   sym = (addr->symbol
 	 ? expand_expr (build_addr (addr->symbol, current_function_decl),
-			NULL_RTX, Pmode, EXPAND_NORMAL)
+			NULL_RTX, address_mode, EXPAND_NORMAL)
 	 : NULL_RTX);
   bse = (addr->base
-	 ? expand_expr (addr->base, NULL_RTX, Pmode, EXPAND_NORMAL)
+	 ? expand_expr (addr->base, NULL_RTX, address_mode, EXPAND_NORMAL)
 	 : NULL_RTX);
   idx = (addr->index
-	 ? expand_expr (addr->index, NULL_RTX, Pmode, EXPAND_NORMAL)
+	 ? expand_expr (addr->index, NULL_RTX, address_mode, EXPAND_NORMAL)
 	 : NULL_RTX);
 
-  gen_addr_rtx (sym, bse, idx, st, off, &address, NULL, NULL);
+  gen_addr_rtx (address_mode, sym, bse, idx, st, off, &address, NULL, NULL);
   return address;
 }
 
@@ -306,15 +322,16 @@ tree_mem_ref_addr (tree type, tree mem_r
    ADDR is valid on the current target.  */
 
 static bool
-valid_mem_ref_p (enum machine_mode mode, struct mem_address *addr)
+valid_mem_ref_p (enum machine_mode mode, addr_space_t as,
+		 struct mem_address *addr)
 {
   rtx address;
 
-  address = addr_for_mem_ref (addr, false);
+  address = addr_for_mem_ref (addr, as, false);
   if (!address)
     return false;
 
-  return memory_address_p (mode, address);
+  return memory_address_addr_space_p (mode, address, as);
 }
 
 /* Checks whether a TARGET_MEM_REF with type TYPE and parameters given by ADDR
@@ -324,7 +341,7 @@ valid_mem_ref_p (enum machine_mode mode,
 static tree
 create_mem_ref_raw (tree type, struct mem_address *addr)
 {
-  if (!valid_mem_ref_p (TYPE_MODE (type), addr))
+  if (!valid_mem_ref_p (TYPE_MODE (type), TYPE_ADDR_SPACE (type), addr))
     return NULL_TREE;
 
   if (addr->step && integer_onep (addr->step))
@@ -376,6 +393,39 @@ move_fixed_address_to_symbol (struct mem
   aff_combination_remove_elt (addr, i);
 }
 
+/* If ADDR contains an instance of BASE_HINT, move it to PARTS->base.  */
+
+static void
+move_hint_to_base (tree type, struct mem_address *parts, tree base_hint,
+		   aff_tree *addr)
+{
+  unsigned i;
+  tree val = NULL_TREE;
+  int qual;
+
+  for (i = 0; i < addr->n; i++)
+    {
+      if (!double_int_one_p (addr->elts[i].coef))
+	continue;
+
+      val = addr->elts[i].val;
+      if (operand_equal_p (val, base_hint, 0))
+	break;
+    }
+
+  if (i == addr->n)
+    return;
+
+  /* Cast value to appropriate pointer type.  We cannot use a pointer
+     to TYPE directly, as the back-end will assume registers of pointer
+     type are aligned, and just the base itself may not actually be.
+     We use void pointer to the type's address space instead.  */
+  qual = ENCODE_QUAL_ADDR_SPACE (TYPE_ADDR_SPACE (type));
+  type = build_qualified_type (void_type_node, qual);
+  parts->base = fold_convert (build_pointer_type (type), val);
+  aff_combination_remove_elt (addr, i);
+}
+
 /* If ADDR contains an address of a dereferenced pointer, move it to
    PARTS->base.  */
 
@@ -437,9 +487,11 @@ add_to_parts (struct mem_address *parts,
    element(s) to PARTS.  */
 
 static void
-most_expensive_mult_to_index (struct mem_address *parts, aff_tree *addr,
-			      bool speed)
+most_expensive_mult_to_index (tree type, struct mem_address *parts,
+			      aff_tree *addr, bool speed)
 {
+  addr_space_t as = TYPE_ADDR_SPACE (type);
+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);
   HOST_WIDE_INT coef;
   double_int best_mult, amult, amult_neg;
   unsigned best_mult_cost = 0, acost;
@@ -453,14 +505,12 @@ most_expensive_mult_to_index (struct mem
       if (!double_int_fits_in_shwi_p (addr->elts[i].coef))
 	continue;
 
-      /* FIXME: Should use the correct memory mode rather than Pmode.  */
-
       coef = double_int_to_shwi (addr->elts[i].coef);
       if (coef == 1
-	  || !multiplier_allowed_in_address_p (coef, Pmode))
+	  || !multiplier_allowed_in_address_p (coef, TYPE_MODE (type), as))
 	continue;
 
-      acost = multiply_by_cost (coef, Pmode, speed);
+      acost = multiply_by_cost (coef, address_mode, speed);
 
       if (acost > best_mult_cost)
 	{
@@ -503,8 +553,10 @@ most_expensive_mult_to_index (struct mem
   parts->step = double_int_to_tree (sizetype, best_mult);
 }
 
-/* Splits address ADDR into PARTS.
-   
+/* Splits address ADDR for a memory access of type TYPE into PARTS.
+   If BASE_HINT is non-NULL, it specifies an SSA name to be used
+   preferentially as base of the reference.
+
    TODO -- be more clever about the distribution of the elements of ADDR
    to PARTS.  Some architectures do not support anything but single
    register in address, possibly with a small integer offset; while
@@ -513,7 +565,8 @@ most_expensive_mult_to_index (struct mem
    addressing modes is useless.  */
 
 static void
-addr_to_parts (aff_tree *addr, struct mem_address *parts, bool speed)
+addr_to_parts (tree type, aff_tree *addr, tree base_hint,
+	       struct mem_address *parts, bool speed)
 {
   tree part;
   unsigned i;
@@ -533,12 +586,14 @@ addr_to_parts (aff_tree *addr, struct me
 
   /* First move the most expensive feasible multiplication
      to index.  */
-  most_expensive_mult_to_index (parts, addr, speed);
+  most_expensive_mult_to_index (type, parts, addr, speed);
 
   /* Try to find a base of the reference.  Since at the moment
      there is no reliable way how to distinguish between pointer and its
      offset, this is just a guess.  */
-  if (!parts->symbol)
+  if (!parts->symbol && base_hint)
+    move_hint_to_base (type, parts, base_hint, addr);
+  if (!parts->symbol && !parts->base)
     move_pointer_to_base (parts, addr);
 
   /* Then try to process the remaining elements.  */
@@ -575,13 +630,13 @@ gimplify_mem_ref_parts (gimple_stmt_iter
 
 tree
 create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,
-		bool speed)
+		tree base_hint, bool speed)
 {
   tree mem_ref, tmp;
   tree atype;
   struct mem_address parts;
 
-  addr_to_parts (addr, &parts, speed);
+  addr_to_parts (type, addr, base_hint, &parts, speed);
   gimplify_mem_ref_parts (gsi, &parts);
   mem_ref = create_mem_ref_raw (type, &parts);
   if (mem_ref)
diff -urNp gcc-4.4.4.orig/gcc/tree-ssa.c gcc-4.4.4/gcc/tree-ssa.c
--- a/src/gcc/tree-ssa.c	2009-08-03
+++ b/src/gcc/tree-ssa.c	2010-06-30
@@ -1075,6 +1075,11 @@ useless_type_conversion_p_1 (tree outer_
   if (POINTER_TYPE_P (inner_type)
       && POINTER_TYPE_P (outer_type))
     {
+      /* Do not lose casts between pointers to different address spaces.  */
+      if (TYPE_ADDR_SPACE (TREE_TYPE (outer_type))
+	  != TYPE_ADDR_SPACE (TREE_TYPE (inner_type)))
+	return false;
+
       /* Do not lose casts to restrict qualified pointers.  */
       if ((TYPE_RESTRICT (outer_type)
 	   != TYPE_RESTRICT (inner_type))
@@ -1235,7 +1240,14 @@ useless_type_conversion_p (tree outer_ty
   if (POINTER_TYPE_P (inner_type)
       && POINTER_TYPE_P (outer_type)
       && TREE_CODE (TREE_TYPE (outer_type)) == VOID_TYPE)
-    return true;
+    {
+      /* Do not lose casts between pointers to different address spaces.  */
+      if (TYPE_ADDR_SPACE (TREE_TYPE (outer_type))
+	  != TYPE_ADDR_SPACE (TREE_TYPE (inner_type)))
+	return false;
+
+      return true;
+    }
 
   return useless_type_conversion_p_1 (outer_type, inner_type);
 }
diff -urNp gcc-4.4.4.orig/gcc/tree-ssa-loop-ivopts.c gcc-4.4.4/gcc/tree-ssa-loop-ivopts.c
--- a/src/gcc/tree-ssa-loop-ivopts.c	2010-06-30
+++ b/src/gcc/tree-ssa-loop-ivopts.c	2010-06-30
@@ -2575,21 +2575,25 @@ seq_cost (rtx seq, bool speed)
 static rtx
 produce_memory_decl_rtl (tree obj, int *regno)
 {
+  addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (obj));
+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);
   rtx x;
   
   gcc_assert (obj);
   if (TREE_STATIC (obj) || DECL_EXTERNAL (obj))
     {
       const char *name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (obj));
-      x = gen_rtx_SYMBOL_REF (Pmode, name);
+      x = gen_rtx_SYMBOL_REF (address_mode, name);
       SET_SYMBOL_REF_DECL (x, obj);
       x = gen_rtx_MEM (DECL_MODE (obj), x);
+      set_mem_addr_space (x, as);
       targetm.encode_section_info (obj, x, true);
     }
   else
     {
-      x = gen_raw_REG (Pmode, (*regno)++);
+      x = gen_raw_REG (address_mode, (*regno)++);
       x = gen_rtx_MEM (DECL_MODE (obj), x);
+      set_mem_addr_space (x, as);
     }
 
   return x;
@@ -2677,7 +2681,8 @@ computation_cost (tree expr, bool speed)
 
   cost = seq_cost (seq, speed);
   if (MEM_P (rslt))
-    cost += address_cost (XEXP (rslt, 0), TYPE_MODE (type), speed);
+    cost += address_cost (XEXP (rslt, 0), TYPE_MODE (type),
+			  TYPE_ADDR_SPACE (type), speed);
 
   return cost;
 }
@@ -2953,124 +2958,153 @@ multiply_by_cost (HOST_WIDE_INT cst, enu
 }
 
 /* Returns true if multiplying by RATIO is allowed in an address.  Test the
-   validity for a memory reference accessing memory of mode MODE.  */
+   validity for a memory reference accessing memory of mode MODE in
+   address space AS.  */
+
+DEF_VEC_P (sbitmap);
+DEF_VEC_ALLOC_P (sbitmap, heap);
 
 bool
-multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode)
+multiplier_allowed_in_address_p (HOST_WIDE_INT ratio, enum machine_mode mode,
+				 addr_space_t as)
 {
 #define MAX_RATIO 128
-  static sbitmap valid_mult[MAX_MACHINE_MODE];
-  
-  if (!valid_mult[mode])
+  unsigned int data_index = (int) as * MAX_MACHINE_MODE + (int) mode;
+  static VEC (sbitmap, heap) *valid_mult_list;
+  sbitmap valid_mult;
+
+  if (data_index >= VEC_length (sbitmap, valid_mult_list))
+    VEC_safe_grow_cleared (sbitmap, heap, valid_mult_list, data_index + 1);
+
+  valid_mult = VEC_index (sbitmap, valid_mult_list, data_index);
+  if (!valid_mult)
     {
-      rtx reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);
+      enum machine_mode address_mode = targetm.addr_space.address_mode (as);
+      rtx reg1 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 1);
       rtx addr;
       HOST_WIDE_INT i;
 
-      valid_mult[mode] = sbitmap_alloc (2 * MAX_RATIO + 1);
-      sbitmap_zero (valid_mult[mode]);
-      addr = gen_rtx_fmt_ee (MULT, Pmode, reg1, NULL_RTX);
+      valid_mult = sbitmap_alloc (2 * MAX_RATIO + 1);
+      sbitmap_zero (valid_mult);
+      addr = gen_rtx_fmt_ee (MULT, address_mode, reg1, NULL_RTX);
       for (i = -MAX_RATIO; i <= MAX_RATIO; i++)
 	{
-	  XEXP (addr, 1) = gen_int_mode (i, Pmode);
-	  if (memory_address_p (mode, addr))
-	    SET_BIT (valid_mult[mode], i + MAX_RATIO);
+	  XEXP (addr, 1) = gen_int_mode (i, address_mode);
+	  if (memory_address_addr_space_p (mode, addr, as))
+	    SET_BIT (valid_mult, i + MAX_RATIO);
 	}
 
       if (dump_file && (dump_flags & TDF_DETAILS))
 	{
 	  fprintf (dump_file, "  allowed multipliers:");
 	  for (i = -MAX_RATIO; i <= MAX_RATIO; i++)
-	    if (TEST_BIT (valid_mult[mode], i + MAX_RATIO))
+	    if (TEST_BIT (valid_mult, i + MAX_RATIO))
 	      fprintf (dump_file, " %d", (int) i);
 	  fprintf (dump_file, "\n");
 	  fprintf (dump_file, "\n");
 	}
+
+      VEC_replace (sbitmap, valid_mult_list, data_index, valid_mult);
     }
 
   if (ratio > MAX_RATIO || ratio < -MAX_RATIO)
     return false;
 
-  return TEST_BIT (valid_mult[mode], ratio + MAX_RATIO);
+  return TEST_BIT (valid_mult, ratio + MAX_RATIO);
 }
 
 /* Returns cost of address in shape symbol + var + OFFSET + RATIO * index.
    If SYMBOL_PRESENT is false, symbol is omitted.  If VAR_PRESENT is false,
    variable is omitted.  Compute the cost for a memory reference that accesses
-   a memory location of mode MEM_MODE.
+   a memory location of mode MEM_MODE in address space AS.
 
    TODO -- there must be some better way.  This all is quite crude.  */
 
+typedef struct
+{
+  HOST_WIDE_INT min_offset, max_offset;
+  unsigned costs[2][2][2][2];
+} *address_cost_data;
+
+DEF_VEC_P (address_cost_data);
+DEF_VEC_ALLOC_P (address_cost_data, heap);
+
 static comp_cost
 get_address_cost (bool symbol_present, bool var_present,
 		  unsigned HOST_WIDE_INT offset, HOST_WIDE_INT ratio,
-		  enum machine_mode mem_mode,
+		  enum machine_mode mem_mode, addr_space_t as,
 		  bool speed)
 {
-  static bool initialized[MAX_MACHINE_MODE];
-  static HOST_WIDE_INT rat[MAX_MACHINE_MODE], off[MAX_MACHINE_MODE];
-  static HOST_WIDE_INT min_offset[MAX_MACHINE_MODE], max_offset[MAX_MACHINE_MODE];
-  static unsigned costs[MAX_MACHINE_MODE][2][2][2][2];
+  enum machine_mode address_mode = targetm.addr_space.address_mode (as);
+  static VEC(address_cost_data, heap) *address_cost_data_list;
+  unsigned int data_index = (int) as * MAX_MACHINE_MODE + (int) mem_mode;
+  address_cost_data data;
   unsigned cost, acost, complexity;
   bool offset_p, ratio_p;
   HOST_WIDE_INT s_offset;
   unsigned HOST_WIDE_INT mask;
   unsigned bits;
 
-  if (!initialized[mem_mode])
+  if (data_index >= VEC_length (address_cost_data, address_cost_data_list))
+    VEC_safe_grow_cleared (address_cost_data, heap, address_cost_data_list,
+			   data_index + 1);
+
+  data = VEC_index (address_cost_data, address_cost_data_list, data_index);
+  if (!data)
     {
       HOST_WIDE_INT i;
       HOST_WIDE_INT start = BIGGEST_ALIGNMENT / BITS_PER_UNIT;
+      HOST_WIDE_INT rat, off;
       int old_cse_not_expected;
       unsigned sym_p, var_p, off_p, rat_p, add_c;
       rtx seq, addr, base;
       rtx reg0, reg1;
 
-      initialized[mem_mode] = true;
+      data = (address_cost_data) xcalloc (1, sizeof (*data));
 
-      reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);
+      reg1 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 1);
 
-      addr = gen_rtx_fmt_ee (PLUS, Pmode, reg1, NULL_RTX);
+      addr = gen_rtx_fmt_ee (PLUS, address_mode, reg1, NULL_RTX);
       for (i = start; i <= 1 << 20; i <<= 1)
 	{
-	  XEXP (addr, 1) = gen_int_mode (i, Pmode);
-	  if (!memory_address_p (mem_mode, addr))
+	  XEXP (addr, 1) = gen_int_mode (i, address_mode);
+	  if (!memory_address_addr_space_p (mem_mode, addr, as))
 	    break;
 	}
-      max_offset[mem_mode] = i == start ? 0 : i >> 1;
-      off[mem_mode] = max_offset[mem_mode];
+      data->max_offset = i == start ? 0 : i >> 1;
+      off = data->max_offset;
 
       for (i = start; i <= 1 << 20; i <<= 1)
 	{
-	  XEXP (addr, 1) = gen_int_mode (-i, Pmode);
-	  if (!memory_address_p (mem_mode, addr))
+	  XEXP (addr, 1) = gen_int_mode (-i, address_mode);
+	  if (!memory_address_addr_space_p (mem_mode, addr, as))
 	    break;
 	}
-      min_offset[mem_mode] = i == start ? 0 : -(i >> 1);
+      data->min_offset = i == start ? 0 : -(i >> 1);
 
       if (dump_file && (dump_flags & TDF_DETAILS))
 	{
 	  fprintf (dump_file, "get_address_cost:\n");
 	  fprintf (dump_file, "  min offset %s %d\n",
 		   GET_MODE_NAME (mem_mode),
-		   (int) min_offset[mem_mode]);
+		   (int) data->min_offset);
 	  fprintf (dump_file, "  max offset %s %d\n",
 		   GET_MODE_NAME (mem_mode),
-		   (int) max_offset[mem_mode]);
+		   (int) data->max_offset);
 	}
 
-      rat[mem_mode] = 1;
+      rat = 1;
       for (i = 2; i <= MAX_RATIO; i++)
-	if (multiplier_allowed_in_address_p (i, mem_mode))
+	if (multiplier_allowed_in_address_p (i, mem_mode, as))
 	  {
-	    rat[mem_mode] = i;
+	    rat = i;
 	    break;
 	  }
 
       /* Compute the cost of various addressing modes.  */
       acost = 0;
-      reg0 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 1);
-      reg1 = gen_raw_REG (Pmode, LAST_VIRTUAL_REGISTER + 2);
+      reg0 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 1);
+      reg1 = gen_raw_REG (address_mode, LAST_VIRTUAL_REGISTER + 2);
 
       for (i = 0; i < 16; i++)
 	{
@@ -3081,15 +3115,15 @@ get_address_cost (bool symbol_present, b
 
 	  addr = reg0;
 	  if (rat_p)
-	    addr = gen_rtx_fmt_ee (MULT, Pmode, addr,
-				   gen_int_mode (rat[mem_mode], Pmode));
+	    addr = gen_rtx_fmt_ee (MULT, address_mode, addr,
+				   gen_int_mode (rat, address_mode));
 
 	  if (var_p)
-	    addr = gen_rtx_fmt_ee (PLUS, Pmode, addr, reg1);
+	    addr = gen_rtx_fmt_ee (PLUS, address_mode, addr, reg1);
 
 	  if (sym_p)
 	    {
-	      base = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (""));
+	      base = gen_rtx_SYMBOL_REF (address_mode, ggc_strdup (""));
 	      /* ??? We can run into trouble with some backends by presenting
 		 it with symbols which haven't been properly passed through
 		 targetm.encode_section_info.  By setting the local bit, we
@@ -3097,36 +3131,35 @@ get_address_cost (bool symbol_present, b
 	      SYMBOL_REF_FLAGS (base) = SYMBOL_FLAG_LOCAL;
 
 	      if (off_p)
-		base = gen_rtx_fmt_e (CONST, Pmode,
-				      gen_rtx_fmt_ee (PLUS, Pmode,
-						      base,
-						      gen_int_mode (off[mem_mode],
-								    Pmode)));
+		base = gen_rtx_fmt_e (CONST, address_mode,
+				      gen_rtx_fmt_ee
+					(PLUS, address_mode, base,
+					 gen_int_mode (off, address_mode)));
 	    }
 	  else if (off_p)
-	    base = gen_int_mode (off[mem_mode], Pmode);
+	    base = gen_int_mode (off, address_mode);
 	  else
 	    base = NULL_RTX;
     
 	  if (base)
-	    addr = gen_rtx_fmt_ee (PLUS, Pmode, addr, base);
+	    addr = gen_rtx_fmt_ee (PLUS, address_mode, addr, base);
   
 	  start_sequence ();
 	  /* To avoid splitting addressing modes, pretend that no cse will
 	     follow.  */
 	  old_cse_not_expected = cse_not_expected;
 	  cse_not_expected = true;
-	  addr = memory_address (mem_mode, addr);
+	  addr = memory_address_addr_space (mem_mode, addr, as);
 	  cse_not_expected = old_cse_not_expected;
 	  seq = get_insns ();
 	  end_sequence ();
 
 	  acost = seq_cost (seq, speed);
-	  acost += address_cost (addr, mem_mode, speed);
+	  acost += address_cost (addr, mem_mode, as, speed);
 
 	  if (!acost)
 	    acost = 1;
-	  costs[mem_mode][sym_p][var_p][off_p][rat_p] = acost;
+	  data->costs[sym_p][var_p][off_p][rat_p] = acost;
 	}
 
       /* On some targets, it is quite expensive to load symbol to a register,
@@ -3141,19 +3174,19 @@ get_address_cost (bool symbol_present, b
 	 If VAR_PRESENT is true, try whether the mode with
 	 SYMBOL_PRESENT = false is cheaper even with cost of addition, and
 	 if this is the case, use it.  */
-      add_c = add_cost (Pmode, speed);
+      add_c = add_cost (address_mode, speed);
       for (i = 0; i < 8; i++)
 	{
 	  var_p = i & 1;
 	  off_p = (i >> 1) & 1;
 	  rat_p = (i >> 2) & 1;
 
-	  acost = costs[mem_mode][0][1][off_p][rat_p] + 1;
+	  acost = data->costs[0][1][off_p][rat_p] + 1;
 	  if (var_p)
 	    acost += add_c;
 
-	  if (acost < costs[mem_mode][1][var_p][off_p][rat_p])
-	    costs[mem_mode][1][var_p][off_p][rat_p] = acost;
+	  if (acost < data->costs[1][var_p][off_p][rat_p])
+	    data->costs[1][var_p][off_p][rat_p] = acost;
 	}
   
       if (dump_file && (dump_flags & TDF_DETAILS))
@@ -3177,14 +3210,17 @@ get_address_cost (bool symbol_present, b
 	      if (rat_p)
 		fprintf (dump_file, "rat * ");
 
-	      acost = costs[mem_mode][sym_p][var_p][off_p][rat_p];
+	      acost = data->costs[sym_p][var_p][off_p][rat_p];
 	      fprintf (dump_file, "index costs %d\n", acost);
 	    }
 	  fprintf (dump_file, "\n");
 	}
+
+      VEC_replace (address_cost_data, address_cost_data_list,
+		   data_index, data);
     }
 
-  bits = GET_MODE_BITSIZE (Pmode);
+  bits = GET_MODE_BITSIZE (address_mode);
   mask = ~(~(unsigned HOST_WIDE_INT) 0 << (bits - 1) << 1);
   offset &= mask;
   if ((offset >> (bits - 1) & 1))
@@ -3193,18 +3229,18 @@ get_address_cost (bool symbol_present, b
 
   cost = 0;
   offset_p = (s_offset != 0
-	      && min_offset[mem_mode] <= s_offset
-	      && s_offset <= max_offset[mem_mode]);
+	      && data->min_offset <= s_offset
+	      && s_offset <= data->max_offset);
   ratio_p = (ratio != 1
-	     && multiplier_allowed_in_address_p (ratio, mem_mode));
+	     && multiplier_allowed_in_address_p (ratio, mem_mode, as));
 
   if (ratio != 1 && !ratio_p)
-    cost += multiply_by_cost (ratio, Pmode, speed);
+    cost += multiply_by_cost (ratio, address_mode, speed);
 
   if (s_offset && !offset_p && !symbol_present)
-    cost += add_cost (Pmode, speed);
+    cost += add_cost (address_mode, speed);
 
-  acost = costs[mem_mode][symbol_present][var_present][offset_p][ratio_p];
+  acost = data->costs[symbol_present][var_present][offset_p][ratio_p];
   complexity = (symbol_present != 0) + (var_present != 0) + offset_p + ratio_p;
   return new_cost (cost + acost, complexity);
 }
@@ -3421,6 +3457,7 @@ ptr_difference_cost (struct ivopts_data 
 		     unsigned HOST_WIDE_INT *offset, bitmap *depends_on)
 {
   HOST_WIDE_INT diff = 0;
+  enum machine_mode mode = TYPE_MODE (TREE_TYPE (e1));
   comp_cost cost;
   bool speed = optimize_loop_for_speed_p (data->current_loop);
 
@@ -3443,7 +3480,7 @@ ptr_difference_cost (struct ivopts_data 
   
   cost = force_var_cost (data, e1, depends_on);
   cost = add_costs (cost, force_var_cost (data, e2, depends_on));
-  cost.cost += add_cost (Pmode, speed);
+  cost.cost += add_cost (mode, speed);
 
   return cost;
 }
@@ -3619,7 +3656,9 @@ get_computation_cost_at (struct ivopts_d
   if (address_p)
     return add_costs (cost, get_address_cost (symbol_present, var_present,
 				offset, ratio,
-				TYPE_MODE (TREE_TYPE (*use->op_p)), speed));
+				TYPE_MODE (TREE_TYPE (*use->op_p)),
+				TYPE_ADDR_SPACE (TREE_TYPE (*use->op_p)),
+				speed));
 
   /* Otherwise estimate the costs for computing the expression.  */
   aratio = ratio > 0 ? ratio : -ratio;
@@ -5309,6 +5348,7 @@ rewrite_use_address (struct ivopts_data 
 {
   aff_tree aff;
   gimple_stmt_iterator bsi = gsi_for_stmt (use->stmt);
+  tree base_hint = NULL_TREE;
   tree ref;
   bool ok;
 
@@ -5316,7 +5356,22 @@ rewrite_use_address (struct ivopts_data 
   gcc_assert (ok);
   unshare_aff_combination (&aff);
 
-  ref = create_mem_ref (&bsi, TREE_TYPE (*use->op_p), &aff, data->speed);
+  /* To avoid undefined overflow problems, all IV candidates use unsigned
+     integer types.  The drawback is that this makes it impossible for
+     create_mem_ref to distinguish an IV that is based on a memory object
+     from one that represents simply an offset.
+
+     To work around this problem, we pass a hint to create_mem_ref that
+     indicates which variable (if any) in aff is an IV based on a memory
+     object.  Note that we only consider the candidate.  If this is not
+     based on an object, the base of the reference is in some subexpression
+     of the use -- but these will use pointer types, so they are recognized
+     by the create_mem_ref heuristics anyway.  */
+  if (cand->iv->base_object)
+    base_hint = var_at_stmt (data->current_loop, cand, use->stmt);
+
+  ref = create_mem_ref (&bsi, TREE_TYPE (*use->op_p), &aff, base_hint,
+			data->speed);
   copy_ref_info (ref, *use->op_p);
   *use->op_p = ref;
 }
diff -urNp gcc-4.4.4.orig/gcc/varasm.c gcc-4.4.4/gcc/varasm.c
--- a/src/gcc/varasm.c	2010-06-30
+++ b/src/gcc/varasm.c	2010-06-30
@@ -1189,11 +1189,17 @@ align_variable (tree decl, bool dont_out
 static section *
 get_variable_section (tree decl, bool prefer_noswitch_p)
 {
+  addr_space_t as = ADDR_SPACE_GENERIC;
   int reloc;
 
-  /* If the decl has been given an explicit section name, then it
-     isn't common, and shouldn't be handled as such.  */
-  if (DECL_COMMON (decl) && DECL_SECTION_NAME (decl) == NULL)
+  if (TREE_TYPE (decl) != error_mark_node)
+    as = TYPE_ADDR_SPACE (TREE_TYPE (decl));
+
+  /* If the decl has been given an explicit section name, or it resides
+     in a non-generic address space, then it isn't common, and shouldn't
+     be handled as such.  */
+  if (DECL_COMMON (decl) && DECL_SECTION_NAME (decl) == NULL
+      && ADDR_SPACE_GENERIC_P (as))
     {
       if (DECL_THREAD_LOCAL_P (decl))
 	return tls_comm_section;
@@ -1217,7 +1223,8 @@ get_variable_section (tree decl, bool pr
   if (IN_NAMED_SECTION (decl))
     return get_named_section (decl, NULL, reloc);
 
-  if (!DECL_THREAD_LOCAL_P (decl)
+  if (ADDR_SPACE_GENERIC_P (as)
+      && !DECL_THREAD_LOCAL_P (decl)
       && !(prefer_noswitch_p && targetm.have_switchable_bss_sections)
       && bss_initializer_p (decl))
     {
@@ -1461,7 +1468,15 @@ make_decl_rtl (tree decl)
   if (use_object_blocks_p () && use_blocks_for_decl_p (decl))
     x = create_block_symbol (name, get_block_for_decl (decl), -1);
   else
-    x = gen_rtx_SYMBOL_REF (Pmode, name);
+    {
+      enum machine_mode address_mode = Pmode;
+      if (TREE_TYPE (decl) != error_mark_node)
+	{
+	  addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (decl));
+	  address_mode = targetm.addr_space.address_mode (as);
+	}
+      x = gen_rtx_SYMBOL_REF (address_mode, name);
+    }
   SYMBOL_REF_WEAK (x) = DECL_WEAK (decl);
   SET_SYMBOL_REF_DECL (x, decl);
 
@@ -4373,7 +4388,7 @@ initializer_constant_valid_p_1 (tree val
       if (cache && cache[0] == value)
 	return cache[1];
       if (! INTEGRAL_TYPE_P (endtype)
-	  || TYPE_PRECISION (endtype) >= POINTER_SIZE)
+	  || TYPE_PRECISION (endtype) >= TYPE_PRECISION (TREE_TYPE (value)))
 	{
 	  tree ncache[4] = { NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE };
 	  tree valid0
@@ -4408,7 +4423,7 @@ initializer_constant_valid_p_1 (tree val
       if (cache && cache[0] == value)
 	return cache[1];
       if (! INTEGRAL_TYPE_P (endtype)
-	  || TYPE_PRECISION (endtype) >= POINTER_SIZE)
+	  || TYPE_PRECISION (endtype) >= TYPE_PRECISION (TREE_TYPE (value)))
 	{
 	  tree ncache[4] = { NULL_TREE, NULL_TREE, NULL_TREE, NULL_TREE };
 	  tree valid0
@@ -4503,7 +4518,9 @@ output_constant (tree exp, unsigned HOST
      resolving it.  */
   if (TREE_CODE (exp) == NOP_EXPR
       && POINTER_TYPE_P (TREE_TYPE (exp))
-      && targetm.valid_pointer_mode (TYPE_MODE (TREE_TYPE (exp))))
+      && targetm.addr_space.valid_pointer_mode
+	   (TYPE_MODE (TREE_TYPE (exp)),
+	    TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)))))
     {
       tree saved_type = TREE_TYPE (exp);
 
@@ -4511,7 +4528,9 @@ output_constant (tree exp, unsigned HOST
 	 pointer modes.  */
       while (TREE_CODE (exp) == NOP_EXPR
 	     && POINTER_TYPE_P (TREE_TYPE (exp))
-	     && targetm.valid_pointer_mode (TYPE_MODE (TREE_TYPE (exp))))
+	     && targetm.addr_space.valid_pointer_mode
+		  (TYPE_MODE (TREE_TYPE (exp)),
+		   TYPE_ADDR_SPACE (TREE_TYPE (TREE_TYPE (exp)))))
 	exp = TREE_OPERAND (exp, 0);
 
       /* If what we're left with is the address of something, we can
@@ -6437,14 +6456,6 @@ default_binds_local_p_1 (const_tree exp,
   return local_p;
 }
 
-/* Determine whether or not a pointer mode is valid. Assume defaults
-   of ptr_mode or Pmode - can be overridden.  */
-bool
-default_valid_pointer_mode (enum machine_mode mode)
-{
-  return (mode == ptr_mode || mode == Pmode);
-}
-
 /* Default function to output code that will globalize a label.  A
    target must define GLOBAL_ASM_OP or provide its own function to
    globalize a label.  */
diff -urNp gcc-4.4.4.orig/libgfortran/configure.ac gcc-4.4.4/libgfortran/configure.ac
--- a/src/libgfortran/configure.ac	2010-06-30
+++ b/src/libgfortran/configure.ac	2010-06-30
@@ -149,6 +149,27 @@ LDFLAGS="$save_LDFLAGS"
 AC_MSG_RESULT($gfortran_use_symver)
 AM_CONDITIONAL(LIBGFOR_USE_SYMVER, [test "x$gfortran_use_symver" = xyes])
 
+# Figure out whether the compiler supports "-ffunction-sections -fdata-sections",
+# similarly to how libstdc++ does it
+ac_test_CFLAGS="${CFLAGS+set}"
+ac_save_CFLAGS="$CFLAGS"
+
+# Check for -ffunction-sections -fdata-sections
+AC_MSG_CHECKING([for gcc that supports -ffunction-sections -fdata-sections])
+CFLAGS='-Werror -ffunction-sections -fdata-sections'
+AC_TRY_COMPILE(, [int foo;], [ac_fdsections=yes], [ac_fdsections=no])
+if test "$ac_test_CFLAGS" = set; then
+  CFLAGS="$ac_save_CFLAGS"
+else
+  # this is the suspicious part
+  CFLAGS=""
+fi
+if test x"$ac_fdsections" = x"yes"; then
+  SECTION_FLAGS='-ffunction-sections -fdata-sections'
+fi
+AC_MSG_RESULT($ac_fdsections)
+AC_SUBST(SECTION_FLAGS)
+
 # Find other programs we need.
 AC_CHECK_TOOL(AS, as)
 AC_CHECK_TOOL(AR, ar)
diff -urNp gcc-4.4.4.orig/libgfortran/Makefile.am gcc-4.4.4/libgfortran/Makefile.am
--- a/src/libgfortran/Makefile.am	2009-06-03
+++ b/src/libgfortran/Makefile.am	2010-06-30
@@ -33,6 +33,10 @@ AM_CPPFLAGS = -iquote$(srcdir)/io -I$(sr
 # Fortran rules for complex multiplication and division
 AM_CFLAGS += -fcx-fortran-rules
 
+# Use -ffunction-sections -fdata-sections if supported by the compiler
+SECTION_FLAGS = @SECTION_FLAGS@
+AM_CFLAGS += $(SECTION_FLAGS)
+
 gfor_io_src= \
 io/close.c \
 io/file_pos.c \
diff -urNp gcc-4.4.4.orig/libgfortran/Makefile.in gcc-4.4.4/libgfortran/Makefile.in
--- a/src/libgfortran/Makefile.in	2010-06-30
+++ b/src/libgfortran/Makefile.in	2010-06-30
@@ -300,7 +300,7 @@ AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 
 # Fortran rules for complex multiplication and division
-AM_CFLAGS = @AM_CFLAGS@ -fcx-fortran-rules
+AM_CFLAGS = @AM_CFLAGS@ -fcx-fortran-rules $(SECTION_FLAGS)
 AM_FCFLAGS = @AM_FCFLAGS@
 AR = @AR@
 AS = @AS@
@@ -360,6 +360,9 @@ PACKAGE_TARNAME = @PACKAGE_TARNAME@
 PACKAGE_VERSION = @PACKAGE_VERSION@
 PATH_SEPARATOR = @PATH_SEPARATOR@
 RANLIB = @RANLIB@
+
+# Use -ffunction-sections -fdata-sections if supported by the compiler
+SECTION_FLAGS = @SECTION_FLAGS@
 SED = @SED@
 SET_MAKE = @SET_MAKE@
 SHELL = @SHELL@
