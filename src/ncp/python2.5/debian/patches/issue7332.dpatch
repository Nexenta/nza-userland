#! /bin/sh -e

# DP: Proposed patch for issue #7332, segfaults in
# DP: PyMarshal_ReadLastObjectFromFile in import_submodule

dir=
if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
    dir="$3/"
elif [ $# -ne 1 ]; then
    echo >&2 "usage: `basename $0`: -patch|-unpatch [-d <srcdir>]"
    exit 1
fi
case "$1" in
    -patch)
        patch $pdir -f --no-backup-if-mismatch -p0 < $0
        ;;
    -unpatch)
        patch $pdir -f --no-backup-if-mismatch -R -p0 < $0
        ;;
    *)
	echo >&2 "usage: `basename $0`: -patch|-unpatch [-d <srcdir>]"
        exit 1
esac
exit 0

Index: Python/marshal.c
===================================================================
--- Python/marshal.c	(r√©vision 80154)
+++ Python/marshal.c	(copie de travail)
@@ -1126,23 +1126,13 @@
 PyObject *
 PyMarshal_ReadLastObjectFromFile(FILE *fp)
 {
-/* 75% of 2.1's .pyc files can exploit SMALL_FILE_LIMIT.
- * REASONABLE_FILE_LIMIT is by defn something big enough for Tkinter.pyc.
- */
-#define SMALL_FILE_LIMIT (1L << 14)
+/* REASONABLE_FILE_LIMIT is by defn something big enough for Tkinter.pyc. */
 #define REASONABLE_FILE_LIMIT (1L << 18)
 #ifdef HAVE_FSTAT
 	off_t filesize;
-#endif
-#ifdef HAVE_FSTAT
 	filesize = getfilesize(fp);
-	if (filesize > 0) {
-		char buf[SMALL_FILE_LIMIT];
-		char* pBuf = NULL;
-		if (filesize <= SMALL_FILE_LIMIT)
-			pBuf = buf;
-		else if (filesize <= REASONABLE_FILE_LIMIT)
-			pBuf = (char *)PyMem_MALLOC(filesize);
+	if (filesize > 0 && filesize <= REASONABLE_FILE_LIMIT) {
+		char* pBuf = (char *)PyMem_MALLOC(filesize);
 		if (pBuf != NULL) {
 			PyObject* v;
 			size_t n;
@@ -1150,8 +1140,7 @@
 			   is smaller than REASONABLE_FILE_LIMIT */
 			n = fread(pBuf, 1, (int)filesize, fp);
 			v = PyMarshal_ReadObjectFromString(pBuf, n);
-			if (pBuf != buf)
-				PyMem_FREE(pBuf);
+			PyMem_FREE(pBuf);
 			return v;
 		}
 
@@ -1162,7 +1151,6 @@
 	 */
 	return PyMarshal_ReadObjectFromFile(fp);
 
-#undef SMALL_FILE_LIMIT
 #undef REASONABLE_FILE_LIMIT
 }
 
