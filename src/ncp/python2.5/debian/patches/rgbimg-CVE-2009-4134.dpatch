#! /bin/sh -e

# DP: Fix multiple security issues in rgbimg module CVE-2009-4134, 
# DP: CVE-2010-1449 CVE-2010-1450).

dir=
if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
    dir="$3/"
elif [ $# -ne 1 ]; then
    echo >&2 "usage: `basename $0`: -patch|-unpatch [-d <srcdir>]"
    exit 1
fi
case "$1" in
    -patch)
        patch $pdir -f --no-backup-if-mismatch -p0 < $0
        ;;
    -unpatch)
        patch $pdir -f --no-backup-if-mismatch -R -p0 < $0
        ;;
    *)
	echo >&2 "usage: `basename $0`: -patch|-unpatch [-d <srcdir>]"
        exit 1
esac
exit 0

--- Modules/rgbimgmodule.c.orig	2010-11-28 16:17:39.860647406 +0000
+++ Modules/rgbimgmodule.c	2010-11-28 16:22:35.943148191 +0000
@@ -20,13 +20,8 @@
 typedef int Py_Int32;
 typedef unsigned int Py_UInt32;
 #else
-#if SIZEOF_LONG == 4
-typedef long Py_Int32;
-typedef unsigned long Py_UInt32;
-#else
 #error "No 4-byte integral type"
 #endif
-#endif
 
 #include <string.h>
 
@@ -92,7 +87,7 @@
 
 #define CHANOFFSET(z)	(3-(z))	/* this is byte order dependent */
 
-static void expandrow(unsigned char *, unsigned char *, int);
+static int expandrow(unsigned char *, unsigned char *, int, int);
 static void setalpha(unsigned char *, int);
 static void copybw(Py_Int32 *, int);
 static void interleaverow(unsigned char*, unsigned char*, int, int);
@@ -304,7 +299,10 @@
 		PyErr_NoMemory();
 		goto finally;
         }
+	if (image.zsize > 4)
+		goto corrupted;
 	if (rle) {
+		/* these can't oveflow, as xsize and ysize <= 0xffff and zsize <= 4 */
 		tablen = ysize * zsize * sizeof(Py_Int32);
 		starttab = (Py_Int32 *)malloc(tablen);
 		lengthtab = (Py_Int32 *)malloc(tablen);
@@ -336,6 +334,10 @@
 
 		fseek(inf, 512 + 2 * tablen, SEEK_SET);
 		cur = 512 + 2 * tablen;
+		if (ysize > 0 && xsize > (INT_MAX/sizeof(Py_Int32)-TAGLEN)/ysize) {
+			PyErr_NoMemory();
+			goto finally;
+		}
 		rv = PyString_FromStringAndSize((char *)NULL,
 				      (xsize * ysize + TAGLEN) * sizeof(Py_Int32));
 		if (rv == NULL)
@@ -359,15 +361,13 @@
 						cur = starttab[idx];
 					}
 					if (lengthtab[idx] > rlebuflen) {
-						PyErr_SetString(ImgfileError,
-							"rlebuf is too small");
-						Py_DECREF(rv);
-						rv = NULL;
-						goto finally;
+						PyErr_SetString(ImgfileError, "rlebuf is too small");
+						goto corrupted;
 					}
 					fread(rledat, lengthtab[idx], 1, inf);
 					cur += lengthtab[idx];
-					expandrow(lptr, rledat, 3-z);
+					if (expandrow(lptr, rledat, 3-z, xsize) != 0)
+						goto corrupted;
 					if (reverse_order)
 						lptr -= xsize
 						      * sizeof(Py_UInt32);
@@ -389,9 +389,14 @@
 						      SEEK_SET);
 						cur = starttab[idx];
 					}
+					if (lengthtab[idx] > rlebuflen) {
+						PyErr_SetString(ImgfileError, "rlebuf is too small");
+						goto corrupted;
+					}
 					fread(rledat, lengthtab[idx], 1, inf);
 					cur += lengthtab[idx];
-					expandrow(lptr, rledat, 3-z);
+					if (expandrow(lptr, rledat, 3-z, xsize) != 0)
+						goto corrupted;
 				}
 				if (reverse_order)
 					lptr -= xsize * sizeof(Py_UInt32);
@@ -405,6 +410,10 @@
 			copybw((Py_Int32 *) base, xsize * ysize);
 	}
 	else {
+		if (ysize > 0 && xsize > (INT_MAX/sizeof(Py_Int32)-TAGLEN)/ysize) {
+			PyErr_NoMemory();
+			goto finally;
+		}
 		rv = PyString_FromStringAndSize((char *) 0,
 					   (xsize*ysize+TAGLEN)*sizeof(Py_Int32));
 		if (rv == NULL)
@@ -440,6 +449,14 @@
 		else if (zsize < 3) 
 			copybw((Py_Int32 *) base, xsize * ysize);
 	}
+	goto finally;
+  corrupted:
+	PyErr_SetString(ImgfileError,
+			"input image file is corrupted");
+	if (rv) {
+		Py_DECREF(rv);
+		rv = NULL;
+	}
   finally:
 	if (starttab)
 		free(starttab);
@@ -507,8 +524,8 @@
 	}
 }
 
-static void
-expandrow(unsigned char *optr, unsigned char *iptr, int z)
+static int
+expandrow(unsigned char *optr, unsigned char *iptr, int z, int n)
 {
 	unsigned char pixel, count;
 
@@ -516,7 +533,12 @@
 	while (1) {
 		pixel = *iptr++;
 		if (!(count = (pixel & 0x7f)))
-			return;
+			return 0;
+		/* don't write more than n byte to output */
+		if (count > n)
+			return 1;
+		else
+			n -= count;
 		if (pixel & 0x80) {
 			while (count >= 8) {
 				optr[0 * 4] = iptr[0];
@@ -588,6 +610,14 @@
 	if (!PyArg_ParseTuple(args, "s#iiis:longstoimage", &lptr, &len,
 			      &xsize, &ysize, &zsize, &name))
 		return NULL;
+	
+	if (xsize < 0 || xsize > 0xffff
+			||  ysize < 0 || ysize > 0xffff
+			||  zsize < 0 || zsize > 4) {
+		PyErr_SetString(ImgfileError, "invalid xsize, ysize, or zsize");
+		return NULL;
+	}
+
 
 	goodwrite = 1;
 	outf = fopen(name, "wb");
@@ -595,8 +625,9 @@
 		PyErr_SetString(ImgfileError, "can't open output file");
 		return NULL;
 	}
-	tablen = ysize * zsize * sizeof(Py_Int32);
 
+	/* these can't oveflow, as xsize and ysize <= 0xffff and zsize <= 4 */
+	tablen = ysize * zsize * sizeof(Py_Int32);
 	starttab = (Py_Int32 *)malloc(tablen);
 	lengthtab = (Py_Int32 *)malloc(tablen);
 	rlebuflen = (int) (1.05 * xsize + 10);
