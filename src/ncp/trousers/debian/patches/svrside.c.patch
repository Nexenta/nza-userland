Index: trousers-0.3.4/src/tcsd/svrside.c
===================================================================
--- trousers-0.3.4.orig/src/tcsd/svrside.c	2011-04-14 20:24:32.154357262 +0400
+++ trousers-0.3.4/src/tcsd/svrside.c	2011-04-07 14:49:51.319381321 +0400
@@ -27,6 +27,13 @@
 #include <arpa/inet.h>
 #include <errno.h>
 #include <getopt.h>
+#ifdef SOLARIS
+#include <priv.h>
+#endif
+#ifndef HAVE_DAEMON
+#include <fcntl.h>
+#endif
+
 #include "trousers/tss.h"
 #include "trousers_types.h"
 #include "tcs_tsp.h"
@@ -206,6 +213,78 @@
 	return result;
 }
 
+#ifdef SOLARIS
+
+/*
+ * For Solaris, make the tcsd privilege aware and drop
+ * risky privileges if they are not needed.
+ */
+static int
+drop_privs()
+{
+	priv_set_t *myprivs;
+	int rv;
+
+	/*
+	 * Drop unneeded privs such as fork/exec.
+	 *
+	 * Get "basic" privs and remove the ones we don't want.
+	 */
+	if ((myprivs = priv_str_to_set("basic", ",", NULL)) == NULL) {
+		LogError("priv_str_to_set failed: %s", strerror(errno));
+		return (1);
+	} else {
+		(void) priv_delset(myprivs, PRIV_PROC_EXEC);
+		(void) priv_delset(myprivs, PRIV_PROC_FORK);
+		(void) priv_delset(myprivs, PRIV_FILE_LINK_ANY);
+		(void) priv_delset(myprivs, PRIV_PROC_INFO);
+		(void) priv_delset(myprivs, PRIV_PROC_SESSION);
+		(void) priv_delset(myprivs, PRIV_PROC_SETID);
+
+		/* for auditing */
+		(void) priv_addset(myprivs, PRIV_PROC_AUDIT);
+
+		if ((rv = setppriv(PRIV_SET, PRIV_PERMITTED, myprivs)))
+			return (rv);
+		if ((rv = setppriv(PRIV_SET, PRIV_LIMIT, myprivs)))
+			return (rv);
+		if ((rv = setppriv(PRIV_SET, PRIV_INHERITABLE, myprivs)))
+			return (rv);
+
+		(void) priv_freeset(myprivs);
+	}
+	return (0);
+}
+#endif /* SOLARIS */
+
+#ifndef HAVE_DAEMON
+static int
+daemon(int nochdir, int noclose) {
+	int rv, fd;
+
+	switch (fork()) {
+		case -1:
+			return (-1);
+		case 0:
+			break;
+		default:
+		exit (0);
+	}
+
+	if (setsid() == -1)
+		return (-1);
+	if (!nochdir)
+		(void) chdir("/");
+	if (!noclose && (fd = open("/dev/null", O_RDWR, 0)) != -1) {
+		(void) dup2(fd, STDIN_FILENO);
+		(void) dup2(fd, STDOUT_FILENO);
+		(void) dup2(fd, STDERR_FILENO);
+		if (fd > 2)
+			(void)close (fd);
+	}
+	return (0);
+}
+#endif /* !HAVE_DAEMON */
 
 int
 main(int argc, char **argv)
@@ -215,13 +294,18 @@
 	int sd, newsd, c, option_index = 0;
 	unsigned client_len;
 	char *hostname = NULL;
+#ifndef SOLARIS
 	struct passwd *pwd;
+#endif
 	struct hostent *client_hostent = NULL;
 	struct option long_options[] = {
 		{"help", 0, NULL, 'h'},
 		{"foreground", 0, NULL, 'f'},
 		{0, 0, 0, 0}
 	};
+#ifdef SOLARIS
+	int rv;
+#endif
 
 	while ((c = getopt_long(argc, argv, "fh", long_options, &option_index)) != -1) {
 		switch (c) {
@@ -263,6 +347,7 @@
 		LogError("Failed bind: %s", strerror(errno));
 		return -1;
 	}
+#ifndef SOLARIS
 	pwd = getpwnam(TSS_USER_NAME);
 	if (pwd == NULL) {
 		if (errno == 0) {
@@ -274,6 +359,7 @@
 		return TCSERR(TSS_E_INTERNAL_ERROR);
 	}
 	setuid(pwd->pw_uid);
+#endif
 	if (listen(sd, TCSD_MAX_SOCKETS_QUEUED) < 0) {
 		LogError("Failed listen: %s", strerror(errno));
 		return -1;
@@ -287,6 +373,11 @@
 			return -1;
 		}
 	}
+#ifdef SOLARIS
+	/* For Solaris, drop privileges for security. */
+	if ((rv = drop_privs()))
+	return (rv);
+#endif /* SOLARIS */
 
 	LogInfo("%s: TCSD up and running.", PACKAGE_STRING);
 	do {
