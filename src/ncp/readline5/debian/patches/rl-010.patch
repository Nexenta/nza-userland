Author: <doko@ubuntu.com>
Description: readline upstream patch readline52-010.
--- a/display.c
+++ b/display.c
@@ -910,6 +910,10 @@
 	     second and subsequent lines start at inv_lbreaks[N], offset by
 	     OFFSET (which has already been calculated above).  */
 
+#define INVIS_FIRST()	(prompt_physical_chars > _rl_screenwidth ? prompt_invis_chars_first_line : wrap_offset)
+#define WRAP_OFFSET(line, offset)  ((line == 0) \
+					? (offset ? INVIS_FIRST() : 0) \
+					: ((line == prompt_last_screen_line) ? wrap_offset-prompt_invis_chars_first_line : 0))
 #define W_OFFSET(line, offset) ((line) == 0 ? offset : 0)
 #define VIS_LLEN(l)	((l) > _rl_vis_botlin ? 0 : (vis_lbreaks[l+1] - vis_lbreaks[l]))
 #define INV_LLEN(l)	(inv_lbreaks[l+1] - inv_lbreaks[l])
@@ -944,7 +948,13 @@
 		  _rl_last_c_pos != o_cpos &&
 		  _rl_last_c_pos > wrap_offset &&
 		  o_cpos < prompt_last_invisible)
-		_rl_last_c_pos -= wrap_offset;
+		_rl_last_c_pos -= prompt_invis_chars_first_line;	/* XXX - was wrap_offset */
+	      else if (linenum == prompt_last_screen_line && prompt_physical_chars > _rl_screenwidth &&
+			(MB_CUR_MAX > 1 && rl_byte_oriented == 0) &&
+			cpos_adjusted == 0 &&
+			_rl_last_c_pos != o_cpos &&
+			_rl_last_c_pos > (prompt_last_invisible - _rl_screenwidth - prompt_invis_chars_first_line))
+		_rl_last_c_pos -= (wrap_offset-prompt_invis_chars_first_line);
 		  
 	      /* If this is the line with the prompt, we might need to
 		 compensate for invisible characters in the new line. Do
@@ -1204,7 +1214,7 @@
      int current_line, omax, nmax, inv_botlin;
 {
   register char *ofd, *ols, *oe, *nfd, *nls, *ne;
-  int temp, lendiff, wsatend, od, nd, o_cpos;
+  int temp, lendiff, wsatend, od, nd, twidth, o_cpos;
   int current_invis_chars;
   int col_lendiff, col_temp;
 #if defined (HANDLE_MULTIBYTE)
@@ -1220,7 +1230,7 @@
   if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
     temp = _rl_last_c_pos;
   else
-    temp = _rl_last_c_pos - W_OFFSET(_rl_last_v_pos, visible_wrap_offset);
+    temp = _rl_last_c_pos - WRAP_OFFSET (_rl_last_v_pos, visible_wrap_offset);
   if (temp == _rl_screenwidth && _rl_term_autowrap && !_rl_horizontal_scroll_mode
 	&& _rl_last_v_pos == current_line - 1)
     {
@@ -1569,11 +1579,16 @@
 	    }
 	  else
 	    {
-	      /* We have horizontal scrolling and we are not inserting at
-		 the end.  We have invisible characters in this line.  This
-		 is a dumb update. */
 	      _rl_output_some_chars (nfd, temp);
 	      _rl_last_c_pos += col_temp;
+	      /* If nfd begins before any invisible characters in the prompt,
+		 adjust _rl_last_c_pos to account for wrap_offset and set
+		 cpos_adjusted to let the caller know. */
+	      if (current_line == 0 && wrap_offset && ((nfd - new) <= prompt_last_invisible))
+		{
+		  _rl_last_c_pos -= wrap_offset;
+		  cpos_adjusted = 1;
+		}
 	      return;
 	    }
 	  /* Copy (new) chars to screen from first diff to last match. */
@@ -1581,15 +1596,15 @@
 	  if ((temp - lendiff) > 0)
 	    {
 	      _rl_output_some_chars (nfd + lendiff, temp - lendiff);
-#if 1
 	     /* XXX -- this bears closer inspection.  Fixes a redisplay bug
 		reported against bash-3.0-alpha by Andreas Schwab involving
 		multibyte characters and prompt strings with invisible
 		characters, but was previously disabled. */
-	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
-#else
-	      _rl_last_c_pos += _rl_col_width (nfd+lendiff, 0, temp-lendiff);
-#endif
+	      if (MB_CUR_MAX > 1 && rl_byte_oriented == 0)
+		twidth = _rl_col_width (nfd+lendiff, 0, temp-col_lendiff);
+	      else
+		twidth = temp - lendiff;
+	      _rl_last_c_pos += twidth;
 	    }
 	}
       else
@@ -1783,7 +1798,7 @@
   int woff;			/* number of invisible chars on current line */
   int cpos, dpos;		/* current and desired cursor positions */
 
-  woff = W_OFFSET (_rl_last_v_pos, wrap_offset);
+  woff = WRAP_OFFSET (_rl_last_v_pos, wrap_offset);
   cpos = _rl_last_c_pos;
 #if defined (HANDLE_MULTIBYTE)
   /* If we have multibyte characters, NEW is indexed by the buffer point in
