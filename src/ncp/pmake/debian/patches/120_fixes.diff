--- pmake-1.111.orig/arch.c
+++ pmake-1.111/arch.c
@@ -173,7 +173,7 @@
 static FILE *ArchFindMember(char *, char *, struct ar_hdr *, const char *);
 #if defined(__svr4__) || defined(__SVR4) || defined(__ELF__)
 #define SVR4ARCHIVES
-static int ArchSVR4Entry(Arch *, char *, size_t, FILE *);
+static int ArchSVR4Entry(Arch *, char **, size_t, FILE *);
 #endif
 
 #ifdef CLEANUP
@@ -535,7 +535,7 @@
     Arch	  *ar;	      /* Archive descriptor */
     Hash_Entry	  *he;	      /* Entry containing member's description */
     struct ar_hdr arh;        /* archive-member header for reading archive */
-    char	  memName[MAXPATHLEN+1];
+    char	  *memName = NULL; 
     	    	    	    /* Current member name while hashing. */
 
     /*
@@ -617,7 +617,6 @@
     ar->fnametab = NULL;
     ar->fnamesize = 0;
     Hash_InitTable(&ar->members, -1);
-    memName[AR_MAX_NAME_LEN] = '\0';
 
     while (fread ((char *)&arh, sizeof (struct ar_hdr), 1, arch) == 1) {
 	if (strncmp ( arh.ar_fmag, ARFMAG, sizeof (arh.ar_fmag)) != 0) {
@@ -636,10 +635,9 @@
 	    arh.ar_size[sizeof(arh.ar_size)-1] = '\0';
 	    size = (int) strtol(arh.ar_size, NULL, 10);
 
-	    (void) strncpy (memName, arh.ar_name, sizeof(arh.ar_name));
-	    for (cp = &memName[AR_MAX_NAME_LEN]; *cp == ' '; cp--) {
-		continue;
-	    }
+	    memName = estrdup(arh.ar_name);
+
+	    for(cp = strchr(memName, 0)-1; *cp == ' '; cp--);
 	    cp[1] = '\0';
 
 #ifdef SVR4ARCHIVES
@@ -650,7 +648,7 @@
 		/*
 		 * svr4 magic mode; handle it
 		 */
-		switch (ArchSVR4Entry(ar, memName, size, arch)) {
+		switch (ArchSVR4Entry(ar, &memName, size, arch)) {
 		case -1:  /* Invalid data */
 		    goto badarch;
 		case 0:	  /* List of files entry */
@@ -675,8 +673,8 @@
 
 		unsigned int elen = atoi(&memName[sizeof(AR_EFMT1)-1]);
 
-		if (elen > MAXPATHLEN)
-			goto badarch;
+		memName = erealloc(memName, elen+1);
+		
 		if (fread (memName, elen, 1, arch) != 1)
 			goto badarch;
 		memName[elen] = '\0';
@@ -692,6 +690,9 @@
 	    memcpy ((Address)Hash_GetValue (he), (Address)&arh,
 		sizeof (struct ar_hdr));
 	}
+	/* time to free memName */
+	free(memName);
+
 	fseek (arch, (size + 1) & ~1, SEEK_CUR);
     }
 
@@ -742,15 +743,15 @@
  *-----------------------------------------------------------------------
  */
 static int
-ArchSVR4Entry(Arch *ar, char *name, size_t size, FILE *arch)
+ArchSVR4Entry(Arch *ar, char **name, size_t size, FILE *arch)
 {
 #define ARLONGNAMES1 "//"
 #define ARLONGNAMES2 "/ARFILENAMES"
     size_t entry;
     char *ptr, *eptr;
 
-    if (strncmp(name, ARLONGNAMES1, sizeof(ARLONGNAMES1) - 1) == 0 ||
-	strncmp(name, ARLONGNAMES2, sizeof(ARLONGNAMES2) - 1) == 0) {
+    if (strncmp(*name, ARLONGNAMES1, sizeof(ARLONGNAMES1) - 1) == 0 ||
+	strncmp(*name, ARLONGNAMES2, sizeof(ARLONGNAMES2) - 1) == 0) {
 
 	if (ar->fnametab != NULL) {
 	    if (DEBUG(ARCH)) {
@@ -793,30 +794,30 @@
 	return 0;
     }
 
-    if (name[1] == ' ' || name[1] == '\0')
+    if ((*name)[1] == ' ' || (*name)[1] == '\0')
 	return 2;
 
-    entry = (size_t) strtol(&name[1], &eptr, 0);
-    if ((*eptr != ' ' && *eptr != '\0') || eptr == &name[1]) {
+    entry = (size_t) strtol(&(*name)[1], &eptr, 0);
+    if ((*eptr != ' ' && *eptr != '\0') || eptr == &(*name)[1]) {
 	if (DEBUG(ARCH)) {
-	    printf("Could not parse SVR4 name %s\n", name);
+	    printf("Could not parse SVR4 name %s\n", *name);
 	}
 	return 2;
     }
     if (entry >= ar->fnamesize) {
 	if (DEBUG(ARCH)) {
 	    printf("SVR4 entry offset %s is greater than %lu\n",
-		   name, (u_long)ar->fnamesize);
+		   *name, (u_long)ar->fnamesize);
 	}
 	return 2;
     }
 
     if (DEBUG(ARCH)) {
-	printf("Replaced %s with %s\n", name, &ar->fnametab[entry]);
+	printf("Replaced %s with %s\n", *name, &ar->fnametab[entry]);
     }
 
-    (void) strncpy(name, &ar->fnametab[entry], MAXPATHLEN);
-    name[MAXPATHLEN] = '\0';
+		free(*name);
+		*name = estrdup(&ar->fnametab[entry]);
     return 1;
 }
 #endif
@@ -926,12 +927,9 @@
 		isdigit((unsigned char)arhPtr->ar_name[sizeof(AR_EFMT1) - 1])) {
 
 		unsigned int elen = atoi(&arhPtr->ar_name[sizeof(AR_EFMT1)-1]);
-		char ename[MAXPATHLEN];
+		char *ename = NULL;
 
-		if (elen > MAXPATHLEN) {
-			fclose (arch);
-			return NULL;
-		}
+		ename = emalloc(elen+1);
 		if (fread (ename, elen, 1, arch) != 1) {
 			fclose (arch);
 			return NULL;
@@ -945,6 +943,8 @@
 			fseek (arch, -sizeof(struct ar_hdr) - elen, SEEK_CUR);
 			return (arch);
 		}
+		/* time to free ename */
+		free(ename);
 		fseek (arch, -elen, SEEK_CUR);
 		goto skip;
 	} else
--- pmake-1.111.orig/buf.c
+++ pmake-1.111/buf.c
@@ -192,7 +192,8 @@
 {
 
     if (numBytesPtr != (int *)NULL) {
-	*numBytesPtr = bp->inPtr - bp->outPtr;
+	intptr_t num = bp->inPtr - bp->outPtr;
+	*numBytesPtr = num;
     }
 
     return (bp->outPtr);
--- pmake-1.111.orig/compat.c
+++ pmake-1.111/compat.c
@@ -130,7 +130,7 @@
 
     Shell_Init();		/* setup default shell */
     
-    for (cp = "#=|^(){};&<>*?[]:$`\\\n"; *cp != '\0'; cp++) {
+    for (cp = "~#=|^(){};&<>*?[]:$`\\\n"; *cp != '\0'; cp++) {
 	meta[(unsigned char) *cp] = 1;
     }
     /*
@@ -498,7 +498,7 @@
 	    }
 	    goto cohorts;
 	} else if (DEBUG(MAKE)) {
-	    printf("out-of-date.\n");
+	    printf("out-of-date\n");
 	}
 
 	/*
--- pmake-1.111.orig/job.c
+++ pmake-1.111/job.c
@@ -2162,7 +2162,8 @@
 	    (void) fprintf(stdout, "Remaking `%s'\n", gn->name);
   	    (void) fflush(stdout);
 	    (void) strcpy(job->outFile, TMPPAT);
-	    job->outFd = mkstemp(job->outFile);
+	    if ((job->outFd = mkstemp(job->outFile)) == -1)
+	       Punt("Cannot create temp file: %s", strerror(errno));
 	    (void) fcntl(job->outFd, F_SETFD, 1);
 	}
     }
--- pmake-1.111.orig/main.c
+++ pmake-1.111/main.c
@@ -825,7 +825,10 @@
 	 * in a different format).
 	 */
 #ifdef POSIX
-	Main_ParseArgLine(getenv("MAKEFLAGS"));
+	/*
+	 * If we are called by GNU make, do not read MAKEFLAGS.
+	 */
+	Main_ParseArgLine(getenv(getenv("MAKELEVEL") ? "MAKE" : "MAKEFLAGS"));
 #else
 	Main_ParseArgLine(getenv("MAKE"));
 #endif
@@ -1149,6 +1152,9 @@
 	}
 	free(path);
 	return(TRUE);
+	/* `path' is not freed before return because its
+	 * pointer is stored somewhere else
+	 */
 }
 
 
--- pmake-1.111.orig/make.1
+++ pmake-1.111/make.1
@@ -33,7 +33,7 @@
 .Dt MAKE 1
 .Os
 .Sh NAME
-.Nm make
+.Nm pmake
 .Nd maintain program dependencies
 .Sh SYNOPSIS
 .Nm
@@ -1233,7 +1233,7 @@
 .It Ic defined
 Takes a variable name as an argument and evaluates to true if the variable
 has been defined.
-.It Ic make
+.It Ic pmake
 Takes a target name as an argument and evaluates to true if the target
 was specified as part of
 .Nm Ns 's
@@ -1602,7 +1602,6 @@
 .Sh SEE ALSO
 .Xr mkdep 1
 .Sh HISTORY
-A
-.Nm
+A make
 command appeared in
 .At v7 .
--- pmake-1.111.orig/var.c
+++ pmake-1.111/var.c
@@ -124,6 +124,7 @@
  */
 
 #ifndef NO_REGEX
+#include    <stdio.h>
 #include    <sys/types.h>
 #include    <regex.h>
 #endif
