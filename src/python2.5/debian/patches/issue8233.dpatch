#! /bin/sh -e

# DP: Issue #8233: When run as a script, py_compile.py optionally takes a single
# DP: argument `-`. Backport from the trunk.

dir=
if [ $# -eq 3 -a "$2" = '-d' ]; then
    pdir="-d $3"
    dir="$3/"
elif [ $# -ne 1 ]; then
    echo >&2 "usage: `basename $0`: -patch|-unpatch [-d <srcdir>]"
    exit 1
fi
case "$1" in
    -patch)
        patch $pdir -f --no-backup-if-mismatch -p0 < $0
        ;;
    -unpatch)
        patch $pdir -f --no-backup-if-mismatch -R -p0 < $0
        ;;
    *)
	echo >&2 "usage: `basename $0`: -patch|-unpatch [-d <srcdir>]"
        exit 1
esac
exit 0

--- Lib/py_compile.py.orig	2005-06-10 17:15:18.000000000 +0000
+++ Lib/py_compile.py	2010-04-21 08:57:46.247252903 +0000
@@ -149,16 +149,36 @@
     not specified) are compiled and the resulting bytecode is cached
     in the normal manner.  This function does not search a directory
     structure to locate source files; it only compiles files named
-    explicitly.
+    explicitly.  If '-' is the only parameter in args, the list of
+    files is taken from standard input.
 
     """
     if args is None:
         args = sys.argv[1:]
-    for filename in args:
-        try:
-            compile(filename, doraise=True)
-        except PyCompileError,err:
-            sys.stderr.write(err.msg)
+    rv = 0
+    if args == ['-']:
+        while True:
+            filename = sys.stdin.readline()
+            if not filename:
+                break
+            filename = filename.rstrip('\n')
+            try:
+                compile(filename, doraise=True)
+            except PyCompileError, error:
+                rv = 1
+                sys.stderr.write("%s\n" % error.msg)
+            except IOError, error:
+                rv = 1
+                sys.stderr.write("%s\n" % error)
+    else:
+        for filename in args:
+            try:
+                compile(filename, doraise=True)
+            except PyCompileError, error:
+                # return value to indicate at least one failure
+                rv = 1
+                sys.stderr.write(error.msg)
+    return rv
 
 if __name__ == "__main__":
     main()
